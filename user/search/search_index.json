{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BioDynaMo What is BioDynaMo? BioDynaMo is a platform through which life scientists can easily create, run, and visualise three-dimensional biological simulations. Built on top of the latest computing technologies, the BioDynaMo platform will enable users to perform simulations of previously unachievable scale and complexity, making it possible to tackle challenging scientific research questions. Important Notes Version This guide corresponds to the latest version of BioDynaMo. Please make sure that your installation has the exact same version string as indicated at the top of the API documentation . Please head over to our installation/update instructions if you haven't installed BioDynaMo yet, or the installation is outdated. Execute biodynamo - v to check which version is installed on your system. The version string will look like: v0 . 1 . 0 - 84 - g4ed0045 . This is how you can interpret it: vMAJOR . MINOR . PATCH - ADDITIONAL_COMMITS - gCOMMIT_ID Unstable API BioDynaMo is in an early development stage. Therefore, our API changes quite rapidly as we learn new requirements from our users. In case your simulation does not compile after an update, please have a look at our changelog and update your code.","title":"Welcome"},{"location":"#welcome-to-biodynamo","text":"","title":"Welcome to BioDynaMo"},{"location":"#what-is-biodynamo","text":"BioDynaMo is a platform through which life scientists can easily create, run, and visualise three-dimensional biological simulations. Built on top of the latest computing technologies, the BioDynaMo platform will enable users to perform simulations of previously unachievable scale and complexity, making it possible to tackle challenging scientific research questions.","title":"What is BioDynaMo?"},{"location":"#important-notes","text":"","title":"Important Notes"},{"location":"#version","text":"This guide corresponds to the latest version of BioDynaMo. Please make sure that your installation has the exact same version string as indicated at the top of the API documentation . Please head over to our installation/update instructions if you haven't installed BioDynaMo yet, or the installation is outdated. Execute biodynamo - v to check which version is installed on your system. The version string will look like: v0 . 1 . 0 - 84 - g4ed0045 . This is how you can interpret it: vMAJOR . MINOR . PATCH - ADDITIONAL_COMMITS - gCOMMIT_ID","title":"Version"},{"location":"#unstable-api","text":"BioDynaMo is in an early development stage. Therefore, our API changes quite rapidly as we learn new requirements from our users. In case your simulation does not compile after an update, please have a look at our changelog and update your code.","title":"Unstable API"},{"location":"changelog/","text":"Changelog 11.09.2019 0719 cd6 Add SBML integration. Currently SBML is not supported on MacOS (see https://trello.com/c/vKPbh4iG ). 05.08.2019 / d7bab00 Major improvements of the BioDynaMo's build system. Refactor build procedure. Improve dependency detection and diagnostic messages for the user. Rename biodynamo - env . sh to thisbdm . sh . BioDynaMo can be used directly from the build directory. The install step has become optional. Improve user and developer guide. 20.06.2019 257 f1a3 Add support for multiscale simulations. 14.06.2019 cb15679 Release BioDynaMo dynamic. This is a more user-friendly version of BioDynaMo. It removes most template code, and does not require compile time parameters, resulting in a simpler API. However, this comes at a small cost in performance. In due time we hope to regain the lost performance. There are too many small API changes to present an exhaustive list here. We recommend to have a look at the demo folder folder or directly inspect the changes of the demo folder. 31.01.2019 3 a51e76 Improve file structure in directory src/ and test/unit API changes Old New SimulationObject SimObject 21.01.2019 1968 ec2 This commit introduces a series of changes to encapsulate different discretization strategies. Other modifications have been made along the way to facilitate this change and solve known issues. Discretization governs three main questions: When should new simulation objects be visible? When should simulation objects be removed from the simulation? If a simulation object is updated, when should the change be visible? Should operations observe the values from the last iteration or from the previous operation? Since simulations might have different requirements, this commit introduces execution contexts to define and encapsulate this behavior in one place. First , this commit introduces unique ids for simulation objects that stay constant during the whole simulation and are not reused if a simulation object is removed from the simulation. Among other things, this improves debugging simulations. Second , building upon the introduction of unique ids, manual updates of SoPointer (references to another simulation object--e.g. NeuriteElement :: daughter_left_ ) becomes obsolete. This is now managed by the ResourceManager . Third , this commit adds an in-place execution context. Simulation objects that are added or removed are visible to the whole simulation after the next timestep. Operations directly modify simulation objects inside the ResourceManager . Thus, the result depends on the order in which sim objects are updated. Operations (biology modules or mechanical interactions) see the updated values from the previous operation. Forth , this commit solves two race condition issues: Adding new simulation objects to the ResourceManager caused issues if it triggered a growth. References and pointers to simulation objects were invalidated during this operation. Modifications of neighbors. Two threads could potentially update the same neighbor. Fifth , result from mechanical interactions will change. Up to now the implementation was inconsistent with respect to when updates will take effect. Biology modules were updated in place, while results from mechanical interactions where cached and applied once all simulation objects have been updated. Now, this behavior is the responsibility of the execution context. In case of the InPlaceExecutionContext this means that during iteration t some cells observe neighbors that have already been updated to timestep t ' . API changes Several API changes were necessary to implement the described functionality. A general rule is to use the new execution context to perform actions instead of using the ResourceManager , or Grid directly. The thread local execution context can be obtained from the simulation object (e.g. calling sim -> GetExecutionContext () ). Exemplary API changes: Method ResourceManager :: New was removed. During a simulation only use e.g. InPlaceExecutionContext :: New . During setup of the initial model using ResourceManager :: push_back is also fine. Method ResourceManager :: Get has been changed to return a const pointer. Thus rm -> Get < Cell > () -> push_back ( new_cell ) won't work anymore. However, calling rm -> Get < Cell > () -> size () is still fine. For the full set of changes that are visible to the user, it is best to have a look at the demo folder and the differences of this commit . 25.10.2018 b197542 Resolve ROOT-9321 by removing TBase template parameter of simulation objects Motivation: Workaround for ROOT-9321 Shortens full name of simulation objects Move duplicated biology module code from Cell and NeuriteELement to SimulationObject This change requires a different signature of BDM_SIM_OBJECT_HEADER . Remove the suffix Ext from the first parameter Add the base class name as a second parameter. In other words, copy the parameters from BDM_SIM_OBJECT to the beginning of BDM_SIM_OBJECT_HEADER class Cell : public SimulationObject { BDM_SIM_OBJECT_HEADER ( Cell , SimulationObject , 1 , ...) Old New BDM_SIM_OBJECT_HEADER ( CellExt , 1 , ...) BDM_SIM_OBJECT_HEADER ( Cell , SimulationObject , 1 , ...) 08.10.2018 8 a97cf2 Allow builds without dictionaries to speed up compile time Early development of a simulation requires fast iteration cycles. During this stage serialization features are not needed. Thus, we support builds without dictionaries. By default dictionaries will be built. To turn them off, run: cmake -Ddict=off .. Old New ClassDef(...) BDM_CLASS_DEF(...) ClassDefNV(...) BDM_CLASS_DEF_NV(...) 18.09.2018 3 a380e4 Refactor parameters . Add functionality to define compile time parameters for a specific simulation object. This was necessary due to compile time errors of neurite biology modules. (Although they were not used for neurons, the compiler tried to compile them) This replaces the reinterpret cast workaround. Simulation :: GetActive () -> GetParam () returns const pointer Runtime parameter should not be changed during the simulation. This simplifies the distributed runtime. Add macros to simplify definition of compile time parameter. All compile time parameter that take more than one type will be defined using CTList . No more distinction between Variant and VariadicTypedef . Improve modularity. Each module can have its own parameter class. All parameter classes will be combined into CompileTimeParam :: Param . Make all runtime parameters non static. Rename AtomicTypes to SimObjectTypes Please have a look at the changes of the demos to see which lines need to be changed in your simulation after this commit . 29.08.2018 a373fca Add the concept of Events . This is an important change to support extensibility. Now, there is a clear way to tell BioDynaMo what should happen with a new data member for a specific event. Old New gAllBmEvents gAllEventIds gNullEvent gNullEventId gCellDivision CellDivisionEvent :: kEventId gNeuriteElongation SplitNeuriteElementEvent :: kEventId gNeuriteBranching NeuriteBranchingEvent :: kEventId gNeuriteBifurcation NeuriteBifurcationEvent :: kEventId gNeuriteSideCylinderExtension SideNeuriteExtensionEvent :: kEventId Simulation objects and biology modules must have an event constructor and event handler function in order to support an event. 16.07.2018 3 bac827 Change github option for biodynamo new . Previously it was opt-out ( --no-github ). This commit changes it to opt-in ( --github ). Old New biodynamo new --no-github biodynamo new biodynamo new biodynamo new --github 11.07.2018 82 e7e15 Add biodynamo demo command to try out the demos biodynamo demo lists all the available demos biodynamo demo < demo - name > < dir > sets up the demo < demo - name > in directory < dir > . If < dir > is not specified, it defaults to the current working directory. 26.06.2018 ba4fe1f Add support for multiple simulations per process. Only one simulation can be active at the same time. Introduces new class Simulation (see API ). This change causes many API changes -- see subsection below. Write simulation files to separate directory: output / simulation - id / Integrate simulation template for biodynamo new into the biodynamo repository to avoid inconsistencies with the biodynamo version. Old New InitializeBioDynaMo (...) Simulation simulation (...) Rm () TRm :: Get () TResourceManager :: Get () auto * rm = simulation . GetResourceManager (); GetDiffusionGrid (...) rm -> GetDiffusionGrid (...) Grid :: GetInstance () auto * grid = simulation . GetGrid (); Param :: some_parameter_ ; auto * param = simulation . GetParam (); param -> some_parameter_ ;","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#11092019-0719cd6","text":"Add SBML integration. Currently SBML is not supported on MacOS (see https://trello.com/c/vKPbh4iG ).","title":"11.09.2019 0719cd6"},{"location":"changelog/#05082019-d7bab00","text":"Major improvements of the BioDynaMo's build system. Refactor build procedure. Improve dependency detection and diagnostic messages for the user. Rename biodynamo - env . sh to thisbdm . sh . BioDynaMo can be used directly from the build directory. The install step has become optional. Improve user and developer guide.","title":"05.08.2019 /d7bab00"},{"location":"changelog/#20062019-257f1a3","text":"Add support for multiscale simulations.","title":"20.06.2019 257f1a3"},{"location":"changelog/#14062019-cb15679","text":"Release BioDynaMo dynamic. This is a more user-friendly version of BioDynaMo. It removes most template code, and does not require compile time parameters, resulting in a simpler API. However, this comes at a small cost in performance. In due time we hope to regain the lost performance. There are too many small API changes to present an exhaustive list here. We recommend to have a look at the demo folder folder or directly inspect the changes of the demo folder.","title":"14.06.2019 cb15679"},{"location":"changelog/#31012019-3a51e76","text":"Improve file structure in directory src/ and test/unit API changes Old New SimulationObject SimObject","title":"31.01.2019 3a51e76"},{"location":"changelog/#21012019-1968ec2","text":"This commit introduces a series of changes to encapsulate different discretization strategies. Other modifications have been made along the way to facilitate this change and solve known issues. Discretization governs three main questions: When should new simulation objects be visible? When should simulation objects be removed from the simulation? If a simulation object is updated, when should the change be visible? Should operations observe the values from the last iteration or from the previous operation? Since simulations might have different requirements, this commit introduces execution contexts to define and encapsulate this behavior in one place. First , this commit introduces unique ids for simulation objects that stay constant during the whole simulation and are not reused if a simulation object is removed from the simulation. Among other things, this improves debugging simulations. Second , building upon the introduction of unique ids, manual updates of SoPointer (references to another simulation object--e.g. NeuriteElement :: daughter_left_ ) becomes obsolete. This is now managed by the ResourceManager . Third , this commit adds an in-place execution context. Simulation objects that are added or removed are visible to the whole simulation after the next timestep. Operations directly modify simulation objects inside the ResourceManager . Thus, the result depends on the order in which sim objects are updated. Operations (biology modules or mechanical interactions) see the updated values from the previous operation. Forth , this commit solves two race condition issues: Adding new simulation objects to the ResourceManager caused issues if it triggered a growth. References and pointers to simulation objects were invalidated during this operation. Modifications of neighbors. Two threads could potentially update the same neighbor. Fifth , result from mechanical interactions will change. Up to now the implementation was inconsistent with respect to when updates will take effect. Biology modules were updated in place, while results from mechanical interactions where cached and applied once all simulation objects have been updated. Now, this behavior is the responsibility of the execution context. In case of the InPlaceExecutionContext this means that during iteration t some cells observe neighbors that have already been updated to timestep t ' . API changes Several API changes were necessary to implement the described functionality. A general rule is to use the new execution context to perform actions instead of using the ResourceManager , or Grid directly. The thread local execution context can be obtained from the simulation object (e.g. calling sim -> GetExecutionContext () ). Exemplary API changes: Method ResourceManager :: New was removed. During a simulation only use e.g. InPlaceExecutionContext :: New . During setup of the initial model using ResourceManager :: push_back is also fine. Method ResourceManager :: Get has been changed to return a const pointer. Thus rm -> Get < Cell > () -> push_back ( new_cell ) won't work anymore. However, calling rm -> Get < Cell > () -> size () is still fine. For the full set of changes that are visible to the user, it is best to have a look at the demo folder and the differences of this commit .","title":"21.01.2019 1968ec2"},{"location":"changelog/#25102018-b197542","text":"Resolve ROOT-9321 by removing TBase template parameter of simulation objects Motivation: Workaround for ROOT-9321 Shortens full name of simulation objects Move duplicated biology module code from Cell and NeuriteELement to SimulationObject This change requires a different signature of BDM_SIM_OBJECT_HEADER . Remove the suffix Ext from the first parameter Add the base class name as a second parameter. In other words, copy the parameters from BDM_SIM_OBJECT to the beginning of BDM_SIM_OBJECT_HEADER class Cell : public SimulationObject { BDM_SIM_OBJECT_HEADER ( Cell , SimulationObject , 1 , ...) Old New BDM_SIM_OBJECT_HEADER ( CellExt , 1 , ...) BDM_SIM_OBJECT_HEADER ( Cell , SimulationObject , 1 , ...)","title":"25.10.2018 b197542"},{"location":"changelog/#08102018-8a97cf2","text":"Allow builds without dictionaries to speed up compile time Early development of a simulation requires fast iteration cycles. During this stage serialization features are not needed. Thus, we support builds without dictionaries. By default dictionaries will be built. To turn them off, run: cmake -Ddict=off .. Old New ClassDef(...) BDM_CLASS_DEF(...) ClassDefNV(...) BDM_CLASS_DEF_NV(...)","title":"08.10.2018 8a97cf2"},{"location":"changelog/#18092018-3a380e4","text":"Refactor parameters . Add functionality to define compile time parameters for a specific simulation object. This was necessary due to compile time errors of neurite biology modules. (Although they were not used for neurons, the compiler tried to compile them) This replaces the reinterpret cast workaround. Simulation :: GetActive () -> GetParam () returns const pointer Runtime parameter should not be changed during the simulation. This simplifies the distributed runtime. Add macros to simplify definition of compile time parameter. All compile time parameter that take more than one type will be defined using CTList . No more distinction between Variant and VariadicTypedef . Improve modularity. Each module can have its own parameter class. All parameter classes will be combined into CompileTimeParam :: Param . Make all runtime parameters non static. Rename AtomicTypes to SimObjectTypes Please have a look at the changes of the demos to see which lines need to be changed in your simulation after this commit .","title":"18.09.2018 3a380e4"},{"location":"changelog/#29082018-a373fca","text":"Add the concept of Events . This is an important change to support extensibility. Now, there is a clear way to tell BioDynaMo what should happen with a new data member for a specific event. Old New gAllBmEvents gAllEventIds gNullEvent gNullEventId gCellDivision CellDivisionEvent :: kEventId gNeuriteElongation SplitNeuriteElementEvent :: kEventId gNeuriteBranching NeuriteBranchingEvent :: kEventId gNeuriteBifurcation NeuriteBifurcationEvent :: kEventId gNeuriteSideCylinderExtension SideNeuriteExtensionEvent :: kEventId Simulation objects and biology modules must have an event constructor and event handler function in order to support an event.","title":"29.08.2018 a373fca"},{"location":"changelog/#16072018-3bac827","text":"Change github option for biodynamo new . Previously it was opt-out ( --no-github ). This commit changes it to opt-in ( --github ). Old New biodynamo new --no-github biodynamo new biodynamo new biodynamo new --github","title":"16.07.2018 3bac827"},{"location":"changelog/#11072018-82e7e15","text":"Add biodynamo demo command to try out the demos biodynamo demo lists all the available demos biodynamo demo < demo - name > < dir > sets up the demo < demo - name > in directory < dir > . If < dir > is not specified, it defaults to the current working directory.","title":"11.07.2018 82e7e15"},{"location":"changelog/#26062018-ba4fe1f","text":"Add support for multiple simulations per process. Only one simulation can be active at the same time. Introduces new class Simulation (see API ). This change causes many API changes -- see subsection below. Write simulation files to separate directory: output / simulation - id / Integrate simulation template for biodynamo new into the biodynamo repository to avoid inconsistencies with the biodynamo version. Old New InitializeBioDynaMo (...) Simulation simulation (...) Rm () TRm :: Get () TResourceManager :: Get () auto * rm = simulation . GetResourceManager (); GetDiffusionGrid (...) rm -> GetDiffusionGrid (...) Grid :: GetInstance () auto * grid = simulation . GetGrid (); Param :: some_parameter_ ; auto * param = simulation . GetParam (); param -> some_parameter_ ;","title":"26.06.2018 ba4fe1f"},{"location":"contact/","text":"Contact Please contact us at: biodynamo-talk@cern.ch","title":"Contact"},{"location":"contact/#contact","text":"Please contact us at: biodynamo-talk@cern.ch","title":"Contact"},{"location":"diffusion/","text":"One of BioDynaMo's built-in biological processes is extracellular diffusion. It is the process of extracellular substances diffusing through space. The constants that govern the diffusion process can be set by the user. Let's go through an example where diffusion plays a role. Copy the demo code diffusion is one of many installed demos in BioDynaMo. It can be copied out with biodynamo demo . biodynamo demo diffusion . Inspect the code Go into the diffusion directory and open the source file src / diffusion_biology_modules . h in your favorite editor. We can note the following things from its content: 1. Substance list enum Substances { kKalium }; The extracellular substances that will be used in the simulation are listed in an enum data structure. In this case it is just a single substance. According to our C++ coding style we will prepend the substance's name with the letter \"k\". 2. Biology modules In the same file you can find the definition of the biology modules Chemotaxis and KaliumSecretion . These are the modules that will govern the behavior of the simulation objects (i.e. cells). 3. Initial model Open the src / diffusion . h source file. First, create a BioDynaMo simulation: Simulation simulation ( argc , argv ); Next up is creating the initial model of our simulation. Therefore, we have to create an initial set of simulation objects and set their attributes: auto construct = []( const Double3 & position ) { Cell * cell = new Cell ( position ); cell -> SetDiameter ( 30 ); cell -> SetMass ( 1.0 ); cell -> AddBiologyModule ( new Chemotaxis ()); Double3 secretion_position = {{ 50 , 50 , 50 }}; if ( position == secretion_position ) { cell -> AddBiologyModule ( new KaliumSecretion ()); } return cell ; }; std :: vector < Double3 > positions ; positions . push_back ({ 0 , 0 , 0 }); positions . push_back ({ 100 , 0 , 0 }); positions . push_back ({ 0 , 100 , 0 }); positions . push_back ({ 0 , 0 , 100 }); positions . push_back ({ 0 , 100 , 100 }); positions . push_back ({ 100 , 0 , 100 }); positions . push_back ({ 100 , 100 , 0 }); positions . push_back ({ 100 , 100 , 100 }); // the cell responsible for secretion positions . push_back ({ 50 , 50 , 50 }); ModelInitializer :: CreateCells ( positions , construct ); The construct lambda defines the properties of each cell that we create. These can be physical properties (diameter, mass), but also biological properties and behaviors (chemotaxis, substance secretion) In this example, each cell is assigned the Chemotaxis behavior. In diffusion_biology_behaviors . h you can check the source code of this module. Basically it makes cells move according to the gradient, caused by a concentration difference of the substance. One of the cells (the cell at position { 50 , 50 , 50 } ) will be the one secreting the substance; it therefore gets assigned the SubstanceSecretion behavior. Furthermore, we define the initial positions of the cells. In this example it is done explicitly, but one could also generate a grid of cells, or a random distribution of cells. Simulation Parameters Create a bdm . toml file in the diffusion directory, and copy the following lines into it: [visualization] export = true export_interval = 10 [[visualize_sim_object]] name = \"Cell\" additional_data_members = [ \"diameter_\" ] [[visualize_diffusion]] name = \"Kalium\" gradient = true This will enable exporting visualization files, so that we can visualize the simulation after it has finished. Furthermore, we enable the output of the diameter of our simulation objects (by default named \"Cell\"), and the gradient data of the extracellular diffusion Build and run the simulation Run the following commands to build and run the simulation. biodynamo run Visualize the simulation Load the generated ParaView state file as described in Section Visualization . From \"View\", select \"Animation Panel\". This will display some animation settings at the bottom of the screen. From the \"Mode\" select \"Real Time\". Then click the Play button at the top of the screen to run the simulation visualization. Your browser does not support the video tag. Diffusion parameter constraints The differential equations that describe the diffusion are solved in an analytical way using the central difference method as shown in the figure below: The diffusion coefficient dictates the speed of diffusing a substance through space, while with the decay constant one controls the speed at which a substance decays. Mathematically, the method would allow for unphysical behavior to occur, such as negative concentration values. In order to avoid such behavior from happening, we impose the following constraint on the parameters: Since as a user, you are giving the resolution of the diffusion grid and not the distance between the grid points, you can determine this value by dividing the longest dimension of your space by the resolution, or by calling the corresponding function DiffusionGrid :: GetBoxLength () . For more information on the inner workings of the diffusion module, please refer to: https://repository.tudelft.nl/islandora/object/uuid%3A2fa2203b-ca26-4aa2-9861-1a4352391e09?collection=education","title":"Diffusion"},{"location":"diffusion/#copy-the-demo-code","text":"diffusion is one of many installed demos in BioDynaMo. It can be copied out with biodynamo demo . biodynamo demo diffusion .","title":"Copy the demo code"},{"location":"diffusion/#inspect-the-code","text":"Go into the diffusion directory and open the source file src / diffusion_biology_modules . h in your favorite editor. We can note the following things from its content:","title":"Inspect the code"},{"location":"diffusion/#1-substance-list","text":"enum Substances { kKalium }; The extracellular substances that will be used in the simulation are listed in an enum data structure. In this case it is just a single substance. According to our C++ coding style we will prepend the substance's name with the letter \"k\".","title":"1. Substance list"},{"location":"diffusion/#2-biology-modules","text":"In the same file you can find the definition of the biology modules Chemotaxis and KaliumSecretion . These are the modules that will govern the behavior of the simulation objects (i.e. cells).","title":"2. Biology modules"},{"location":"diffusion/#3-initial-model","text":"Open the src / diffusion . h source file. First, create a BioDynaMo simulation: Simulation simulation ( argc , argv ); Next up is creating the initial model of our simulation. Therefore, we have to create an initial set of simulation objects and set their attributes: auto construct = []( const Double3 & position ) { Cell * cell = new Cell ( position ); cell -> SetDiameter ( 30 ); cell -> SetMass ( 1.0 ); cell -> AddBiologyModule ( new Chemotaxis ()); Double3 secretion_position = {{ 50 , 50 , 50 }}; if ( position == secretion_position ) { cell -> AddBiologyModule ( new KaliumSecretion ()); } return cell ; }; std :: vector < Double3 > positions ; positions . push_back ({ 0 , 0 , 0 }); positions . push_back ({ 100 , 0 , 0 }); positions . push_back ({ 0 , 100 , 0 }); positions . push_back ({ 0 , 0 , 100 }); positions . push_back ({ 0 , 100 , 100 }); positions . push_back ({ 100 , 0 , 100 }); positions . push_back ({ 100 , 100 , 0 }); positions . push_back ({ 100 , 100 , 100 }); // the cell responsible for secretion positions . push_back ({ 50 , 50 , 50 }); ModelInitializer :: CreateCells ( positions , construct ); The construct lambda defines the properties of each cell that we create. These can be physical properties (diameter, mass), but also biological properties and behaviors (chemotaxis, substance secretion) In this example, each cell is assigned the Chemotaxis behavior. In diffusion_biology_behaviors . h you can check the source code of this module. Basically it makes cells move according to the gradient, caused by a concentration difference of the substance. One of the cells (the cell at position { 50 , 50 , 50 } ) will be the one secreting the substance; it therefore gets assigned the SubstanceSecretion behavior. Furthermore, we define the initial positions of the cells. In this example it is done explicitly, but one could also generate a grid of cells, or a random distribution of cells.","title":"3. Initial model"},{"location":"diffusion/#simulation-parameters","text":"Create a bdm . toml file in the diffusion directory, and copy the following lines into it: [visualization] export = true export_interval = 10 [[visualize_sim_object]] name = \"Cell\" additional_data_members = [ \"diameter_\" ] [[visualize_diffusion]] name = \"Kalium\" gradient = true This will enable exporting visualization files, so that we can visualize the simulation after it has finished. Furthermore, we enable the output of the diameter of our simulation objects (by default named \"Cell\"), and the gradient data of the extracellular diffusion","title":"Simulation Parameters"},{"location":"diffusion/#build-and-run-the-simulation","text":"Run the following commands to build and run the simulation. biodynamo run","title":"Build and run the simulation"},{"location":"diffusion/#visualize-the-simulation","text":"Load the generated ParaView state file as described in Section Visualization . From \"View\", select \"Animation Panel\". This will display some animation settings at the bottom of the screen. From the \"Mode\" select \"Real Time\". Then click the Play button at the top of the screen to run the simulation visualization. Your browser does not support the video tag.","title":"Visualize the simulation"},{"location":"diffusion/#diffusion-parameter-constraints","text":"The differential equations that describe the diffusion are solved in an analytical way using the central difference method as shown in the figure below: The diffusion coefficient dictates the speed of diffusing a substance through space, while with the decay constant one controls the speed at which a substance decays. Mathematically, the method would allow for unphysical behavior to occur, such as negative concentration values. In order to avoid such behavior from happening, we impose the following constraint on the parameters: Since as a user, you are giving the resolution of the diffusion grid and not the distance between the grid points, you can determine this value by dividing the longest dimension of your space by the resolution, or by calling the corresponding function DiffusionGrid :: GetBoxLength () . For more information on the inner workings of the diffusion module, please refer to: https://repository.tudelft.nl/islandora/object/uuid%3A2fa2203b-ca26-4aa2-9861-1a4352391e09?collection=education","title":"Diffusion parameter constraints"},{"location":"documentation/","text":"Documentation Warning We are currently under construction!","title":"Documentation"},{"location":"documentation/#documentation","text":"Warning We are currently under construction!","title":"Documentation"},{"location":"event/","text":"Event If a new simulation object (e.g. Cell) is created during a simulation we denote it as an Event. An example is cell division: A mother cell splits into two daughter cells. By our definition the already existing mother cell is modified to become the first daughter cell. The second daughter cell must be created. Further examples are: Neurite elongation Neurite branching Neurite bifurcation ... Stages An event has two stages: Create new simulation object(s) Modify the simulation object which triggered the event (optional). Cell Division Example Let\u2018s take the cell division event as an example and walk through these steps. Event trigger A call to cell . Divide () triggers the event. Step 1: Create daughter 2 A new cell will be created using the following constructor Cell ( const CellDivisionEvent & event , TMother * mother ) . The class CellDivisionEvent contains the parameters to perform a cell division. The second parameter is a pointer to the event trigger cell (aka mother) and can be used to access its data members. (e.g. volume_ = mother -> GetVolume () * event . volume_ratio_ ) Step 2: Modify event trigger Currently the event trigger cell is still in the state before the division (= mother). Now, we have to modify it to transform it into daughter 1. For instance the original volume must be adjusted such that ( volume_mother = volume_daughter_1 + volume_daughter_2 ). This is performed in the EventHandler function. For cell division it has the following signature: EventHandler ( const CellDivisionEvent & event , TDaughter * daughter ) Extending Simulation Objects This architecture is important to support extension of simulation objects. Let's assume that you extend the Cell class to add a new data member my_new_data_member_ . class MyCell : public Cell { ... double my_new_data_member_ = { 3.14 }; ... } Now you have to tell BioDynaMo what the value of new_data_member_ should be for daughter 1 and daughter 2 in case your cell divides. You can do that by defining a constructor and event handler. Let's assume that new_data_member_ of the mother cell is divided between the daughters according to the volume ratio defined in CellDivisionEvent . class MyCell : public Cell { public : MyCell ( const Event & event , SimObject * other , uint64_t new_oid = 0 ) : Base ( event , other , new_oid ) { new_data_member_ = mother -> new_data_member_ * event . volume_ratio ; } void EventHandler (( const Event & event , SimObject * other_1 , SimObject * other_2 = nullptr ) override { if ( auto * daughter_2 = dynamic_cast < MyCell *> ( other_2 )) { new_data_member_ -= daughter_2 -> new_data_member_ ; } Base :: EventHandler ( event , daughter_2 ); } ... private : double my_new_data_member_ = { 3.14 }; ... }; The constructor initializes new_data_member_ for daughter 2. The event handler performs the transition from mother to daughter 1. Caution Do not forget to forward the call to the constructor and event handler of the base class. Additional Notes It is possible to create a default constructor and event handler that is called for every event. This is useful for example if you extend a simulation object, but do not add additional data members. Events can create more than one simulation object. e.g. NeuriteBranchingEvent The type of the simulation object that triggers the event and newly created objects can be different. e.g. NewNeuriteExtensionEvent","title":"Event"},{"location":"event/#event","text":"If a new simulation object (e.g. Cell) is created during a simulation we denote it as an Event. An example is cell division: A mother cell splits into two daughter cells. By our definition the already existing mother cell is modified to become the first daughter cell. The second daughter cell must be created. Further examples are: Neurite elongation Neurite branching Neurite bifurcation ...","title":"Event"},{"location":"event/#stages","text":"An event has two stages: Create new simulation object(s) Modify the simulation object which triggered the event (optional).","title":"Stages"},{"location":"event/#cell-division-example","text":"Let\u2018s take the cell division event as an example and walk through these steps.","title":"Cell Division Example"},{"location":"event/#event-trigger","text":"A call to cell . Divide () triggers the event.","title":"Event trigger"},{"location":"event/#step-1-create-daughter-2","text":"A new cell will be created using the following constructor Cell ( const CellDivisionEvent & event , TMother * mother ) . The class CellDivisionEvent contains the parameters to perform a cell division. The second parameter is a pointer to the event trigger cell (aka mother) and can be used to access its data members. (e.g. volume_ = mother -> GetVolume () * event . volume_ratio_ )","title":"Step 1: Create daughter 2"},{"location":"event/#step-2-modify-event-trigger","text":"Currently the event trigger cell is still in the state before the division (= mother). Now, we have to modify it to transform it into daughter 1. For instance the original volume must be adjusted such that ( volume_mother = volume_daughter_1 + volume_daughter_2 ). This is performed in the EventHandler function. For cell division it has the following signature: EventHandler ( const CellDivisionEvent & event , TDaughter * daughter )","title":"Step 2: Modify event trigger"},{"location":"event/#extending-simulation-objects","text":"This architecture is important to support extension of simulation objects. Let's assume that you extend the Cell class to add a new data member my_new_data_member_ . class MyCell : public Cell { ... double my_new_data_member_ = { 3.14 }; ... } Now you have to tell BioDynaMo what the value of new_data_member_ should be for daughter 1 and daughter 2 in case your cell divides. You can do that by defining a constructor and event handler. Let's assume that new_data_member_ of the mother cell is divided between the daughters according to the volume ratio defined in CellDivisionEvent . class MyCell : public Cell { public : MyCell ( const Event & event , SimObject * other , uint64_t new_oid = 0 ) : Base ( event , other , new_oid ) { new_data_member_ = mother -> new_data_member_ * event . volume_ratio ; } void EventHandler (( const Event & event , SimObject * other_1 , SimObject * other_2 = nullptr ) override { if ( auto * daughter_2 = dynamic_cast < MyCell *> ( other_2 )) { new_data_member_ -= daughter_2 -> new_data_member_ ; } Base :: EventHandler ( event , daughter_2 ); } ... private : double my_new_data_member_ = { 3.14 }; ... }; The constructor initializes new_data_member_ for daughter 2. The event handler performs the transition from mother to daughter 1. Caution Do not forget to forward the call to the constructor and event handler of the base class.","title":"Extending Simulation Objects"},{"location":"event/#additional-notes","text":"It is possible to create a default constructor and event handler that is called for every event. This is useful for example if you extend a simulation object, but do not add additional data members. Events can create more than one simulation object. e.g. NeuriteBranchingEvent The type of the simulation object that triggers the event and newly created objects can be different. e.g. NewNeuriteExtensionEvent","title":"Additional Notes"},{"location":"first_steps/","text":"First Steps Setting up a simulation and running it is done with the BioDynaMo command line interface (CLI). Open a new terminal and execute: source <path-to-bdm-installation>/biodynamo-env.sh This command must be executed whenever you want to use BioDynaMo in a new terminal! Basic Workflow A basic BioDynaMo workflow looks as follows: 1. Create a new project To create a new project run the following command: biodynamo new <enter_name> This command creates a new Git repository for you with the name specified in the < enter_name > placeholder. You will see a folder appear with the same name, containing some template files to get you started. Tip If you wish to have your Github account linked to your project you can append the --github option to the command. biodynamo assist command requires --github 2. Implement your model The provided template files in your newly created folder can be used as a starting point for your simulation. The src directory contains the files with the source code that defines the simulation. You can edit and add the code that describes your model in this folder. 3. Run the simulation Building the simulation and running it can be done with the command: biodynamo run All your source code will be compiled and linked against the BioDynaMo libraries, and an executable file will be created and run. It is at this point you might encounter compilation errors. You will need to fix them before the simulation can actually run. Try out some demos There are some demos in the installation. They can be listed with the command: biodynamo demo Each of these demos can be copied out to a directory and executed with two biodynamo commands: biodynamo demo <name> [ target ] cd <destination> # as printed out by the previous command biodynamo run For example, to run the demo cell_division , we can do: biodynamo demo cell_division /tmp cd /tmp/cell_division biodynamo run Request assistance It can happen that you encounter an error or issue that you cannot solve on your own. Or you might be convinced that there is a bug in BioDynaMo. For such occasions we have provided you with BioDynaMo assistance: biodynamo assist This command will create a folder called debug in which debug information will be collected. A git branch will be created and uploaded to Github. Send the link to this branch to us, so we can take a look at the issue. Check out Contact on how to contact us.","title":"First Steps"},{"location":"first_steps/#first-steps","text":"Setting up a simulation and running it is done with the BioDynaMo command line interface (CLI). Open a new terminal and execute: source <path-to-bdm-installation>/biodynamo-env.sh This command must be executed whenever you want to use BioDynaMo in a new terminal!","title":"First Steps"},{"location":"first_steps/#basic-workflow","text":"A basic BioDynaMo workflow looks as follows:","title":"Basic Workflow"},{"location":"first_steps/#1-create-a-new-project","text":"To create a new project run the following command: biodynamo new <enter_name> This command creates a new Git repository for you with the name specified in the < enter_name > placeholder. You will see a folder appear with the same name, containing some template files to get you started. Tip If you wish to have your Github account linked to your project you can append the --github option to the command. biodynamo assist command requires --github","title":"1. Create a new project"},{"location":"first_steps/#2-implement-your-model","text":"The provided template files in your newly created folder can be used as a starting point for your simulation. The src directory contains the files with the source code that defines the simulation. You can edit and add the code that describes your model in this folder.","title":"2. Implement your model"},{"location":"first_steps/#3-run-the-simulation","text":"Building the simulation and running it can be done with the command: biodynamo run All your source code will be compiled and linked against the BioDynaMo libraries, and an executable file will be created and run. It is at this point you might encounter compilation errors. You will need to fix them before the simulation can actually run.","title":"3. Run the simulation"},{"location":"first_steps/#try-out-some-demos","text":"There are some demos in the installation. They can be listed with the command: biodynamo demo Each of these demos can be copied out to a directory and executed with two biodynamo commands: biodynamo demo <name> [ target ] cd <destination> # as printed out by the previous command biodynamo run For example, to run the demo cell_division , we can do: biodynamo demo cell_division /tmp cd /tmp/cell_division biodynamo run","title":"Try out some demos"},{"location":"first_steps/#request-assistance","text":"It can happen that you encounter an error or issue that you cannot solve on your own. Or you might be convinced that there is a bug in BioDynaMo. For such occasions we have provided you with BioDynaMo assistance: biodynamo assist This command will create a folder called debug in which debug information will be collected. A git branch will be created and uploaded to Github. Send the link to this branch to us, so we can take a look at the issue. Check out Contact on how to contact us.","title":"Request assistance"},{"location":"gpu_acceleration/","text":"GPU-acceleration: what and why? Physical interactions are one of the most compute intensive operations in biological simulations. The main reason is that the computations that are involved often include operators that require multiple CPU cycles to perform the corresponding operation. In an accurate model, physical interactions happen between all simulation objects and their local environment, for every time step. Therefore, you can imagine that a lot of performance can be gained by accelerating these interactions. General purpose GPUs (GPGPUs) make it possible to obtain the computing performance of a small cluster computer. Almost any desktop computer, or laptop has a built-in GPU available. It mostly takes care of all the graphical computations that take place on a computer, but recent developments allow us to use GPUs for high-performance computing purposes. Frameworks such as CUDA and OpenCL make it possible to program a GPU to perform the computations that we specify at a speed much higher than on a regular CPU. Of course, this depends on the type of computation that you want to perform, but fortunately physical interactions in BioDynaMo fits the bill. Requirements We try to keep things as simple as possible in terms of usage. So for the most part you are good to go as long as you meet either the following requirements: You have a CUDA-compatible GPU and CUDA installed You have an OpenCL-compatible GPU and OpenCL installed If you have multiple GPUs on your machine, BioDynaMo will automatically select one. You can also configure this yourself if you prefer one GPU over the other(s). More on this below. Enabling GPU acceleration The only thing you need to do to enjoy GPU acceleration is enabling it through the configuration file (bdm.toml) as following: [ experimental ] use_gpu = true By default we assume that your GPU is only CUDA-compatible. If you want to let BioDynaMo know you have an OpenCL-compatible GPU just append the following to the above snippet: use_opencl = true Note If you have multiple GPUs on your system you can select which BioDynaMo uses by setting the following flag: preferred_gpu = < value > , where < value > is the index of the GPU in the list of all GPUs.","title":"GPU Acceleration"},{"location":"gpu_acceleration/#gpu-acceleration-what-and-why","text":"Physical interactions are one of the most compute intensive operations in biological simulations. The main reason is that the computations that are involved often include operators that require multiple CPU cycles to perform the corresponding operation. In an accurate model, physical interactions happen between all simulation objects and their local environment, for every time step. Therefore, you can imagine that a lot of performance can be gained by accelerating these interactions. General purpose GPUs (GPGPUs) make it possible to obtain the computing performance of a small cluster computer. Almost any desktop computer, or laptop has a built-in GPU available. It mostly takes care of all the graphical computations that take place on a computer, but recent developments allow us to use GPUs for high-performance computing purposes. Frameworks such as CUDA and OpenCL make it possible to program a GPU to perform the computations that we specify at a speed much higher than on a regular CPU. Of course, this depends on the type of computation that you want to perform, but fortunately physical interactions in BioDynaMo fits the bill.","title":"GPU-acceleration: what and why?"},{"location":"gpu_acceleration/#requirements","text":"We try to keep things as simple as possible in terms of usage. So for the most part you are good to go as long as you meet either the following requirements: You have a CUDA-compatible GPU and CUDA installed You have an OpenCL-compatible GPU and OpenCL installed If you have multiple GPUs on your machine, BioDynaMo will automatically select one. You can also configure this yourself if you prefer one GPU over the other(s). More on this below.","title":"Requirements"},{"location":"gpu_acceleration/#enabling-gpu-acceleration","text":"The only thing you need to do to enjoy GPU acceleration is enabling it through the configuration file (bdm.toml) as following: [ experimental ] use_gpu = true By default we assume that your GPU is only CUDA-compatible. If you want to let BioDynaMo know you have an OpenCL-compatible GPU just append the following to the above snippet: use_opencl = true Note If you have multiple GPUs on your system you can select which BioDynaMo uses by setting the following flag: preferred_gpu = < value > , where < value > is the index of the GPU in the list of all GPUs.","title":"Enabling GPU acceleration"},{"location":"hello_world/","text":"The most basic BioDynaMo simulation (i.e. our Hello World program) is a static single cell. It is the default model that comes with the installation of BioDynaMo. In this section we shall go over the three simple steps of running this simple simulation. Step 1: Create your simulation Run the following command to create a new project called \"hello_world\": biodynamo new hello_world Step 2: Build your simulation Go into the newly created directory hello_world with: cd hello_world And build the project files with: biodynamo build Step 3: Run your simulation biodynamo run You should see \"Simulation completed succesfully\" as the output. Extra: Cell division Let's make the simulation more interesting by adding a biological behavior to the cell: cell division. Open the src / hello_world . h and add the following line to the simulate function after the cell is created. // Add the biological behavior to the cell. cell . AddBiologyModule ( new GrowDivide ( 32 , 3000 , { gAllEventIds })); Rebuild and rerun the simulation to have the cell division take effect. visit the next exercise to learn about the visualization features of BioDynaMo. Info You might want to run for a few more simulation steps to witness cells dividing","title":"Hello World"},{"location":"hello_world/#step-1-create-your-simulation","text":"Run the following command to create a new project called \"hello_world\": biodynamo new hello_world","title":"Step 1: Create your simulation"},{"location":"hello_world/#step-2-build-your-simulation","text":"Go into the newly created directory hello_world with: cd hello_world And build the project files with: biodynamo build","title":"Step 2: Build your simulation"},{"location":"hello_world/#step-3-run-your-simulation","text":"biodynamo run You should see \"Simulation completed succesfully\" as the output.","title":"Step 3: Run your simulation"},{"location":"hello_world/#extra-cell-division","text":"Let's make the simulation more interesting by adding a biological behavior to the cell: cell division. Open the src / hello_world . h and add the following line to the simulate function after the cell is created. // Add the biological behavior to the cell. cell . AddBiologyModule ( new GrowDivide ( 32 , 3000 , { gAllEventIds })); Rebuild and rerun the simulation to have the cell division take effect. visit the next exercise to learn about the visualization features of BioDynaMo. Info You might want to run for a few more simulation steps to witness cells dividing","title":"Extra: Cell division"},{"location":"installation/","text":"Installation To install BioDynaMo for the first time execute the following commands. The installation will also install all required packages including ParaView, ROOT and Qt5. git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo ./install.sh Important After the installation you need to restart your terminal. In every new terminal execute source < path - to - bdm - installation >/ bin / thisbdm . sh to use BioDynaMo! It is also possible to use the library without running make install . You will just need to source thisbdm . sh from the build directory: source < path - to - bdm - build - dir >/ install / bin / thisbdm . sh BioDynaMo uses a customized version of ParaView. Therefore, you should not install ParaView separately. Update Installation The following commands update your BioDynaMo installation: cd path/to/biodynamo # make sure you are on the master branch git checkout master # get latest changes git pull origin master ./install.sh Supported platforms Ubuntu 16.04 (recommended) , 18.04 CentOS 7.6.1810 Mac OSX","title":"Installation"},{"location":"installation/#installation","text":"To install BioDynaMo for the first time execute the following commands. The installation will also install all required packages including ParaView, ROOT and Qt5. git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo ./install.sh Important After the installation you need to restart your terminal. In every new terminal execute source < path - to - bdm - installation >/ bin / thisbdm . sh to use BioDynaMo! It is also possible to use the library without running make install . You will just need to source thisbdm . sh from the build directory: source < path - to - bdm - build - dir >/ install / bin / thisbdm . sh BioDynaMo uses a customized version of ParaView. Therefore, you should not install ParaView separately.","title":"Installation"},{"location":"installation/#update-installation","text":"The following commands update your BioDynaMo installation: cd path/to/biodynamo # make sure you are on the master branch git checkout master # get latest changes git pull origin master ./install.sh","title":"Update Installation"},{"location":"installation/#supported-platforms","text":"Ubuntu 16.04 (recommended) , 18.04 CentOS 7.6.1810 Mac OSX","title":"Supported platforms"},{"location":"math_array/","text":"MathArray Description MathArray < T , N > is an array-like structure which provides a similar interface to the standard std :: array < T , N > class, but it overloads many standard mathematical operations (e.g. + , - , += , etc.). Moreover, it implements several custom operations (e.g. Norm () , Normalize () , etc.). Mathematical Operations It is possible to perform several mathematical operations with MathArray instances. For instance: MathArray < double , 4 > a { 1 , 2 , 3 , 4 }; MathArray < double , 3 > b { 1 , 1 , 1 , 1 }; // sum == {2,3,4,5}; auto sum = a + b ; // sub == {0,1,2,3}; auto sub = a - b ; // Performs the dot product between the two MathArray // elements and it returns a single value. dot == 10 auto dot = a * b ; // div = {1,2,3,4}; auto div = a / b ; Increment and decrement operations are also defined (plus other in-place operations): MathArray < double , 4 > a { 1 , 2 , 3 , 4 }; MathArray < double , 3 > b { 1 , 1 , 1 , 1 }; a ++ ; a -- ; a += b ; a -= b ; a /= b ; Complex Operations MathArray objects offer also a series of custom operations which make them easier to use and to manipulate. MathArray < double , 4 > a { 1 , 2 , 3 , 4 }; MathArray < double , 3 > b { 2 , 2 , 2 , 2 }; // Entry wise product between a and b. The result will be a new array // with as content {2, 4, 6, 8}. auto entry_prod = a . EntryWiseProduct ( b ) // It returns the sum of the array's content, which is 10. auto array_sum = a . Sum () // It computes and returns the array's norm. auto norm = a . Norm () // Normalize the array in-place. a . Normalize () Two alias are also available, Double3 and Double4 , which correspond to the following instantiations: MathArray < double , 3 > and MathArray < double , 4 > .","title":"MathArray"},{"location":"math_array/#matharray","text":"","title":"MathArray"},{"location":"math_array/#description","text":"MathArray < T , N > is an array-like structure which provides a similar interface to the standard std :: array < T , N > class, but it overloads many standard mathematical operations (e.g. + , - , += , etc.). Moreover, it implements several custom operations (e.g. Norm () , Normalize () , etc.).","title":"Description"},{"location":"math_array/#mathematical-operations","text":"It is possible to perform several mathematical operations with MathArray instances. For instance: MathArray < double , 4 > a { 1 , 2 , 3 , 4 }; MathArray < double , 3 > b { 1 , 1 , 1 , 1 }; // sum == {2,3,4,5}; auto sum = a + b ; // sub == {0,1,2,3}; auto sub = a - b ; // Performs the dot product between the two MathArray // elements and it returns a single value. dot == 10 auto dot = a * b ; // div = {1,2,3,4}; auto div = a / b ; Increment and decrement operations are also defined (plus other in-place operations): MathArray < double , 4 > a { 1 , 2 , 3 , 4 }; MathArray < double , 3 > b { 1 , 1 , 1 , 1 }; a ++ ; a -- ; a += b ; a -= b ; a /= b ;","title":"Mathematical Operations"},{"location":"math_array/#complex-operations","text":"MathArray objects offer also a series of custom operations which make them easier to use and to manipulate. MathArray < double , 4 > a { 1 , 2 , 3 , 4 }; MathArray < double , 3 > b { 2 , 2 , 2 , 2 }; // Entry wise product between a and b. The result will be a new array // with as content {2, 4, 6, 8}. auto entry_prod = a . EntryWiseProduct ( b ) // It returns the sum of the array's content, which is 10. auto array_sum = a . Sum () // It computes and returns the array's norm. auto norm = a . Norm () // Normalize the array in-place. a . Normalize () Two alias are also available, Double3 and Double4 , which correspond to the following instantiations: MathArray < double , 3 > and MathArray < double , 4 > .","title":"Complex Operations"},{"location":"opengl_issues/","text":"OpenGL issues Turn on debugging output and run simulation again export LIBGL_DEBUG = verbose . / simulation Check OpenGL information: glxinfo | grep - i OpenGL Driver information: lspci | grep - i \"vga compatible\" Faulty OpenGL version detection with software renderer https://python.develop-bugs.com/article/10118323/paraview+needs+higher+OpenGL+in+Mesa When using llvmpipe/gallium with mesa, a software renderer, the OpenGL capabilities can be incorrectly detected. The simplest way to fix that is to force it : MESA_GL_VERSION_OVERRIDE = 3 . 3 . / bin / paraview Simulation output: ... libGL error : failed to open drm device : No such file or directory libGL error : failed to load driver : i965 libGL : OpenDriver : trying / usr / lib64 / dri / tls / swrast_dri . so libGL : OpenDriver : trying / usr / lib64 / dri / swrast_dri . so libGL : Can ' t open configuration file /home/testuser/.drirc: No such file or directory. libGL : Can ' t open configuration file /home/testuser/.drirc: No such file or directory. libGL error : failed to open drm device : No such file or directory libGL error : failed to load driver : i965 libGL : OpenDriver : trying / usr / lib64 / dri / tls / swrast_dri . so libGL : OpenDriver : trying / usr / lib64 / dri / swrast_dri . so libGL : Can ' t open configuration file /home/testuser/.drirc: No such file or directory. libGL : Can ' t open configuration file /home/testuser/.drirc: No such file or directory. ERROR : In / home / testuser / bdm - build - third - party / paraview / VTK / Rendering / OpenGL2 / vtkOpenGLRenderWindow . cxx , line 793 vtkXOpenGLRenderWindow ( 0 x4ba2790 ) : GL version 2 . 1 with the gpu_shader4 extension is not supported by your graphics driver but is required for the new OpenGL rendering backend . Please update your OpenGL driver . If you are using Mesa please make sure you have version 10 . 6 . 5 or later and make sure your driver in Mesa supports OpenGL 3 . 2 . ERROR : In / home / testuser / bdm - build - third - party / paraview / VTK / Rendering / OpenGL2 / vtkShaderProgram . cxx , line 445 vtkShaderProgram ( 0 x4b93030 ) : 1 : # version 120 ... glxinfo glxinfo | grep - i OpenGL OpenGL vendor string : VMware , Inc . OpenGL renderer string : llvmpipe ( LLVM 6 . 0 , 256 bits ) OpenGL version string : 2 . 1 Mesa 18 . 0 . 5 OpenGL shading language version string : 1 . 30 OpenGL extensions : OpenGL ES profile version string : OpenGL ES 2 . 0 Mesa 18 . 0 . 5 OpenGL ES profile shading language version string : OpenGL ES GLSL ES 1 . 0 . 16 OpenGL ES profile extensions : Mount host graphics card to container https://stackoverflow.com/questions/42438619/run-chromium-inside-container-libgl-error # for intel cards docker run -- device =/ dev / dri : / dev / dri ...","title":"OpenGL"},{"location":"opengl_issues/#opengl-issues","text":"Turn on debugging output and run simulation again export LIBGL_DEBUG = verbose . / simulation Check OpenGL information: glxinfo | grep - i OpenGL Driver information: lspci | grep - i \"vga compatible\"","title":"OpenGL issues"},{"location":"opengl_issues/#faulty-opengl-version-detection-with-software-renderer","text":"https://python.develop-bugs.com/article/10118323/paraview+needs+higher+OpenGL+in+Mesa When using llvmpipe/gallium with mesa, a software renderer, the OpenGL capabilities can be incorrectly detected. The simplest way to fix that is to force it : MESA_GL_VERSION_OVERRIDE = 3 . 3 . / bin / paraview Simulation output: ... libGL error : failed to open drm device : No such file or directory libGL error : failed to load driver : i965 libGL : OpenDriver : trying / usr / lib64 / dri / tls / swrast_dri . so libGL : OpenDriver : trying / usr / lib64 / dri / swrast_dri . so libGL : Can ' t open configuration file /home/testuser/.drirc: No such file or directory. libGL : Can ' t open configuration file /home/testuser/.drirc: No such file or directory. libGL error : failed to open drm device : No such file or directory libGL error : failed to load driver : i965 libGL : OpenDriver : trying / usr / lib64 / dri / tls / swrast_dri . so libGL : OpenDriver : trying / usr / lib64 / dri / swrast_dri . so libGL : Can ' t open configuration file /home/testuser/.drirc: No such file or directory. libGL : Can ' t open configuration file /home/testuser/.drirc: No such file or directory. ERROR : In / home / testuser / bdm - build - third - party / paraview / VTK / Rendering / OpenGL2 / vtkOpenGLRenderWindow . cxx , line 793 vtkXOpenGLRenderWindow ( 0 x4ba2790 ) : GL version 2 . 1 with the gpu_shader4 extension is not supported by your graphics driver but is required for the new OpenGL rendering backend . Please update your OpenGL driver . If you are using Mesa please make sure you have version 10 . 6 . 5 or later and make sure your driver in Mesa supports OpenGL 3 . 2 . ERROR : In / home / testuser / bdm - build - third - party / paraview / VTK / Rendering / OpenGL2 / vtkShaderProgram . cxx , line 445 vtkShaderProgram ( 0 x4b93030 ) : 1 : # version 120 ... glxinfo glxinfo | grep - i OpenGL OpenGL vendor string : VMware , Inc . OpenGL renderer string : llvmpipe ( LLVM 6 . 0 , 256 bits ) OpenGL version string : 2 . 1 Mesa 18 . 0 . 5 OpenGL shading language version string : 1 . 30 OpenGL extensions : OpenGL ES profile version string : OpenGL ES 2 . 0 Mesa 18 . 0 . 5 OpenGL ES profile shading language version string : OpenGL ES GLSL ES 1 . 0 . 16 OpenGL ES profile extensions :","title":"Faulty OpenGL version detection with software renderer"},{"location":"opengl_issues/#mount-host-graphics-card-to-container","text":"https://stackoverflow.com/questions/42438619/run-chromium-inside-container-libgl-error # for intel cards docker run -- device =/ dev / dri : / dev / dri ...","title":"Mount host graphics card to container"},{"location":"operation/","text":"Operation Operations are functions that are executed for each simulation object. To execute a function for specific simulation objects have a look at biology modules. To support multiscale simulations, operations have a data member frequency. If it is set to one it means that this function will be executed for every time step. If this member is set to two it will be executed every second time step, and so on. Here the link for the complete API documentation for Operation Usage examples Add a user-defined operation Below you can find a code example to add an operation that prints all simulation object unique ids. auto * scheduler = simulation . GetScheduler (); Operation op ( \"print uid op\" , []( SimObject * so ){ std :: cout << \"SimObject \" << so -> GetUid () << std :: endl ; }); scheduler -> AddOperation ( op ); Change the execution frequency of an operation Let's assume that we want to output all unique ids every 100 timesteps instead of every. auto * scheduler = simulation . GetScheduler (); scheduler -> GetOperation ( \"print uid op\" ) -> frequency_ = 100 ;","title":"Operation"},{"location":"operation/#operation","text":"Operations are functions that are executed for each simulation object. To execute a function for specific simulation objects have a look at biology modules. To support multiscale simulations, operations have a data member frequency. If it is set to one it means that this function will be executed for every time step. If this member is set to two it will be executed every second time step, and so on. Here the link for the complete API documentation for Operation","title":"Operation"},{"location":"operation/#usage-examples","text":"","title":"Usage examples"},{"location":"operation/#add-a-user-defined-operation","text":"Below you can find a code example to add an operation that prints all simulation object unique ids. auto * scheduler = simulation . GetScheduler (); Operation op ( \"print uid op\" , []( SimObject * so ){ std :: cout << \"SimObject \" << so -> GetUid () << std :: endl ; }); scheduler -> AddOperation ( op );","title":"Add a user-defined operation"},{"location":"operation/#change-the-execution-frequency-of-an-operation","text":"Let's assume that we want to output all unique ids every 100 timesteps instead of every. auto * scheduler = simulation . GetScheduler (); scheduler -> GetOperation ( \"print uid op\" ) -> frequency_ = 100 ;","title":"Change the execution frequency of an operation"},{"location":"parameter/","text":"Parameter Parameters are used to tailor BioDynaMo to your specific simulation. The majority of parameters are defined in the core engine . Each module can define its own Param class to add additional parameters. There are three ways to set the value of a parameter: TOML configuration file Command line parameter Assignment in the source code. Note Higher index takes precedence. E.g. If you define the backup_file in the TOML file and the command line parameter, the command line version will be used. The documentation of each parameter contains a description of the parameter, its default value and how to set it in the TOML file ( example ) The following code snippet shows how to access a parameter in your simulation. const auto * param = Simulation :: GetActive () - > GetParam (); std :: cout << param- > simulation_time_step_ << std :: endl ; std :: cout << param- > GetModuleParam < neuroscience :: Param >() - > neurite_max_length_ << std :: endl ; Configuration File This is the recommended way to set runtime variables. Create a file bdm . toml in the working directory and add your configuration. You can find a sample below: [visualization] export = true export_interval = 1 [[visualize_sim_object]] name = \"Cell\" additional_data_members = [ \"density_\" ] Command Line Parameter Some parameter can be set as command line argument when you start the simulation. For a complete list execute the binary with the --help switch. e.g. . / cell_division --help . Sample output: Info : Initialize new simulation using BioDynaMo v0 . 1 . 0 - 105 - g74f6a24 - v , -- verbose Verbose mode . Causes BioDynaMo to print debugging messages . Multiple - v options increases the verbosity . The maximum is 3 . - r , -- restore filename Restores the simulation from the checkpoint found in filename and continues simulation from that point . - b , -- backup filename Periodically create full simulation backup to the specified file NOTA BENE : File will be overriden if it exists -- help Print usage and exit . Assignment in the Source Code You can also set a runtime parameter in the source code. You have to recompile your simulation though. auto set_param = [] ( Param * param ) { // Create an artificial bound for the simulation space param -> bound_space_ = true ; param -> min_bound_ = 0 ; param -> max_bound_ = 250 ; param -> run_mechanical_interactions_ = false ; } ; Simulation simulation ( argc , argv , set_param ) ; You have to create a lambda and pass it to the constructor of Simulation . Afterwards, Simulation only returns a const pointer to the parameters. Thus, they cannot be modified.","title":"Parameter"},{"location":"parameter/#parameter","text":"Parameters are used to tailor BioDynaMo to your specific simulation. The majority of parameters are defined in the core engine . Each module can define its own Param class to add additional parameters. There are three ways to set the value of a parameter: TOML configuration file Command line parameter Assignment in the source code. Note Higher index takes precedence. E.g. If you define the backup_file in the TOML file and the command line parameter, the command line version will be used. The documentation of each parameter contains a description of the parameter, its default value and how to set it in the TOML file ( example ) The following code snippet shows how to access a parameter in your simulation. const auto * param = Simulation :: GetActive () - > GetParam (); std :: cout << param- > simulation_time_step_ << std :: endl ; std :: cout << param- > GetModuleParam < neuroscience :: Param >() - > neurite_max_length_ << std :: endl ;","title":"Parameter"},{"location":"parameter/#configuration-file","text":"This is the recommended way to set runtime variables. Create a file bdm . toml in the working directory and add your configuration. You can find a sample below: [visualization] export = true export_interval = 1 [[visualize_sim_object]] name = \"Cell\" additional_data_members = [ \"density_\" ]","title":"Configuration File"},{"location":"parameter/#command-line-parameter","text":"Some parameter can be set as command line argument when you start the simulation. For a complete list execute the binary with the --help switch. e.g. . / cell_division --help . Sample output: Info : Initialize new simulation using BioDynaMo v0 . 1 . 0 - 105 - g74f6a24 - v , -- verbose Verbose mode . Causes BioDynaMo to print debugging messages . Multiple - v options increases the verbosity . The maximum is 3 . - r , -- restore filename Restores the simulation from the checkpoint found in filename and continues simulation from that point . - b , -- backup filename Periodically create full simulation backup to the specified file NOTA BENE : File will be overriden if it exists -- help Print usage and exit .","title":"Command Line Parameter"},{"location":"parameter/#assignment-in-the-source-code","text":"You can also set a runtime parameter in the source code. You have to recompile your simulation though. auto set_param = [] ( Param * param ) { // Create an artificial bound for the simulation space param -> bound_space_ = true ; param -> min_bound_ = 0 ; param -> max_bound_ = 250 ; param -> run_mechanical_interactions_ = false ; } ; Simulation simulation ( argc , argv , set_param ) ; You have to create a lambda and pass it to the constructor of Simulation . Afterwards, Simulation only returns a const pointer to the parameters. Thus, they cannot be modified.","title":"Assignment in the Source Code"},{"location":"prerequisites/","text":"Prerequisites This page lists the prerequisites packages that needs to be installed in order to build correctly BioDynaMo. BioDynaMo provides also an automated procedure to install all the needed library. Ubuntu 16.04, 18.04 Required Packages cmake : Set of tools for automate building, testing of software (for /usr/bin/cmake ); make : Build automation tool (for /usr/bin/make ); gcc : GNU C compiler (for /usr/bin/gcc ); g++ : GNU C++ compiler (for /usr/bin/g++ ); libopenmpi-dev : Development files for OpenMPI (Open Source Message Passing Interface); libomp-dev : Development files for OpenMP (API for multiprocessor programming); libnuma-dev : Development files for NUMA (simple programming interface to the policy supported by the Linux kernel); libtbb-dev : Development files for TBB (C++ template library developed by Intel for parallel programming); libpthread-stubs0-dev : Development files for managing threads; python3 : Python 3 Interpreter (for /usr/bin/python3 ); python3-pip : Python 3 Package Manager (for /usr/bin/pip3 ). Optional Packages freeglut3-dev : Development files for GLUT (OpenGL Utility Toolkit); valgrind : A suite of tools for debugging and profiling (for /usr/bin/valgrind ); clang-format-3.9 : clang-based C++ style checker and formatter (for /usr/bin/clang-format-3.9 ); clang-tidy-3.9 : clang-based C++ \u201clinter\u201d tool (for /usr/bin/clang-tidy-3.9 ); doxygen : Tool for generating documentation from annotated C++ sources (for /usr/bin/doxygen ); graphviz : Graph Visualization Software used optionally by Doxygen; lcov : Graphical front-end for GCC's coverage testing tool gcov; gcovr : Tool to test code coverage in programs. Installation Required Packages sudo apt-get install -y cmake make gcc g++ \\ libopenmpi-dev libomp-dev libnuma-dev libtbb-dev \\ libpthread-stubs0-dev python3 python3-pip Optional Packages pip3 install --user mkdocs mkdocs-material sudo apt-get install -y freeglut3-dev valgrind \\ clang-3.9 clang-format-3.9 clang-tidy-3.9 \\ doxygen graphviz lcov gcovr CentOS 7.6.1810 Required Packages epel-release : It provides a set of additional packages for Enterprise Linux; ius-release : It provides RPM packages for newer software versions for for Enterprise Linux distributions; cmake3 : Set of tools for automate building, testing of software; libXt-devel : Basic library for developing X11; libXext-devel : Library which contains a handful of X11 extensions devtoolset-7-gcc : Compiler suite for C and C++; numactl-devel : Development files for NUMA (simple programming interface to the policy supported by the Linux kernel); tbb-devel : Development files for TBB (C++ template library developed by Intel for parallel programming); openmpi3-devel : Development files for OpenMP (API for multiprocessor programming); rh-python36 , python and python-pip : Python 3 Interpreter and Package Manager. Optional Packages freeglut-devel : Development files for GLUT (OpenGL Utility Toolkit); lcov : Graphical front-end for GCC's coverage testing tool gcov; gcov : Tool to test code coverage in programs; llvm-toolset-7 : software collection that provides software from the LLVM suite; llvm-toolset-7-clang-tools-extra : software collection that provides clang - format and clang - tidy ; valgrind : A suite of tools for debugging and profiling; doxygen : Tool for generating documentation from annotated C++ sources; graphviz : Graph Visualization Software used optionally by Doxygen. Installation Required Packages sudo yum update -y sudo yum -y install centos-release-scl epel-release sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm sudo yum -y install cmake3 libXt-devel libXext-devel \\ devtoolset-7-gcc* numactl-devel tbb-devel openmpi3-devel \\ rh-python36 python python-pip Optional Packages pip install --user mkdocs mkdocs-material sudo yum -y install lcov gcovr llvm-toolset-7 \\ llvm-toolset-7-clang-tools-extra doxygen graphviz valgrind freeglut-devel MacOS Attention Currently we support only installation of BioDynaMo using Homebrew and Fink. If you are using another package manager you will need to install all the corresponding packages. Required Packages llvm : LLVM compiler suite with also OpenMP compliant clang and clang++; cmake : Set of tools for automate building, testing of software; libomp : Development files for OpenMP (API for multiprocessor programming); tbb : Development files for TBB (C++ template library developed by Intel for parallel programming); open-mpi : Development files for OpenMP (API for multiprocessor programming); python and python@2 : Python 3 Interpreter. Optional Packages doxygen : Tool for generating documentation from annotated C++ sources; lcov : Graphical front-end for GCC's coverage testing tool gcov; gcovr : Tool to test code coverage in programs. Installation Required Packages Using HomeBrew: sudo brew install llvm cmake libomp tbb open-mpi \\ python python@2 brew upgrade python cmake Using Fink: sudo fink install llvm-clang cmake libomp-dev libtbb4 openmpi \\ python3 pip-py37 Optional Packages Using HomeBrew: pip install --user mkdocs mkdocs-material sudo brew install doxygen lcov gcovr Using Fink: pip install --user mkdocs mkdocs-material sudo fink install doxygen","title":"Prerequisites"},{"location":"prerequisites/#prerequisites","text":"This page lists the prerequisites packages that needs to be installed in order to build correctly BioDynaMo. BioDynaMo provides also an automated procedure to install all the needed library.","title":"Prerequisites"},{"location":"prerequisites/#ubuntu-1604-1804","text":"","title":"Ubuntu 16.04, 18.04"},{"location":"prerequisites/#required-packages","text":"cmake : Set of tools for automate building, testing of software (for /usr/bin/cmake ); make : Build automation tool (for /usr/bin/make ); gcc : GNU C compiler (for /usr/bin/gcc ); g++ : GNU C++ compiler (for /usr/bin/g++ ); libopenmpi-dev : Development files for OpenMPI (Open Source Message Passing Interface); libomp-dev : Development files for OpenMP (API for multiprocessor programming); libnuma-dev : Development files for NUMA (simple programming interface to the policy supported by the Linux kernel); libtbb-dev : Development files for TBB (C++ template library developed by Intel for parallel programming); libpthread-stubs0-dev : Development files for managing threads; python3 : Python 3 Interpreter (for /usr/bin/python3 ); python3-pip : Python 3 Package Manager (for /usr/bin/pip3 ).","title":"Required Packages"},{"location":"prerequisites/#optional-packages","text":"freeglut3-dev : Development files for GLUT (OpenGL Utility Toolkit); valgrind : A suite of tools for debugging and profiling (for /usr/bin/valgrind ); clang-format-3.9 : clang-based C++ style checker and formatter (for /usr/bin/clang-format-3.9 ); clang-tidy-3.9 : clang-based C++ \u201clinter\u201d tool (for /usr/bin/clang-tidy-3.9 ); doxygen : Tool for generating documentation from annotated C++ sources (for /usr/bin/doxygen ); graphviz : Graph Visualization Software used optionally by Doxygen; lcov : Graphical front-end for GCC's coverage testing tool gcov; gcovr : Tool to test code coverage in programs.","title":"Optional Packages"},{"location":"prerequisites/#installation","text":"","title":"Installation"},{"location":"prerequisites/#required-packages_1","text":"sudo apt-get install -y cmake make gcc g++ \\ libopenmpi-dev libomp-dev libnuma-dev libtbb-dev \\ libpthread-stubs0-dev python3 python3-pip","title":"Required Packages"},{"location":"prerequisites/#optional-packages_1","text":"pip3 install --user mkdocs mkdocs-material sudo apt-get install -y freeglut3-dev valgrind \\ clang-3.9 clang-format-3.9 clang-tidy-3.9 \\ doxygen graphviz lcov gcovr","title":"Optional Packages"},{"location":"prerequisites/#centos-761810","text":"","title":"CentOS 7.6.1810"},{"location":"prerequisites/#required-packages_2","text":"epel-release : It provides a set of additional packages for Enterprise Linux; ius-release : It provides RPM packages for newer software versions for for Enterprise Linux distributions; cmake3 : Set of tools for automate building, testing of software; libXt-devel : Basic library for developing X11; libXext-devel : Library which contains a handful of X11 extensions devtoolset-7-gcc : Compiler suite for C and C++; numactl-devel : Development files for NUMA (simple programming interface to the policy supported by the Linux kernel); tbb-devel : Development files for TBB (C++ template library developed by Intel for parallel programming); openmpi3-devel : Development files for OpenMP (API for multiprocessor programming); rh-python36 , python and python-pip : Python 3 Interpreter and Package Manager.","title":"Required Packages"},{"location":"prerequisites/#optional-packages_2","text":"freeglut-devel : Development files for GLUT (OpenGL Utility Toolkit); lcov : Graphical front-end for GCC's coverage testing tool gcov; gcov : Tool to test code coverage in programs; llvm-toolset-7 : software collection that provides software from the LLVM suite; llvm-toolset-7-clang-tools-extra : software collection that provides clang - format and clang - tidy ; valgrind : A suite of tools for debugging and profiling; doxygen : Tool for generating documentation from annotated C++ sources; graphviz : Graph Visualization Software used optionally by Doxygen.","title":"Optional Packages"},{"location":"prerequisites/#installation_1","text":"","title":"Installation"},{"location":"prerequisites/#required-packages_3","text":"sudo yum update -y sudo yum -y install centos-release-scl epel-release sudo yum -y install https://centos7.iuscommunity.org/ius-release.rpm sudo yum -y install cmake3 libXt-devel libXext-devel \\ devtoolset-7-gcc* numactl-devel tbb-devel openmpi3-devel \\ rh-python36 python python-pip","title":"Required Packages"},{"location":"prerequisites/#optional-packages_3","text":"pip install --user mkdocs mkdocs-material sudo yum -y install lcov gcovr llvm-toolset-7 \\ llvm-toolset-7-clang-tools-extra doxygen graphviz valgrind freeglut-devel","title":"Optional Packages"},{"location":"prerequisites/#macos","text":"Attention Currently we support only installation of BioDynaMo using Homebrew and Fink. If you are using another package manager you will need to install all the corresponding packages.","title":"MacOS"},{"location":"prerequisites/#required-packages_4","text":"llvm : LLVM compiler suite with also OpenMP compliant clang and clang++; cmake : Set of tools for automate building, testing of software; libomp : Development files for OpenMP (API for multiprocessor programming); tbb : Development files for TBB (C++ template library developed by Intel for parallel programming); open-mpi : Development files for OpenMP (API for multiprocessor programming); python and python@2 : Python 3 Interpreter.","title":"Required Packages"},{"location":"prerequisites/#optional-packages_4","text":"doxygen : Tool for generating documentation from annotated C++ sources; lcov : Graphical front-end for GCC's coverage testing tool gcov; gcovr : Tool to test code coverage in programs.","title":"Optional Packages"},{"location":"prerequisites/#installation_2","text":"","title":"Installation"},{"location":"prerequisites/#required-packages_5","text":"Using HomeBrew: sudo brew install llvm cmake libomp tbb open-mpi \\ python python@2 brew upgrade python cmake Using Fink: sudo fink install llvm-clang cmake libomp-dev libtbb4 openmpi \\ python3 pip-py37","title":"Required Packages"},{"location":"prerequisites/#optional-packages_5","text":"Using HomeBrew: pip install --user mkdocs mkdocs-material sudo brew install doxygen lcov gcovr Using Fink: pip install --user mkdocs mkdocs-material sudo fink install doxygen","title":"Optional Packages"},{"location":"soma_clustering/","text":"Let's take a look at a more realistic example called soma clustering. In this example, we create two types of cells. Each type of cell secretes a specific substance, and moves along the gradient of its corresponding substance. This will form clusters of cells that are of the same type. Copy out the demo code Soma clustering is one of many installed demos. It can be copied to a target directory: biodynamo demo soma_clustering . Inspect the code Go into the soma_clustering directory and open the source file src / soma_clustering . h in your favorite editor. We can note the following things from its content: 1. Creating a custom simulation object In src / my_cell . h we can find the following code: class MyCell : public Cell { BDM_SIM_OBJECT_HEADER ( MyCell , Cell , 1 , cell_type_ ); public : MyCell () {} MyCell ( const Double3 & position ) : Base ( position ) {} void SetCellType ( int t ) { cell_type_ = t ; } int GetCellType () const { return cell_type_ ; } private : int cell_type_ ; We create a new type of cell called \"MyCell\" that extends the default Cell. It contains a new data member called cell_type_ that makes it possible to assign a type to a cell. 2. Define substances and biology modules In src / soma_clustering_biology_modules . h we can find the listing of the two substances that are used in this simulation: enum Substances { kSubstance_0 , kSubstance_1 }; We can also find the biology modules that were used in the Diffusion exercise. Configure the simulation Create a bdm . toml file in the diffusion directory, and create the following configuration file: [visualization] export = true export_interval = 10 [[visualize_sim_object]] name = \"MyCell\" additional_data_members = [ \"diameter_\", \"cell_type_\" ] [[visualize_diffusion]] name = \"Substance_0\" [[visualize_diffusion]] name = \"Substance_1\" This will enable exporting visualization files, so that we can visualize the simulation after it has finished. Furthermore, we enable the output of the diameter and the cell type of our simulation objects (named \"MyCell\"), and the two substances that are secreted. Build and run the simulation Run the following commands to build and run the simulation (do not forget to biodynamo source if you haven't already in your terminal): biodynamo build biodynamo run Visualize the simulation Open ParaView and navigate to the diffusion directory. Open the cells_data_ * and Kalium_ * files as Group (see the Visualization exercise as a reference). Click on the cells_data_ entry in the Pipeline Browser. From \"Filters\", select \"Search\" (or do Ctrl + Space). Search for the \"Glyph\" filter, Apply it, and set the following properties: Glyph Type = 'Sphere' Scalars = 'Diameters' Scale Mode = 'Scalar' Scale Factor = 1 Glyph Mode = 'All Points' And hit Apply. You might need to 'Zoom to Fit'. Hit the Play button on the top of the interface to play the simulation over time.","title":"Soma clustering"},{"location":"soma_clustering/#copy-out-the-demo-code","text":"Soma clustering is one of many installed demos. It can be copied to a target directory: biodynamo demo soma_clustering .","title":"Copy out the demo code"},{"location":"soma_clustering/#inspect-the-code","text":"Go into the soma_clustering directory and open the source file src / soma_clustering . h in your favorite editor. We can note the following things from its content:","title":"Inspect the code"},{"location":"soma_clustering/#1-creating-a-custom-simulation-object","text":"In src / my_cell . h we can find the following code: class MyCell : public Cell { BDM_SIM_OBJECT_HEADER ( MyCell , Cell , 1 , cell_type_ ); public : MyCell () {} MyCell ( const Double3 & position ) : Base ( position ) {} void SetCellType ( int t ) { cell_type_ = t ; } int GetCellType () const { return cell_type_ ; } private : int cell_type_ ; We create a new type of cell called \"MyCell\" that extends the default Cell. It contains a new data member called cell_type_ that makes it possible to assign a type to a cell.","title":"1. Creating a custom simulation object"},{"location":"soma_clustering/#2-define-substances-and-biology-modules","text":"In src / soma_clustering_biology_modules . h we can find the listing of the two substances that are used in this simulation: enum Substances { kSubstance_0 , kSubstance_1 }; We can also find the biology modules that were used in the Diffusion exercise.","title":"2. Define substances and biology modules"},{"location":"soma_clustering/#configure-the-simulation","text":"Create a bdm . toml file in the diffusion directory, and create the following configuration file: [visualization] export = true export_interval = 10 [[visualize_sim_object]] name = \"MyCell\" additional_data_members = [ \"diameter_\", \"cell_type_\" ] [[visualize_diffusion]] name = \"Substance_0\" [[visualize_diffusion]] name = \"Substance_1\" This will enable exporting visualization files, so that we can visualize the simulation after it has finished. Furthermore, we enable the output of the diameter and the cell type of our simulation objects (named \"MyCell\"), and the two substances that are secreted.","title":"Configure the simulation"},{"location":"soma_clustering/#build-and-run-the-simulation","text":"Run the following commands to build and run the simulation (do not forget to biodynamo source if you haven't already in your terminal): biodynamo build biodynamo run","title":"Build and run the simulation"},{"location":"soma_clustering/#visualize-the-simulation","text":"Open ParaView and navigate to the diffusion directory. Open the cells_data_ * and Kalium_ * files as Group (see the Visualization exercise as a reference). Click on the cells_data_ entry in the Pipeline Browser. From \"Filters\", select \"Search\" (or do Ctrl + Space). Search for the \"Glyph\" filter, Apply it, and set the following properties: Glyph Type = 'Sphere' Scalars = 'Diameters' Scale Mode = 'Scalar' Scale Factor = 1 Glyph Mode = 'All Points' And hit Apply. You might need to 'Zoom to Fit'. Hit the Play button on the top of the interface to play the simulation over time.","title":"Visualize the simulation"},{"location":"substance_initializers/","text":"You might want to initialize the concentration of one or more of the substances in your simulation. In this tutorial we shal take a look on how to do so. Tutorial by example Go into the test / integration directory and open the source file substance_initialization . h in your favorite editor. 1. List the substance(s) We start the code of by listing the s we will use in our simulation in an enum data structure. In this example we just create one substance. enum Substances { kSubstance }; 2. Specify the space dimensions We bound our space to keep things simple. Param :: bound_space_ = true ; Param :: min_bound_ = 0 ; Param :: max_bound_ = 250 ; 3. Create a cell We create one cell with diameter 10, at a random location auto construct = []( const Double3 & position ) { Cell * cell = new Cell ( position ); cell -> SetDiameter ( 10 ); return cell ; }; ModelInitializer :: CreateCellsRandom ( Param :: min_bound_ , Param :: max_bound_ , 1 , construct ); 4. Define the substance(s) We define the diffusion parameters of the substance(s) in our simulation. We choose a diffusion coefficient of 0.5, a decay constant 0f 0.1 and a resolution of 1. ModelInitializer :: DefineSubstance ( kSubstance , \"Substance\" , 0.5 , 0.1 , 1 ); 5. Initialize the substance(s) Now comes the most important part of the tutorial: initializing our substance(s) concentration values throught the space. We will use the function ModelInitializer :: InitializeSubstance for this purpose. ModelInitializer :: InitializeSubstance ( kSubstance , \"Substance\" , GaussianBand ( 120 , 5 , Axis :: kXAxis )); Let's break this down. We first pass the substance enum id and name in the function in order to specify which substance we want to initialize. Then we simply pass the model we want to initialize the substance with (we call these \"initializers\"). In this case we choose for a GaussianBand with a mean value of 120 along the x-axis, and a variance of 5. The result (visualized with ParaView) is the following: Creating a custom substance initializer In this tutorial you have seen how to initialize a substance's concentration values with the GaussianBand initializer. Of course this is not the only model to initialize a substance with. We have several predefined initializers available in BioDynaMo, and you can create your own. Let's take a look at an existing substance initializer. Option 1: Functors struct GaussianBand { double mean_ ; double sigma_ ; uint8_t axis_ ; GaussianBand ( double mean , double sigma , uint8_t axis ) { mean_ = mean ; sigma_ = sigma ; axis_ = axis ; } double operator ()( double x , double y , double z ) { switch ( axis_ ) { case Axis :: kXAxis : return ROOT :: Math :: normal_pdf ( x , sigma_ , mean_ ); case Axis :: kYAxis : return ROOT :: Math :: normal_pdf ( y , sigma_ , mean_ ); case Axis :: kZAxis : return ROOT :: Math :: normal_pdf ( z , sigma_ , mean_ ); default : throw std :: logic_error ( \"You have chosen an non-existing axis!\" ); } } }; The above code is what is called a 'functor' in C++. Here it basically describes the model or operation that you want to perform on the entire diffusion space. In the constructor we save the mean, variance and orientation axis, so that this initializer can be used generically. The operator tells BioDynaMo what the concentration value should be for x, y, and z. BioDynaMo will make sure that your operator is executed over the whole simulation space. In this example we make use of a function that models the normal (i.e. Gaussian) probability density function. Option 2: Lambdas Functors are nice if you want to create a generic model that you can apply for several input variables (e.g. different means, sigmas in the above example). But you might want to just keep it short and simple; in which case lambdas are nice to use. We can accomplish exactly the same result as the above example with the following lambda: auto gaussian_band = [] ( double x , double y , double z ) { return ROOT :: Math :: normal_pdf ( x , 5 , 120 ) ; } ; Much simpler right? As you can see we have hard-coded some of the variables that we had generalized in our functor. So depending on your use case or preference, lambdas might be the way to go.","title":"Substance Initialization"},{"location":"substance_initializers/#tutorial-by-example","text":"Go into the test / integration directory and open the source file substance_initialization . h in your favorite editor.","title":"Tutorial by example"},{"location":"substance_initializers/#1-list-the-substances","text":"We start the code of by listing the s we will use in our simulation in an enum data structure. In this example we just create one substance. enum Substances { kSubstance };","title":"1. List the substance(s)"},{"location":"substance_initializers/#2-specify-the-space-dimensions","text":"We bound our space to keep things simple. Param :: bound_space_ = true ; Param :: min_bound_ = 0 ; Param :: max_bound_ = 250 ;","title":"2. Specify the space dimensions"},{"location":"substance_initializers/#3-create-a-cell","text":"We create one cell with diameter 10, at a random location auto construct = []( const Double3 & position ) { Cell * cell = new Cell ( position ); cell -> SetDiameter ( 10 ); return cell ; }; ModelInitializer :: CreateCellsRandom ( Param :: min_bound_ , Param :: max_bound_ , 1 , construct );","title":"3. Create a cell"},{"location":"substance_initializers/#4-define-the-substances","text":"We define the diffusion parameters of the substance(s) in our simulation. We choose a diffusion coefficient of 0.5, a decay constant 0f 0.1 and a resolution of 1. ModelInitializer :: DefineSubstance ( kSubstance , \"Substance\" , 0.5 , 0.1 , 1 );","title":"4. Define the substance(s)"},{"location":"substance_initializers/#5-initialize-the-substances","text":"Now comes the most important part of the tutorial: initializing our substance(s) concentration values throught the space. We will use the function ModelInitializer :: InitializeSubstance for this purpose. ModelInitializer :: InitializeSubstance ( kSubstance , \"Substance\" , GaussianBand ( 120 , 5 , Axis :: kXAxis )); Let's break this down. We first pass the substance enum id and name in the function in order to specify which substance we want to initialize. Then we simply pass the model we want to initialize the substance with (we call these \"initializers\"). In this case we choose for a GaussianBand with a mean value of 120 along the x-axis, and a variance of 5. The result (visualized with ParaView) is the following:","title":"5. Initialize the substance(s)"},{"location":"substance_initializers/#creating-a-custom-substance-initializer","text":"In this tutorial you have seen how to initialize a substance's concentration values with the GaussianBand initializer. Of course this is not the only model to initialize a substance with. We have several predefined initializers available in BioDynaMo, and you can create your own. Let's take a look at an existing substance initializer.","title":"Creating a custom substance initializer"},{"location":"substance_initializers/#option-1-functors","text":"struct GaussianBand { double mean_ ; double sigma_ ; uint8_t axis_ ; GaussianBand ( double mean , double sigma , uint8_t axis ) { mean_ = mean ; sigma_ = sigma ; axis_ = axis ; } double operator ()( double x , double y , double z ) { switch ( axis_ ) { case Axis :: kXAxis : return ROOT :: Math :: normal_pdf ( x , sigma_ , mean_ ); case Axis :: kYAxis : return ROOT :: Math :: normal_pdf ( y , sigma_ , mean_ ); case Axis :: kZAxis : return ROOT :: Math :: normal_pdf ( z , sigma_ , mean_ ); default : throw std :: logic_error ( \"You have chosen an non-existing axis!\" ); } } }; The above code is what is called a 'functor' in C++. Here it basically describes the model or operation that you want to perform on the entire diffusion space. In the constructor we save the mean, variance and orientation axis, so that this initializer can be used generically. The operator tells BioDynaMo what the concentration value should be for x, y, and z. BioDynaMo will make sure that your operator is executed over the whole simulation space. In this example we make use of a function that models the normal (i.e. Gaussian) probability density function.","title":"Option 1: Functors"},{"location":"substance_initializers/#option-2-lambdas","text":"Functors are nice if you want to create a generic model that you can apply for several input variables (e.g. different means, sigmas in the above example). But you might want to just keep it short and simple; in which case lambdas are nice to use. We can accomplish exactly the same result as the above example with the following lambda: auto gaussian_band = [] ( double x , double y , double z ) { return ROOT :: Math :: normal_pdf ( x , 5 , 120 ) ; } ; Much simpler right? As you can see we have hard-coded some of the variables that we had generalized in our functor. So depending on your use case or preference, lambdas might be the way to go.","title":"Option 2: Lambdas"},{"location":"tumor_concept/","text":"Tumor concept Written by Jean de Montigny Introduction BioDynaMo is platform for computer simulations of biological dynamics. You can learn more about BioDynaMo by accessing its official website. This Tutorial in designed for user with limited knowledge of C++ language and will teach you the basics of BioDynaMo: Create, build and run a new project Create cells with a specific behaviour through a biological module Extend an existing structure Visualize a simulation Installation You can access the installation page by clicking here . Structure creation As BioDynaMo is written is C++, it needs a particular structure. Fortunately, this procedure is really easy with BioDynaMo. To create a new project, you just need to run the command biodynamo new < project > . If you wish to have your Github account linked to your project you can append the --github option to the command. Try opening a terminal and running the command biodynamo new tutorial . This will create a folder named tutorial in your current directory, containing everything that BioDynaMo needs. Inside tutorial / src , two files with the basic structure already written have been created: tutorial . cc and tutorial . h . tutorial . cc will only contain the call to function Simulate which is defined in tutorial . h . This is were the core of our work will be added. You can easily compile your code using the command biodynamo build and run your simulation by typing the command biodynamo run . You can also directly use biodynamo demo tumor_concept to try this demo. Cells and biology modules The structure built in the previous chapter only creates a single cell. In this chapter we will create more cells in order to build a square of 2 400 randomly distributed cells. Afterwards, we will create a number of cancerous cells, that will grow and divide. Creating cells To do so, we will work only on the Simulate function of the tutorial . h file. First, we create a lambda function to set the simulation parameters programmatically. Second, we create a BioDynaMo simulation. auto set_param = []( Param * param ) { param -> bound_space_ = true ; param -> min_bound_ = 0 ; param -> max_bound_ = 100 ; // cube of 100*100*100 }; Simulation simulation ( argc , argv , set_param ); Afterwards, we obtain a reference to a few important objects. ResourceManager will store our simulation objects. Random is a random number generator. Param holds our simulation parameters. auto * rm = simulation . GetResourceManager (); auto * random = simulation . GetRandom (); auto * param = simulation . GetParam (); Let's define the number of cells we want to create and allocate three variables to hold the position (x_coord, y_coord and z_coord). size_t nb_of_cells = 2400 ; // number of cells in the simulation double x_coord , y_coord , z_coord ; Then, with a simple loop from 0 to the number of cells, generate uniform distributed values for x, y and z and create a new cell object. for ( size_t i = 0 ; i < nb_of_cells ; ++ i ) { // our modelling will be a cell cube of 100*100*100 // random double between 0 and 100 x_coord = random -> Uniform ( param -> min_bound_ , param -> max_bound_ ); y_coord = random -> Uniform ( param -> min_bound_ , param -> max_bound_ ); z_coord = random -> Uniform ( param -> min_bound_ , param -> max_bound_ ); // creating the cell at position x, y, z Cell * cell = new Cell ({ x_coord , y_coord , z_coord }); // set cell parameters cell -> SetDiameter ( 7.5 ); rm -> push_back ( cell ); // put the created cell in our cells structure } We now have our structure containing all the 2400 cells! The code in charge of running our modelling is already written and will simulate it for only one step. Lets change this to simulate for 200 steps. simulation . GetScheduler () -> Simulate ( 200 ); Biology module In the previous chapter, we created a great number of cells. However, those cells don\u2019t do anything! We will here create a cancerous cell that will grow and divide when it reaches a certain diameter. For this, we will define a new biology module structure GrowthModule that will be applied to cell elements, and we will make this GrowthModule copied into the cell daughter (so the daughter will also contain an instance of the biology module GrowthModule) struct GrowthModule : public BaseBiologyModule { BDM_STATELESS_BM_HEADER ( GrowthModule , BaseBiologyModule , 1 ); public : GrowthModule () : BaseBiologyModule ( gAllEventIds ) {} /// Empty default event constructor, because GrowthModule does not have state. template < typename TEvent , typename TBm > GrowthModule ( const TEvent & event , TBm * other , uint64_t new_oid = 0 ) : BaseBiologyModule ( event , other , new_oid ) {} void Run ( SimObject * so ) override { // code to be executed at each simulation step } }; We are now able to add any code in the Run() method, that will be executed at each simulation step for each cell containing this GrowthModule. In our case, it will be a cellular growth, until a certain diameter is reached and then a cell division: if ( auto * cell = dynamic_cast < Cell *> ( so )) { if ( cell -> GetDiameter () < 8 ) { cell -> ChangeVolume ( 400 ); } else { cell -> Divide (); } } Of course, we need to create at least one new cell that contains our GrowthModule in our Simulate method Cell * cell = new Cell ({ 20 , 50 , 50 }); cell -> SetDiameter ( 6 ); cell -> AddBiologyModule ( new GrowthModule ()); rm -> push_back ( cell ); // put the created cell in our cells structure Run running it using biodynamo run . This code is now able to create and simulate 2 400 normal cells and 1 cancerous cell that will grow and divide! Complete code can be found in demo / tumor_concept . Visualisation using Paraview In the previous chapter we created a simulation of a great number of cell, also containing dividing cancerous cells, but we were not able to visualize anything, yet! In this chapter, we will set up visualization using Paraview (included in the BioDynaMo package). Dedicated page about visualization can be accessed here Paraview Paraview is an open source application for interactive and scientific visualisation. First of all, we need to tell BioDynaMo that we will use Paraview and so that we want the visualisation to be enable. To do that, we need to create a configuration file bdm . toml in the tutorial folder. Visualisation is of course not the only configuration we can do using this file. You can allow live visualisation and/or export visualisation (here every 2 simulation step) by adding in bdm . toml [ visualization ] live = false export = false export_interval = 2 Afterwards, we have to define which simulation objects will be considered for visualization: [[ visualize_sim_object ]] name = \"Cell\" Because those visualization parameters are not in the source code, you don\u2019t need to compile your code again. We can note that instead of creating a configuration file, you can do the same by creating this lambda function and passing it to the constructor of Simulation auto set_param = []( auto * param ) { param -> live_visualization_ = true ; // allows live visualisation param -> export_visualization_ = true ; // allows export of visualisation files param -> visualization_export_interval_ = 2 ; // export visualisation files every 2 steps param -> visualize_sim_objects_ [ \"Cell\" ] = std :: set < std :: string > { \"\" }; } Simulation simulation ( argc , argv , set_param ); Once again, it is important to note that if you want to change any visualization parameter using this second method, you will have to compile your code again. That is not the case using a configuration file. Hence, using the toml file is highly recommended. We will first have a look at export visualization then the live visualization. In both cases, simply run Paraview using the console line command paraview & . This window should appears Export Visualisation (recommended) In the configuration file (bdm.toml), turn the export parameter to true then run your modelling. You\u2019ll notice the creation of several new files with the following file extensions * . pvsm , * . pvtu , * . vtu , * pvti , * . vti in the folder output/tutorial. Open ParaView and load the generated state file as described in Section Visualization (file -> load state) A major advantage of export visualisation, in addition of not impacting the simulation time, is that you can visualise your modelling freely in time. using the arrows in the top menu, you can choose respectively to go back to the beginning of the simulation, go one step back, run normally, go one step further or go to the end of the simulation. You also can see witch step you are currently visualising (remember that this step number is the number of your modelling step divided by the export_interval you choose in your configuration file). Live visualisation To use live visualisation, turn the live option of your configuration file to true, then click on the Catalyst top menu, and select Connect . This windows should appears Click OK, then this windows should appears Your Paraview is now accepting connections! Click OK, go back to the Catalyst menu, and select Pause Simulation . Using the same console, launch your tutorial simulation. You now notice that the programme stop right before running the simulation, because we used the Paraview Pause Simulation . Go back to Paraview. You notice that new objects have appeared in the Pipeline Browser section. Click on the round shape in front of Cells Glyph . A new Builtin object have appeared: Extract: Cells Glyph . Click on the eye in front of it. All cells appear on the screen! You can now go to the Catalyst menu, and select Continue . The simulation will run the number of steps you specified in your code. Even if live visualization is particularly useful to set or tune a simulation, it is capital to note that it also drastically slows down the simulation! One way to avoid this major problem is to export visualization files and read then after the modeling is done. In both cases, even if we can now visualize our cell, they have all the same color, which can be a bit confusing and doesn't allow us to visualize properly what is going on. Adding layers color In this chapter, we will modify our code in order to create a better coloring for our simulation. A good idea would be to create a coloring depending on the layer of the cell. By this way, we could display several layers of cell, and have an other color for our cancerous cells. To do that, we can extend the existing Cell class in order to add a new data member cell_color . We will do that directly in our tutorial . h file by writing: // 0. Define my custom cell MyCell, which extends Cell by adding extra data // members: cell_color and can_divide class MyCell : public Cell { // our object extends the Cell object // create the header with our new data member BDM_SIM_OBJECT_HEADER ( MyCell , Cell , 1 , can_divide_ , cell_color_ ); public : MyCell () {} explicit MyCell ( const Double3 & position ) : Base ( position ) {} /// If MyCell divides, daughter 2 copies the data members from the mother MyCell ( const Event & event , SimObject * other , uint64_t new_oid = 0 ) : Base ( event , other , new_oid ) { if ( auto * mother = dynamic_cast < MyCell *> ( other )) { cell_color_ = mother -> cell_color_ ; } } /// If a cell divides, daughter keeps the same state from its mother. void EventHandler ( const Event & event , SimObject * other1 , SimObject * other2 = nullptr ) override { Base :: EventHandler ( event , other1 , other2 ); } void SetCellColor ( int cell_color ) { cell_color_ = cell_color ; } int GetCellColor () const { return cell_color_ ; } private : // declare new data member and define their type // private data can only be accessed by public function and not directly int cell_color_ ; }; Each cell (implementing our new object MyCell ) of the modelling is now able to have a value cell_color_ that we will choose and use to display different colors! In order to create cells with this attribute, we need to replace all Cell object by MyCell during cells creation (inside the Simulate () method). For example // Cell* cell = new Cell({x_coord, y_coord, z_coord}); MyCell * cell = new MyCell ({ x_coord , y_coord , z_coord }); Now that we are creating cells of type MyCell , we can set the cancerous cell cell_color_ value to 8 (so it will have a really distinct color from non cancerous cells). To do so, simply use the method SetCellColor() we created cell -> SetCellColour ( 8 ); Do the same for the regular cells, setting the value depending on the y axis value. One possibility is to write cell -> SetCellColour (( int )( y_coord / param -> max_bound_ * 6 )); // will vary from 0 to 5. so 6 different layers depending on y_coord This new simulation is now functional, however before running it, we need to tell BioDynaMo to communicate all cell_color_ values. Do do that, we will modify the configuration file bdm . toml by modifying the visualize_sim_object [[ visualize_sim_object ]] name = \"MyCell\" additional_data_members = [ \"cell_color_\" ] With those changes, we are now able to colorize our different layers. All you have to do, after displaying cells and creating the Glyph filter (chapter 3.1) is to select your Glyph filter and to select cell_color_ in the Coloring section. Well done, we can now visualize the different layers and the cancerous cell in red! However, there is still a little problem. The attribute cell_color_ is not transmitted to the daughter cell after a division. You can also notice that it is not really easy to see the cancerous cells. We will solve those issues in the next chapter. Playing with filters Even if our cancerous cells transmit their color to their daughter, it still is not really easy to spot them in the middle of thousands of other cells. This problem can be solve using the threshold filter function of ParaView. To do that, after displaying cells color as at the end of 3.2, click on the threshold filter button. This filter will be applied to the currently selected Pipeline Browser , so pay attention to select the correct one ( Glyph1 ) before creating the threshold filter. On the Properties menu, select the Scalar cell_colour_ , put the minimum value at 7 and the maximum at 8 (so only the value of cancerous cell is selected) then click Apply Finally, choose the Coloring mode cell_colour_ . Great, we can now choose to display either all the cells, or just the cancerous cells by selecting either the Glyph1 or the Threshold1 in the Pipeline Browser ! This is of course just an example of what you can do with the threshold filters. Adding some complexity We now have all we want to visualize our modeling in the best conditions, but this modeling itself is a bit limited. We should add some movements to it as well as a new mechanism to complexity cell division. To add cell movement, we will modify the Run () method of our biology module GrowthModule , and use the function UpdatePosition () . To generate the direction we will again use a random a random number generator. We choose here to give stochastic movement only to growing cells, so we will write the movement just after the volume change auto * random = Simulation :: GetActive () -> GetRandom (); // create an array of 3 random numbers between -2 and 2 Double3 cell_movements = random -> template UniformArray < 3 > ( - 2 , 2 ); // update the cell mass location, ie move the cell cell -> UpdatePosition ( cell_movements ); Using the previous chapters, you should now be able to visualize cell movement during their growth. This is great, but every cancerous cell grows and divides indefinitely, and that is a bit too much. We will now add a mechanism to reduce the probability to divide, and assuring that a cancerous cell that didn't divide, will never divide any more. To add a 0.8 probability to divide, simply write if ( random -> Uniform ( 0 , 1 ) < 0.8 ) { cell -> Divide (); } Cells will now have only 80% chance to divide. However, it will have 80% chance to divide at every simulation step! We want that if a cell doesn't divide, it will not be able to divide any more. To do that, we will create a new MyCell boolean attribute called can_divide_ , like we did for cell_colour_ attribute (see chapter 3.2). BDM_SIM_OBJECT_HEADER ( MyCell , Cell , 1 , can_divide_ , cell_color_ ); and create two methods, SetCanDivide () and GetCanDivide () . void SetCanDivide ( bool d ) { can_divide_ = d ; } bool GetCanDivide () { return can_divide_ ; } Then, like we did for cell_colour_ , declare this data member as private bool can_divide_ ; In the event constructor add the following lines to set can_divide_ to true in case of a CellDivisionEvent if ( event . GetId () == CellDivisionEvent :: kEventId ) { // the daughter will be able to divide can_divide_ = true ; } else { can_divide_ = mother -> can_divide_ ; } Now that we got a new attribute can_divide_ , we need to change the Run () method to prevent cells that failed the 80% test to divide again. if ( cell -> GetCanDivide () && random -> Uniform ( 0 , 1 ) < 0.8 ) { cell -> Divide (); } else { cell -> SetCanDivide ( false ); // this cell won't divide anymore } Codes corresponding to this chapter is accessible here . You now have all the BioDynaMo cell basic knowledge to construct your own modeling! Diffusion Coming soon.","title":"Tumor Concept"},{"location":"tumor_concept/#tumor-concept","text":"Written by Jean de Montigny","title":"Tumor concept"},{"location":"tumor_concept/#introduction","text":"BioDynaMo is platform for computer simulations of biological dynamics. You can learn more about BioDynaMo by accessing its official website. This Tutorial in designed for user with limited knowledge of C++ language and will teach you the basics of BioDynaMo: Create, build and run a new project Create cells with a specific behaviour through a biological module Extend an existing structure Visualize a simulation","title":"Introduction"},{"location":"tumor_concept/#installation","text":"You can access the installation page by clicking here .","title":"Installation"},{"location":"tumor_concept/#structure-creation","text":"As BioDynaMo is written is C++, it needs a particular structure. Fortunately, this procedure is really easy with BioDynaMo. To create a new project, you just need to run the command biodynamo new < project > . If you wish to have your Github account linked to your project you can append the --github option to the command. Try opening a terminal and running the command biodynamo new tutorial . This will create a folder named tutorial in your current directory, containing everything that BioDynaMo needs. Inside tutorial / src , two files with the basic structure already written have been created: tutorial . cc and tutorial . h . tutorial . cc will only contain the call to function Simulate which is defined in tutorial . h . This is were the core of our work will be added. You can easily compile your code using the command biodynamo build and run your simulation by typing the command biodynamo run . You can also directly use biodynamo demo tumor_concept to try this demo.","title":"Structure creation"},{"location":"tumor_concept/#cells-and-biology-modules","text":"The structure built in the previous chapter only creates a single cell. In this chapter we will create more cells in order to build a square of 2 400 randomly distributed cells. Afterwards, we will create a number of cancerous cells, that will grow and divide.","title":"Cells and biology modules"},{"location":"tumor_concept/#creating-cells","text":"To do so, we will work only on the Simulate function of the tutorial . h file. First, we create a lambda function to set the simulation parameters programmatically. Second, we create a BioDynaMo simulation. auto set_param = []( Param * param ) { param -> bound_space_ = true ; param -> min_bound_ = 0 ; param -> max_bound_ = 100 ; // cube of 100*100*100 }; Simulation simulation ( argc , argv , set_param ); Afterwards, we obtain a reference to a few important objects. ResourceManager will store our simulation objects. Random is a random number generator. Param holds our simulation parameters. auto * rm = simulation . GetResourceManager (); auto * random = simulation . GetRandom (); auto * param = simulation . GetParam (); Let's define the number of cells we want to create and allocate three variables to hold the position (x_coord, y_coord and z_coord). size_t nb_of_cells = 2400 ; // number of cells in the simulation double x_coord , y_coord , z_coord ; Then, with a simple loop from 0 to the number of cells, generate uniform distributed values for x, y and z and create a new cell object. for ( size_t i = 0 ; i < nb_of_cells ; ++ i ) { // our modelling will be a cell cube of 100*100*100 // random double between 0 and 100 x_coord = random -> Uniform ( param -> min_bound_ , param -> max_bound_ ); y_coord = random -> Uniform ( param -> min_bound_ , param -> max_bound_ ); z_coord = random -> Uniform ( param -> min_bound_ , param -> max_bound_ ); // creating the cell at position x, y, z Cell * cell = new Cell ({ x_coord , y_coord , z_coord }); // set cell parameters cell -> SetDiameter ( 7.5 ); rm -> push_back ( cell ); // put the created cell in our cells structure } We now have our structure containing all the 2400 cells! The code in charge of running our modelling is already written and will simulate it for only one step. Lets change this to simulate for 200 steps. simulation . GetScheduler () -> Simulate ( 200 );","title":"Creating cells"},{"location":"tumor_concept/#biology-module","text":"In the previous chapter, we created a great number of cells. However, those cells don\u2019t do anything! We will here create a cancerous cell that will grow and divide when it reaches a certain diameter. For this, we will define a new biology module structure GrowthModule that will be applied to cell elements, and we will make this GrowthModule copied into the cell daughter (so the daughter will also contain an instance of the biology module GrowthModule) struct GrowthModule : public BaseBiologyModule { BDM_STATELESS_BM_HEADER ( GrowthModule , BaseBiologyModule , 1 ); public : GrowthModule () : BaseBiologyModule ( gAllEventIds ) {} /// Empty default event constructor, because GrowthModule does not have state. template < typename TEvent , typename TBm > GrowthModule ( const TEvent & event , TBm * other , uint64_t new_oid = 0 ) : BaseBiologyModule ( event , other , new_oid ) {} void Run ( SimObject * so ) override { // code to be executed at each simulation step } }; We are now able to add any code in the Run() method, that will be executed at each simulation step for each cell containing this GrowthModule. In our case, it will be a cellular growth, until a certain diameter is reached and then a cell division: if ( auto * cell = dynamic_cast < Cell *> ( so )) { if ( cell -> GetDiameter () < 8 ) { cell -> ChangeVolume ( 400 ); } else { cell -> Divide (); } } Of course, we need to create at least one new cell that contains our GrowthModule in our Simulate method Cell * cell = new Cell ({ 20 , 50 , 50 }); cell -> SetDiameter ( 6 ); cell -> AddBiologyModule ( new GrowthModule ()); rm -> push_back ( cell ); // put the created cell in our cells structure Run running it using biodynamo run . This code is now able to create and simulate 2 400 normal cells and 1 cancerous cell that will grow and divide! Complete code can be found in demo / tumor_concept .","title":"Biology module"},{"location":"tumor_concept/#visualisation-using-paraview","text":"In the previous chapter we created a simulation of a great number of cell, also containing dividing cancerous cells, but we were not able to visualize anything, yet! In this chapter, we will set up visualization using Paraview (included in the BioDynaMo package). Dedicated page about visualization can be accessed here","title":"Visualisation using Paraview"},{"location":"tumor_concept/#paraview","text":"Paraview is an open source application for interactive and scientific visualisation. First of all, we need to tell BioDynaMo that we will use Paraview and so that we want the visualisation to be enable. To do that, we need to create a configuration file bdm . toml in the tutorial folder. Visualisation is of course not the only configuration we can do using this file. You can allow live visualisation and/or export visualisation (here every 2 simulation step) by adding in bdm . toml [ visualization ] live = false export = false export_interval = 2 Afterwards, we have to define which simulation objects will be considered for visualization: [[ visualize_sim_object ]] name = \"Cell\" Because those visualization parameters are not in the source code, you don\u2019t need to compile your code again. We can note that instead of creating a configuration file, you can do the same by creating this lambda function and passing it to the constructor of Simulation auto set_param = []( auto * param ) { param -> live_visualization_ = true ; // allows live visualisation param -> export_visualization_ = true ; // allows export of visualisation files param -> visualization_export_interval_ = 2 ; // export visualisation files every 2 steps param -> visualize_sim_objects_ [ \"Cell\" ] = std :: set < std :: string > { \"\" }; } Simulation simulation ( argc , argv , set_param ); Once again, it is important to note that if you want to change any visualization parameter using this second method, you will have to compile your code again. That is not the case using a configuration file. Hence, using the toml file is highly recommended. We will first have a look at export visualization then the live visualization. In both cases, simply run Paraview using the console line command paraview & . This window should appears","title":"Paraview"},{"location":"tumor_concept/#export-visualisation-recommended","text":"In the configuration file (bdm.toml), turn the export parameter to true then run your modelling. You\u2019ll notice the creation of several new files with the following file extensions * . pvsm , * . pvtu , * . vtu , * pvti , * . vti in the folder output/tutorial. Open ParaView and load the generated state file as described in Section Visualization (file -> load state) A major advantage of export visualisation, in addition of not impacting the simulation time, is that you can visualise your modelling freely in time. using the arrows in the top menu, you can choose respectively to go back to the beginning of the simulation, go one step back, run normally, go one step further or go to the end of the simulation. You also can see witch step you are currently visualising (remember that this step number is the number of your modelling step divided by the export_interval you choose in your configuration file).","title":"Export Visualisation (recommended)"},{"location":"tumor_concept/#live-visualisation","text":"To use live visualisation, turn the live option of your configuration file to true, then click on the Catalyst top menu, and select Connect . This windows should appears Click OK, then this windows should appears Your Paraview is now accepting connections! Click OK, go back to the Catalyst menu, and select Pause Simulation . Using the same console, launch your tutorial simulation. You now notice that the programme stop right before running the simulation, because we used the Paraview Pause Simulation . Go back to Paraview. You notice that new objects have appeared in the Pipeline Browser section. Click on the round shape in front of Cells Glyph . A new Builtin object have appeared: Extract: Cells Glyph . Click on the eye in front of it. All cells appear on the screen! You can now go to the Catalyst menu, and select Continue . The simulation will run the number of steps you specified in your code. Even if live visualization is particularly useful to set or tune a simulation, it is capital to note that it also drastically slows down the simulation! One way to avoid this major problem is to export visualization files and read then after the modeling is done. In both cases, even if we can now visualize our cell, they have all the same color, which can be a bit confusing and doesn't allow us to visualize properly what is going on.","title":"Live visualisation"},{"location":"tumor_concept/#adding-layers-color","text":"In this chapter, we will modify our code in order to create a better coloring for our simulation. A good idea would be to create a coloring depending on the layer of the cell. By this way, we could display several layers of cell, and have an other color for our cancerous cells. To do that, we can extend the existing Cell class in order to add a new data member cell_color . We will do that directly in our tutorial . h file by writing: // 0. Define my custom cell MyCell, which extends Cell by adding extra data // members: cell_color and can_divide class MyCell : public Cell { // our object extends the Cell object // create the header with our new data member BDM_SIM_OBJECT_HEADER ( MyCell , Cell , 1 , can_divide_ , cell_color_ ); public : MyCell () {} explicit MyCell ( const Double3 & position ) : Base ( position ) {} /// If MyCell divides, daughter 2 copies the data members from the mother MyCell ( const Event & event , SimObject * other , uint64_t new_oid = 0 ) : Base ( event , other , new_oid ) { if ( auto * mother = dynamic_cast < MyCell *> ( other )) { cell_color_ = mother -> cell_color_ ; } } /// If a cell divides, daughter keeps the same state from its mother. void EventHandler ( const Event & event , SimObject * other1 , SimObject * other2 = nullptr ) override { Base :: EventHandler ( event , other1 , other2 ); } void SetCellColor ( int cell_color ) { cell_color_ = cell_color ; } int GetCellColor () const { return cell_color_ ; } private : // declare new data member and define their type // private data can only be accessed by public function and not directly int cell_color_ ; }; Each cell (implementing our new object MyCell ) of the modelling is now able to have a value cell_color_ that we will choose and use to display different colors! In order to create cells with this attribute, we need to replace all Cell object by MyCell during cells creation (inside the Simulate () method). For example // Cell* cell = new Cell({x_coord, y_coord, z_coord}); MyCell * cell = new MyCell ({ x_coord , y_coord , z_coord }); Now that we are creating cells of type MyCell , we can set the cancerous cell cell_color_ value to 8 (so it will have a really distinct color from non cancerous cells). To do so, simply use the method SetCellColor() we created cell -> SetCellColour ( 8 ); Do the same for the regular cells, setting the value depending on the y axis value. One possibility is to write cell -> SetCellColour (( int )( y_coord / param -> max_bound_ * 6 )); // will vary from 0 to 5. so 6 different layers depending on y_coord This new simulation is now functional, however before running it, we need to tell BioDynaMo to communicate all cell_color_ values. Do do that, we will modify the configuration file bdm . toml by modifying the visualize_sim_object [[ visualize_sim_object ]] name = \"MyCell\" additional_data_members = [ \"cell_color_\" ] With those changes, we are now able to colorize our different layers. All you have to do, after displaying cells and creating the Glyph filter (chapter 3.1) is to select your Glyph filter and to select cell_color_ in the Coloring section. Well done, we can now visualize the different layers and the cancerous cell in red! However, there is still a little problem. The attribute cell_color_ is not transmitted to the daughter cell after a division. You can also notice that it is not really easy to see the cancerous cells. We will solve those issues in the next chapter.","title":"Adding layers color"},{"location":"tumor_concept/#playing-with-filters","text":"Even if our cancerous cells transmit their color to their daughter, it still is not really easy to spot them in the middle of thousands of other cells. This problem can be solve using the threshold filter function of ParaView. To do that, after displaying cells color as at the end of 3.2, click on the threshold filter button. This filter will be applied to the currently selected Pipeline Browser , so pay attention to select the correct one ( Glyph1 ) before creating the threshold filter. On the Properties menu, select the Scalar cell_colour_ , put the minimum value at 7 and the maximum at 8 (so only the value of cancerous cell is selected) then click Apply Finally, choose the Coloring mode cell_colour_ . Great, we can now choose to display either all the cells, or just the cancerous cells by selecting either the Glyph1 or the Threshold1 in the Pipeline Browser ! This is of course just an example of what you can do with the threshold filters.","title":"Playing with filters"},{"location":"tumor_concept/#adding-some-complexity","text":"We now have all we want to visualize our modeling in the best conditions, but this modeling itself is a bit limited. We should add some movements to it as well as a new mechanism to complexity cell division. To add cell movement, we will modify the Run () method of our biology module GrowthModule , and use the function UpdatePosition () . To generate the direction we will again use a random a random number generator. We choose here to give stochastic movement only to growing cells, so we will write the movement just after the volume change auto * random = Simulation :: GetActive () -> GetRandom (); // create an array of 3 random numbers between -2 and 2 Double3 cell_movements = random -> template UniformArray < 3 > ( - 2 , 2 ); // update the cell mass location, ie move the cell cell -> UpdatePosition ( cell_movements ); Using the previous chapters, you should now be able to visualize cell movement during their growth. This is great, but every cancerous cell grows and divides indefinitely, and that is a bit too much. We will now add a mechanism to reduce the probability to divide, and assuring that a cancerous cell that didn't divide, will never divide any more. To add a 0.8 probability to divide, simply write if ( random -> Uniform ( 0 , 1 ) < 0.8 ) { cell -> Divide (); } Cells will now have only 80% chance to divide. However, it will have 80% chance to divide at every simulation step! We want that if a cell doesn't divide, it will not be able to divide any more. To do that, we will create a new MyCell boolean attribute called can_divide_ , like we did for cell_colour_ attribute (see chapter 3.2). BDM_SIM_OBJECT_HEADER ( MyCell , Cell , 1 , can_divide_ , cell_color_ ); and create two methods, SetCanDivide () and GetCanDivide () . void SetCanDivide ( bool d ) { can_divide_ = d ; } bool GetCanDivide () { return can_divide_ ; } Then, like we did for cell_colour_ , declare this data member as private bool can_divide_ ; In the event constructor add the following lines to set can_divide_ to true in case of a CellDivisionEvent if ( event . GetId () == CellDivisionEvent :: kEventId ) { // the daughter will be able to divide can_divide_ = true ; } else { can_divide_ = mother -> can_divide_ ; } Now that we got a new attribute can_divide_ , we need to change the Run () method to prevent cells that failed the 80% test to divide again. if ( cell -> GetCanDivide () && random -> Uniform ( 0 , 1 ) < 0.8 ) { cell -> Divide (); } else { cell -> SetCanDivide ( false ); // this cell won't divide anymore } Codes corresponding to this chapter is accessible here . You now have all the BioDynaMo cell basic knowledge to construct your own modeling!","title":"Adding some complexity"},{"location":"tumor_concept/#diffusion","text":"Coming soon.","title":"Diffusion"},{"location":"visualization/","text":"Enabling visualization is very easy. BioDynaMo can be configured through its own configuration file: bdm . toml . Visualization is just one of the many configuration options. Let's take a look at how to set it. We shall continue using the hello_world example from the previous exercise. Create the configuration file In your simulation directory hello_world create a new file called bdm . toml . You can also do this from the command line with the following command: touch bdm.toml Export visualization files One way to enable visualization is to export a visualization file every time step (or every N time steps). In the bmd . toml file add the following lines: [visualization] export = true export_interval = 1 [[visualize_sim_object]] name = \"Cell\" additional_data_members = [ \"diameter_\" ] This will export a visualization file every time step. You can set the frequency by setting the export_interval . Make sure that you run a good number of steps so that the cells have time to divide. Set it to around 2000 for the hello_world example. You can do this in src / hello_world . h in the scheduler . Simulate ( time_steps ) function. Run your simulation with biodynamo run . Now we need to open ParaView: Warning Make sure you start ParaView from the project directory. Otherwise, ParaView might not find the exported files. paraview Select \"File->Load State\" as shown below: Navigate to your simulation output directory and select the pvsm file. In the next window keep the default ( Use File Names From State ) and click OK.","title":"Visualization"},{"location":"visualization/#create-the-configuration-file","text":"In your simulation directory hello_world create a new file called bdm . toml . You can also do this from the command line with the following command: touch bdm.toml","title":"Create the configuration file"},{"location":"visualization/#export-visualization-files","text":"One way to enable visualization is to export a visualization file every time step (or every N time steps). In the bmd . toml file add the following lines: [visualization] export = true export_interval = 1 [[visualize_sim_object]] name = \"Cell\" additional_data_members = [ \"diameter_\" ] This will export a visualization file every time step. You can set the frequency by setting the export_interval . Make sure that you run a good number of steps so that the cells have time to divide. Set it to around 2000 for the hello_world example. You can do this in src / hello_world . h in the scheduler . Simulate ( time_steps ) function. Run your simulation with biodynamo run . Now we need to open ParaView: Warning Make sure you start ParaView from the project directory. Otherwise, ParaView might not find the exported files. paraview Select \"File->Load State\" as shown below: Navigate to your simulation output directory and select the pvsm file. In the next window keep the default ( Use File Names From State ) and click OK.","title":"Export visualization files"}]}
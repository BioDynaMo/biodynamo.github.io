{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BioDynaMo What is BioDynaMo? BioDynaMo is a platform through which life scientists can easily create, run, and visualise three-dimensional biological simulations. Built on top of the latest computing technologies, the BioDynaMo platform will enable users to perform simulations of previously unachievable scale and complexity, making it possible to tackle challenging scientific research questions. Important Notes Version This guide corresponds to the latest version of BioDynaMo. Please make sure that your installation has the exact same version string as indicated at the top of the API documentation . Please head over to our installation/update instructions if you haven't installed BioDynaMo yet, or the installation is outdated. Execute biodynamo -v to check which version is installed on your system. The version string will look like: v0.1.0-84-g4ed0045 . This is how you can interpret it: vMAJOR.MINOR.PATCH-ADDITIONAL_COMMITS-gCOMMIT_ID Unstable API BioDynaMo is in an early development stage. Therefore, our API changes quite rapidly as we learn new requirements from our users. In case your simulation does not compile after an update, please have a look at our changelog and update your code.","title":"Welcome"},{"location":"#welcome-to-biodynamo","text":"","title":"Welcome to BioDynaMo"},{"location":"#what-is-biodynamo","text":"BioDynaMo is a platform through which life scientists can easily create, run, and visualise three-dimensional biological simulations. Built on top of the latest computing technologies, the BioDynaMo platform will enable users to perform simulations of previously unachievable scale and complexity, making it possible to tackle challenging scientific research questions.","title":"What is BioDynaMo?"},{"location":"#important-notes","text":"","title":"Important Notes"},{"location":"#version","text":"This guide corresponds to the latest version of BioDynaMo. Please make sure that your installation has the exact same version string as indicated at the top of the API documentation . Please head over to our installation/update instructions if you haven't installed BioDynaMo yet, or the installation is outdated. Execute biodynamo -v to check which version is installed on your system. The version string will look like: v0.1.0-84-g4ed0045 . This is how you can interpret it: vMAJOR.MINOR.PATCH-ADDITIONAL_COMMITS-gCOMMIT_ID","title":"Version"},{"location":"#unstable-api","text":"BioDynaMo is in an early development stage. Therefore, our API changes quite rapidly as we learn new requirements from our users. In case your simulation does not compile after an update, please have a look at our changelog and update your code.","title":"Unstable API"},{"location":"changelog/","text":"Changelog 16.07.2018 3bac827 Change github option for biodynamo new . Previously it was opt-out ( --no-github ). This commit changes it to opt-in ( --github ). Old New biodynamo new --no-github biodynamo new biodynamo new biodynamo new --github 11.07.2018 82e7e15 Add biodynamo demo command to try out the demos biodynamo demo lists all the available demos biodynamo demo demo-name dir sets up the demo demo-name in directory dir . If dir is not specified, it defaults to the current working directory. 26.06.2018 ba4fe1f Add support for multiple simulations per process. Only one simulation can be active at the same time. Introduces new class Simulation (see API ). This change causes many API changes -- see subsection below. Write simulation files to separate directory: output/simulation-id/ Integrate simulation template for biodynamo new into the biodynamo repository to avoid inconsistencies with the biodynamo version. API changes Old New InitializeBioDynaMo(...) Simulation simulation(...) Rm() TRm::Get() TResourceManager::Get() auto* rm = simulation.GetResourceManager(); GetDiffusionGrid(...) rm- GetDiffusionGrid(...) Grid::GetInstance() auto* grid = simulation.GetGrid(); Param :: some_parameter_ ; auto* param = simulation.GetParam(); param- some_parameter_;","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#16072018-3bac827","text":"Change github option for biodynamo new . Previously it was opt-out ( --no-github ). This commit changes it to opt-in ( --github ). Old New biodynamo new --no-github biodynamo new biodynamo new biodynamo new --github","title":"16.07.2018 3bac827"},{"location":"changelog/#11072018-82e7e15","text":"Add biodynamo demo command to try out the demos biodynamo demo lists all the available demos biodynamo demo demo-name dir sets up the demo demo-name in directory dir . If dir is not specified, it defaults to the current working directory.","title":"11.07.2018 82e7e15"},{"location":"changelog/#26062018-ba4fe1f","text":"Add support for multiple simulations per process. Only one simulation can be active at the same time. Introduces new class Simulation (see API ). This change causes many API changes -- see subsection below. Write simulation files to separate directory: output/simulation-id/ Integrate simulation template for biodynamo new into the biodynamo repository to avoid inconsistencies with the biodynamo version.","title":"26.06.2018 ba4fe1f"},{"location":"changelog/#api-changes","text":"Old New InitializeBioDynaMo(...) Simulation simulation(...) Rm() TRm::Get() TResourceManager::Get() auto* rm = simulation.GetResourceManager(); GetDiffusionGrid(...) rm- GetDiffusionGrid(...) Grid::GetInstance() auto* grid = simulation.GetGrid(); Param :: some_parameter_ ; auto* param = simulation.GetParam(); param- some_parameter_;","title":"API changes"},{"location":"contact/","text":"Contact Please contact us at: biodynamo-talk@cern.ch","title":"Contact"},{"location":"contact/#contact","text":"Please contact us at: biodynamo-talk@cern.ch","title":"Contact"},{"location":"diffusion/","text":"One of BioDynaMo's built-in biological processes is extracellular diffusion. It is the process of extracellular substances diffusing through space. The constants that govern the diffusion process can be set by the user. Let's go through an example where diffusion plays a role. Copy the demo code diffusion is one of many installed demos in BioDynaMo. It can be copied out with biodynamo demo . biodynamo demo diffusion . Inspect the code Go into the diffusion directory and open the source file src/diffusion_biology_modules.h in your favorite editor. We can note the following things from its content: 1. List the substances enum Substances { kKalium }; The extracellular substances that will be used in the simulation are listed in an enum data structure. In this case it is just a single substance. According to our C++ coding style we will prepend the substance's name with the letter \"k\". 2. Set up the biology modules Open the src/diffusion.h source file. In order for BioDynaMo to anticipate the biology modules that you want to use in the simulation, we need to declare them in our CompileTimeParameters as such: template typename Backend struct CompileTimeParam : public DefaultCompileTimeParam Backend { using BiologyModules = Variant Chemotaxis , KaliumSecretion ; }; The important part here is the Chemotaxis and KaliumSecretion biology modules. These are the modules that will govern the behavior of the simulation objects (i.e. cells). We import them at the top of the source code with #include diffusion_biology_modules . 3. Set up the simulation objects Next up is creating simulation objects: auto construct = []( const std :: array double , 3 position ) { Cell cell ( position ); cell . SetDiameter ( 30 ); cell . SetMass ( 1.0 ); cell . AddBiologyModule ( Chemotaxis ()); std :: array double , 3 secretion_position = {{ 50 , 50 , 50 }}; if ( position == secretion_position ) { cell . AddBiologyModule ( KaliumSecretion ()); } return cell ; }; std :: vector std :: array double , 3 positions ; positions . push_back ({ 0 , 0 , 0 }); positions . push_back ({ 100 , 0 , 0 }); positions . push_back ({ 0 , 100 , 0 }); positions . push_back ({ 0 , 0 , 100 }); positions . push_back ({ 0 , 100 , 100 }); positions . push_back ({ 100 , 0 , 100 }); positions . push_back ({ 100 , 100 , 0 }); positions . push_back ({ 100 , 100 , 100 }); // the cell responsible for secretion positions . push_back ({ 50 , 50 , 50 }); ModelInitializer :: CreateCells ( positions , construct ); The construct lambda defines the properties of each cell that we create. These can be physical properties (diameter, mass), but also biological properties and behaviors (chemotaxis, substance secretion) In this example, each cell is assigned the Chemotaxis behavior. In diffusion_biology_behaviors.h you can check the source code of this module. Basically it makes cells move according to the gradient, caused by a concentration difference of the substance. One of the cells (the cell at position {50, 50, 50} ) will be the one secreting the substance; it therefore gets assigned the SubstanceSecretion behavior. Furthermore, we define the initial positions of the cells. In this example it is done explicitly, but one could also generate a grid of cells, or a random distribution of cells. Configure the simulation Create a bdm.toml file in the diffusion directory, and copy the following lines into it: [visualization] export = true export_interval = 10 [[visualize_sim_object]] name = Cell additional_data_members = [ diameter_ ] [[visualize_diffusion]] name = Kalium gradient = true This will enable exporting visualization files, so that we can visualize the simulation after it has finished. Furthermore, we enable the output of the diameter of our simulation objects (by default named \"Cell\"), and the gradient data of the extracellular diffusion Build and run the simulation Run the following commands to build and run the simulation. biodynamo run Visualize the simulation Load the generated ParaView state file as described in Section Visualization . From \"View\", select \"Animation Panel\". This will display some animation settings at the bottom of the screen. From the \"Mode\" select \"Real Time\". Then click the Play button at the top of the screen to run the simulation visualization. Your browser does not support the video tag.","title":"Diffusion"},{"location":"diffusion/#copy-the-demo-code","text":"diffusion is one of many installed demos in BioDynaMo. It can be copied out with biodynamo demo . biodynamo demo diffusion .","title":"Copy the demo code"},{"location":"diffusion/#inspect-the-code","text":"Go into the diffusion directory and open the source file src/diffusion_biology_modules.h in your favorite editor. We can note the following things from its content:","title":"Inspect the code"},{"location":"diffusion/#1-list-the-substances","text":"enum Substances { kKalium }; The extracellular substances that will be used in the simulation are listed in an enum data structure. In this case it is just a single substance. According to our C++ coding style we will prepend the substance's name with the letter \"k\".","title":"1. List the substances"},{"location":"diffusion/#2-set-up-the-biology-modules","text":"Open the src/diffusion.h source file. In order for BioDynaMo to anticipate the biology modules that you want to use in the simulation, we need to declare them in our CompileTimeParameters as such: template typename Backend struct CompileTimeParam : public DefaultCompileTimeParam Backend { using BiologyModules = Variant Chemotaxis , KaliumSecretion ; }; The important part here is the Chemotaxis and KaliumSecretion biology modules. These are the modules that will govern the behavior of the simulation objects (i.e. cells). We import them at the top of the source code with #include diffusion_biology_modules .","title":"2. Set up the biology modules"},{"location":"diffusion/#3-set-up-the-simulation-objects","text":"Next up is creating simulation objects: auto construct = []( const std :: array double , 3 position ) { Cell cell ( position ); cell . SetDiameter ( 30 ); cell . SetMass ( 1.0 ); cell . AddBiologyModule ( Chemotaxis ()); std :: array double , 3 secretion_position = {{ 50 , 50 , 50 }}; if ( position == secretion_position ) { cell . AddBiologyModule ( KaliumSecretion ()); } return cell ; }; std :: vector std :: array double , 3 positions ; positions . push_back ({ 0 , 0 , 0 }); positions . push_back ({ 100 , 0 , 0 }); positions . push_back ({ 0 , 100 , 0 }); positions . push_back ({ 0 , 0 , 100 }); positions . push_back ({ 0 , 100 , 100 }); positions . push_back ({ 100 , 0 , 100 }); positions . push_back ({ 100 , 100 , 0 }); positions . push_back ({ 100 , 100 , 100 }); // the cell responsible for secretion positions . push_back ({ 50 , 50 , 50 }); ModelInitializer :: CreateCells ( positions , construct ); The construct lambda defines the properties of each cell that we create. These can be physical properties (diameter, mass), but also biological properties and behaviors (chemotaxis, substance secretion) In this example, each cell is assigned the Chemotaxis behavior. In diffusion_biology_behaviors.h you can check the source code of this module. Basically it makes cells move according to the gradient, caused by a concentration difference of the substance. One of the cells (the cell at position {50, 50, 50} ) will be the one secreting the substance; it therefore gets assigned the SubstanceSecretion behavior. Furthermore, we define the initial positions of the cells. In this example it is done explicitly, but one could also generate a grid of cells, or a random distribution of cells.","title":"3. Set up the simulation objects"},{"location":"diffusion/#configure-the-simulation","text":"Create a bdm.toml file in the diffusion directory, and copy the following lines into it: [visualization] export = true export_interval = 10 [[visualize_sim_object]] name = Cell additional_data_members = [ diameter_ ] [[visualize_diffusion]] name = Kalium gradient = true This will enable exporting visualization files, so that we can visualize the simulation after it has finished. Furthermore, we enable the output of the diameter of our simulation objects (by default named \"Cell\"), and the gradient data of the extracellular diffusion","title":"Configure the simulation"},{"location":"diffusion/#build-and-run-the-simulation","text":"Run the following commands to build and run the simulation. biodynamo run","title":"Build and run the simulation"},{"location":"diffusion/#visualize-the-simulation","text":"Load the generated ParaView state file as described in Section Visualization . From \"View\", select \"Animation Panel\". This will display some animation settings at the bottom of the screen. From the \"Mode\" select \"Real Time\". Then click the Play button at the top of the screen to run the simulation visualization. Your browser does not support the video tag.","title":"Visualize the simulation"},{"location":"documentation/","text":"Documentation Warning We are currently under construction!","title":"Documentation"},{"location":"documentation/#documentation","text":"Warning We are currently under construction!","title":"Documentation"},{"location":"first_steps/","text":"First Steps Setting up a simulation and running it is done with the BioDynaMo command line interface (CLI). Open a new terminal and execute: source path-to-bdm-installation /biodynamo-env.sh This command must be executed whenever you want to use BioDynaMo in a new terminal! Basic Workflow A basic BioDynaMo workflow looks as follows: 1. Create a new project To create a new project run the following command: biodynamo new enter_name This command creates a new Git repository for you with the name specified in the enter_name placeholder. You will see a folder appear with the same name, containing some template files to get you started. Tip If you wish to have your Github account linked to your project you can append the --github option to the command. biodynamo assist command requires --github 2. Implement your model The provided template files in your newly created folder can be used as a starting point for your simulation. The src directory contains the files with the source code that defines the simulation. You can edit and add the code that describes your model in this folder. 3. Run the simulation Building the simulation and running it can be done with the command: biodynamo run All your source code will be compiled and linked against the BioDynaMo libraries, and an executable file will be created and run. It is at this point you might encounter compilation errors. You will need to fix them before the simulation can actually run. Try out some demos There are some demos in the installation. They can be listed with the command: biodynamo demo Each of these demos can be copied out to a directory and executed with two biodynamo commands: biodynamo demo name [ target ] cd destination # as printed out by the previous command biodynamo run For example, to run the demo cell_division , we can do: biodynamo demo cell_division /tmp cd /tmp/cell_division biodynamo run Request assistance It can happen that you encounter an error or issue that you cannot solve on your own. Or you might be convinced that there is a bug in BioDynaMo. For such occasions we have provided you with BioDynaMo assistance: biodynamo assist This command will create a folder called debug in which debug information will be collected. A git branch will be created and uploaded to Github. Send the link to this branch to us, so we can take a look at the issue. Check out Contact on how to contact us.","title":"First Steps"},{"location":"first_steps/#first-steps","text":"Setting up a simulation and running it is done with the BioDynaMo command line interface (CLI). Open a new terminal and execute: source path-to-bdm-installation /biodynamo-env.sh This command must be executed whenever you want to use BioDynaMo in a new terminal!","title":"First Steps"},{"location":"first_steps/#basic-workflow","text":"A basic BioDynaMo workflow looks as follows:","title":"Basic Workflow"},{"location":"first_steps/#1-create-a-new-project","text":"To create a new project run the following command: biodynamo new enter_name This command creates a new Git repository for you with the name specified in the enter_name placeholder. You will see a folder appear with the same name, containing some template files to get you started. Tip If you wish to have your Github account linked to your project you can append the --github option to the command. biodynamo assist command requires --github","title":"1. Create a new project"},{"location":"first_steps/#2-implement-your-model","text":"The provided template files in your newly created folder can be used as a starting point for your simulation. The src directory contains the files with the source code that defines the simulation. You can edit and add the code that describes your model in this folder.","title":"2. Implement your model"},{"location":"first_steps/#3-run-the-simulation","text":"Building the simulation and running it can be done with the command: biodynamo run All your source code will be compiled and linked against the BioDynaMo libraries, and an executable file will be created and run. It is at this point you might encounter compilation errors. You will need to fix them before the simulation can actually run.","title":"3. Run the simulation"},{"location":"first_steps/#try-out-some-demos","text":"There are some demos in the installation. They can be listed with the command: biodynamo demo Each of these demos can be copied out to a directory and executed with two biodynamo commands: biodynamo demo name [ target ] cd destination # as printed out by the previous command biodynamo run For example, to run the demo cell_division , we can do: biodynamo demo cell_division /tmp cd /tmp/cell_division biodynamo run","title":"Try out some demos"},{"location":"first_steps/#request-assistance","text":"It can happen that you encounter an error or issue that you cannot solve on your own. Or you might be convinced that there is a bug in BioDynaMo. For such occasions we have provided you with BioDynaMo assistance: biodynamo assist This command will create a folder called debug in which debug information will be collected. A git branch will be created and uploaded to Github. Send the link to this branch to us, so we can take a look at the issue. Check out Contact on how to contact us.","title":"Request assistance"},{"location":"gpu_acceleration/","text":"GPU-acceleration: what and why? Physical interactions are one of the most compute intensive operations in biological simulations. The main reason is that the computations that are involved often include operators that require multiple CPU cycles to perform the corresponding operation. In an accurate model, physical interactions happen between all simulation objects and their local environment, for every time step. Therefore, you can imagine that a lot of performance can be gained by accelerating these interactions. General purpose GPUs (GPGPUs) make it possible to obtain the computing performance of a small cluster computer. Almost any desktop computer, or laptop has a built-in GPU available. It mostly takes care of all the graphical computations that take place on a computer, but recent developments allow us to use GPUs for high-performance computing purposes. Frameworks such as CUDA and OpenCL make it possible to program a GPU to perform the computations that we specify at a speed much higher than on a regular CPU. Of course, this depends on the type of computation that you want to perform, but fortunately physical interactions in BioDynaMo fits the bill. Requirements We try to keep things as simple as possible in terms of usage. So for the most part you are good to go as long as you meet either the following requirements: You have a CUDA-compatible GPU and CUDA installed You have an OpenCL-compatible GPU and OpenCL installed If you have multiple GPUs on your machine, BioDynaMo will automatically select one. You can also configure this yourself if you prefer one GPU over the other(s). More on this below. Enabling GPU acceleration The only thing you need to do to enjoy GPU acceleration is enabling it through the configuration file (bdm.toml) as following: [ experimental ] use_gpu = true By default we assume that your GPU is only CUDA-compatible. If you want to let BioDynaMo know you have an OpenCL-compatible GPU just append the following to the above snippet: use_opencl = true Note If you have multiple GPUs on your system you can select which BioDynaMo uses by setting the following flag: preferred_gpu = value , where value is the index of the GPU in the list of all GPUs.","title":"GPU Acceleration"},{"location":"gpu_acceleration/#gpu-acceleration-what-and-why","text":"Physical interactions are one of the most compute intensive operations in biological simulations. The main reason is that the computations that are involved often include operators that require multiple CPU cycles to perform the corresponding operation. In an accurate model, physical interactions happen between all simulation objects and their local environment, for every time step. Therefore, you can imagine that a lot of performance can be gained by accelerating these interactions. General purpose GPUs (GPGPUs) make it possible to obtain the computing performance of a small cluster computer. Almost any desktop computer, or laptop has a built-in GPU available. It mostly takes care of all the graphical computations that take place on a computer, but recent developments allow us to use GPUs for high-performance computing purposes. Frameworks such as CUDA and OpenCL make it possible to program a GPU to perform the computations that we specify at a speed much higher than on a regular CPU. Of course, this depends on the type of computation that you want to perform, but fortunately physical interactions in BioDynaMo fits the bill.","title":"GPU-acceleration: what and why?"},{"location":"gpu_acceleration/#requirements","text":"We try to keep things as simple as possible in terms of usage. So for the most part you are good to go as long as you meet either the following requirements: You have a CUDA-compatible GPU and CUDA installed You have an OpenCL-compatible GPU and OpenCL installed If you have multiple GPUs on your machine, BioDynaMo will automatically select one. You can also configure this yourself if you prefer one GPU over the other(s). More on this below.","title":"Requirements"},{"location":"gpu_acceleration/#enabling-gpu-acceleration","text":"The only thing you need to do to enjoy GPU acceleration is enabling it through the configuration file (bdm.toml) as following: [ experimental ] use_gpu = true By default we assume that your GPU is only CUDA-compatible. If you want to let BioDynaMo know you have an OpenCL-compatible GPU just append the following to the above snippet: use_opencl = true Note If you have multiple GPUs on your system you can select which BioDynaMo uses by setting the following flag: preferred_gpu = value , where value is the index of the GPU in the list of all GPUs.","title":"Enabling GPU acceleration"},{"location":"hello_world/","text":"The most basic BioDynaMo simulation (i.e. our Hello World program) is a static single cell. It is the default model that comes with the installation of BioDynaMo. In this section we shall go over the three simple steps of running this simple simulation. Step 1: Create your simulation Run the following command to create a new project called \"hello_world\": biodynamo new hello_world Step 2: Build your simulation Go into the newly created directory hello_world with: cd hello_world And build the project files with: biodynamo build Step 3: Run your simulation biodynamo run You should see \"Simulation completed succesfully\" as the output. Extra: Cell division Let's make the simulation more interesting by adding a biological behavior to the cell: cell division. Open the src/hello_world.h Replace the CompileTimeParameters struct with the following one: template typename Backend struct CompileTimeParam : public DefaultCompileTimeParam Backend { using BiologyModules = Variant GrowDivide ; }; And add the following line to the construct function: cell . AddBiologyModule ( GrowDivide ( 32 , 3000 , { gAllBmEvents })); Rebuild and rerun the simulation to have the cell division take effect. visit the next exercise to learn about the visualization features of BioDynaMo. Info You might want to run for a few more simulation steps to witness cells dividing","title":"Hello World"},{"location":"hello_world/#step-1-create-your-simulation","text":"Run the following command to create a new project called \"hello_world\": biodynamo new hello_world","title":"Step 1: Create your simulation"},{"location":"hello_world/#step-2-build-your-simulation","text":"Go into the newly created directory hello_world with: cd hello_world And build the project files with: biodynamo build","title":"Step 2: Build your simulation"},{"location":"hello_world/#step-3-run-your-simulation","text":"biodynamo run You should see \"Simulation completed succesfully\" as the output.","title":"Step 3: Run your simulation"},{"location":"hello_world/#extra-cell-division","text":"Let's make the simulation more interesting by adding a biological behavior to the cell: cell division. Open the src/hello_world.h Replace the CompileTimeParameters struct with the following one: template typename Backend struct CompileTimeParam : public DefaultCompileTimeParam Backend { using BiologyModules = Variant GrowDivide ; }; And add the following line to the construct function: cell . AddBiologyModule ( GrowDivide ( 32 , 3000 , { gAllBmEvents })); Rebuild and rerun the simulation to have the cell division take effect. visit the next exercise to learn about the visualization features of BioDynaMo. Info You might want to run for a few more simulation steps to witness cells dividing","title":"Extra: Cell division"},{"location":"installation/","text":"Installation To install BioDynaMo for the first time execute the following commands. The installation will also install all required packages including Paraview. git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo ./install.sh Important After the installation you need to restart your terminal. In every new terminal execute source path-to-bdm-installation /biodynamo-env.sh to use BioDynaMo! BioDynaMo uses a customized version of ParaView. Therefore, you should not install ParaView separately. Update Installation The following commands update your BioDynaMo installation: cd path/to/biodynamo # make sure you are on the master branch git checkout master # get latest changes git pull origin master ./install.sh Supported platforms Ubuntu 16.04, 18.04 Mac OSX","title":"Installation"},{"location":"installation/#installation","text":"To install BioDynaMo for the first time execute the following commands. The installation will also install all required packages including Paraview. git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo ./install.sh Important After the installation you need to restart your terminal. In every new terminal execute source path-to-bdm-installation /biodynamo-env.sh to use BioDynaMo! BioDynaMo uses a customized version of ParaView. Therefore, you should not install ParaView separately.","title":"Installation"},{"location":"installation/#update-installation","text":"The following commands update your BioDynaMo installation: cd path/to/biodynamo # make sure you are on the master branch git checkout master # get latest changes git pull origin master ./install.sh","title":"Update Installation"},{"location":"installation/#supported-platforms","text":"Ubuntu 16.04, 18.04 Mac OSX","title":"Supported platforms"},{"location":"jean_tuto/","text":"BioDynaMo short tutorial Written by Jean de Montigny Introduction BioDynaMo is platform for computer simulations of biological dynamics. You can learn more about BioDynaMo by accessing its official website. This Tutorial in designed for user with limited knowledge of C++ language and will teach you the basics of BioDynaMo: Create, build and run a new project Create cells with a specific behaviour through a biological module Extend an existing structure visualise a simulation Installation You can access the installation page by clicking here . Structure creation As BioDynaMo is written is C++, it needs a particular structure. Fortunately, this procedure is really easy with BioDynaMo. To create a new project, you just need to run the command biodynamo new project . If you wish to have your Github account linked to your project you can append the --github option to the command. Try opening a terminal and running the command biodynamo new tutorial . This will create a folder named tutorial in your current directory, containing everything that BioDynaMo needs. Inside tutorial/src, two files with the basic structure already written have been created: tutorial.cc and tutorial.h. tutorial.cc will only contain the call to the header tutorial.h which will be the core of our work. You can easily compile your code using the command biodynamo build and run your simulation by typing the command biodynamo run . You can also directly use biodynamo demo tumor_concept to try this demo. Cells and biology Module The structure build in the previous chapter only creates a single cell. In this chapter we will in a first time create more cells in order to building a square of 2 400 randomly distributed cells. Then in a second time, we will create a number of cancerous cells, that will grow and divide. Creating cells To do so, we will work only on the Simulate function of the tutorial.h file. Inside the Simulate method, we need to define a resource manager and a structure to contain our cells: Simulation simulation ( argc , argv ); auto * rm = simulation . GetResourceManager (); // set up resource manager auto * cells = rm - template Get Cell (); // create a structure to contain cells Because we want 2400 cells randomly distributed, it is mandatory to have an random number generator to generate x, y and z coordinate of each cell. For that, we will declare three double (x_coord, y_coord and z_coord) and use the included random engine. Still inside the Simulate method, write: auto * random = simulation . GetRandom (); // set up the random engine auto * param = simulation . GetParam (); // set up param size_t nb_of_cells = 2400 ; // number of cells in the simulation param - min_bound_ = 0 ; param - max_bound_ = 100 ; // cube of 100*100*100 double x_coord , y_coord , z_coord ; cells - reserve ( nb_of_cells ); // allocate the correct number of cell in our cells structure before cell creation Then, with a simple loop from 0 to the number of cells, we will be able to fill this cells structure with cell elements. for ( size_t i = 0 ; i nb_of_cells ; ++ i ) { // our modelling will be a cell cube of 100*100*100 // random double between min_bound and max_bound ( 0 and 100) x_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); y_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); z_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); // creating the cell at position x, y, z Cell cell ({ x_coord , y_coord , z_coord }); // set cell parameters cell . SetDiameter ( 7.5 ); cells - push_back ( cell ); // put the created cell in our cells structure } cells - Commit (); // commit cells We now have our structure containing all the 2400 cells! The code in charge of running our modelling is already written and will simulate it for only one step. Lets change this to simulate for 100 steps. simulation . GetScheduler () - Simulate ( 200 ); Biology module In the previous chapter, we created a great number of cells. However, those cells don\u2019t do anything! We will here create a cancerous cell that will grow and divide when it reaches a certain diameter. For this, we will define a new biology module structure GrowthModule that will be applied to cell elements, and we will make this GrowthModule copied into the cell daughter (so the daughter will also contain an instance of the biology module GrowthModule) struct GrowthModule : public BaseBiologyModule { GrowthModule () : BaseBiologyModule ( gAllBmEvents ) {} template typename T void Run ( T * cell ) { // code to be executed each at simulation step } ClassDefNV ( GrowthModule , 1 ); }; We are now able to add any code in the Run() method, that will be executed at each simulation step for each cell containing this GrowthModule. In our case, it will be a cellular growth, until a certain diameter is reached and then a cell division: if ( cell - GetDiameter () 8 ) { cell - ChangeVolume ( 400 ); } else { cell - Divide (); } After creating our GrowthModule, we need to add this Biology module to the compile time parameter, to tell BioDynaMo to use this new BiologyModule template typename Backend struct CompileTimeParam : public DefaultCompileTimeParam Backend { using BiologyModules = Variant GrowthModule ; // add GrowthModule }; Of course, we need to create at least one new cell that contains our GrowthModule in our Simulate method Cell cell ({ 20 , 50 , 50 }); cell . SetDiameter ( 6 ); cell . AddBiologyModule ( GrowthModule ()); cells - push_back ( cell ); Run running it using biodynamo run . This code is now able to create and simulate 2 400 normal cells and 1 cancerous cell that will grow and divide! Complete codes for tutorial.cc and tutorial.h of this chapter are accessible at the end of this tutorial. Visualisation using Paraview In the previous chapter we created a simulation of a great number of cell, also containing dividing cancerous cells, but we were not able to visualise anything! In this chapter, we will set up a visualisation using Paraview (included in the BioDynaMo package). Dedicated page about visualisation can be accessed here Paraview Paraview is an open source application for interactive and scientific visualisation. First of all, we need to tell BioDynaMo that we will use Paraview and so that we want the visualisation to be enable. To do that, we need to create a configuration file bdm.toml in the tutorial folder. Visualisation is of course not the only configuration we can do using this file. You can allow live visualisation and/or export visualisation (here every 2 simulation step) by adding in bdm.toml [ visualization ] live = false export = false export_interval = 2 you also can say to Paraview to visualise a particular parameter of ours cells, for example the diameter of every cells. Do do that, add below [visualization] in the configuration file the following lines [[ visualize_sim_object ]] name = Cell Because those visualisation parameters are not in the source code, you don\u2019t need to compile your code again. We can note that instead of creating a configuration file, you can do the same by adding directly in our Simulate function the lines param - live_visualization_ = true ; // allows live visualisation param - export_visualization_ = true ; // allows export of visualisation files param - visualization_export_interval_ = 2 ; // export visualisation files every 2 steps param - visualize_sim_objects_ [ Cell ] = std :: set std :: string { diameter_ }; // add the data member diameter_ to the visualisation objects Once again, it is important to note that if you want to change any visualisation parameter using this second method, you will have to compile again your code. That is not the case using a configuration file. Hence, using the toml file is highly recommended. We will first see export visualisation then the live visualisation. In both cases, simply run Paraview using the console line command paraview . This windows should appears Export Visualisation (recommended) In the configuration file (bdm.toml), turn the export parameter to true then run your modelling. You\u2019ll notice the creation of several new files with the following file extensions *.pvsm, *.pvtu, *.vtu, *pvti, *.vti in the folder output/tutorial. Open ParaView and load the generated state file as described in Section Visualization (file - load state) A major advantage of export visualisation, in addition of not impacting the simulation time, is that you can visualise your modelling freely in time. using the arrows in the top menu, you can choose respectively to go back to the beginning of the simulation, go one step back, run normally, go one step further or go to the end of the simulation. You also can see witch step you are currently visualising (remember that this step number is the number of your modelling step divided by the export_interval you choose in your configuration file). Live visualisation To use live visualisation, turn the live option of your configuration file to true, then click on the Catalyst top menu, and select Connect . This windows should appears Click OK, then this windows should appears Your Paraview is now accepting connections! Click OK, go back to the Catalyst menu, and select Pause Simulation . Using the same console, launch your tutorial simulation. You now notice that the programme stop right before running the simulation, because we used the Paraview Pause Simulation . Go back to Paraview. You notice that new objects have appeared in the Pipeline Browser section. Click on the round shape in front of Cells Glyph . A new Builtin object have appeared: Extract: Cells Glyph . Click on the eye in front of it. All cells appear on the screen! You can now go to the Catalyst menu, and select Continue . The simulation will run the number of steps you specified in your code. Even if live visualisation is particularly useful to set or tune a simulation, it is capital to note that it also drastically slows down the simulation! One way to avoid this major problem is to export visualisation files and read then after the modelling is done. In both cases, even if we can now visualise our cell, they have all the same colour, which can be a bit confusing and doesn't allow us to visualise properly what is going on. Adding layers colour In this chapter, we will modify our code in order to create a better colouring for our simulation. A good idea would be to create a colouring depending on the y axis coordinate. By this way, we could display several layers of cell, and have an other colour for our cancerous cells. To do that, we can extend the existing Cell class in order to add a new data member cell_colour . We will do that directly in our tutorial.h file by writing // Define my custom cell MyCell, which extends Cell by adding extra data members: cell_colour BDM_SIM_OBJECT ( MyCell , bdm :: Cell ) { // our object extends the Cell object BDM_SIM_OBJECT_HEADER ( MyCellExt , 1 , cell_colour_ ); // create the header with our new data member public : MyCellExt () {} MyCellExt ( const std :: array double , 3 position ) : Base ( position ) {} // our creator // getter and setter for our new data member void SetCelColour ( int cellColour ) { cell_colour_ [ kIdx ] = cellColour ; } int GetCellColour () { return cell_colour_ [ kIdx ]; } int * GetCellColourPtr () { return cell_colour_ . data (); } private : // private data can only be accessed by public function and not directly vec int cell_colour_ ; // declare our new data member and define its type }; Don't forget to add this new object to your compile time parameters (inside \"struct CompileTimeParam\") so BioDynaMo know that we want to use our custom MyCell object. This is done by adding the line using AtomicTypes = VariadicTypedef MyCell ; Each cell (implementing our new object MyCell ) of the modelling is now able to have a value cell_colour_ that we will choose and use to display different colours! In order to create cells with this attribute, we need to replace all Cell object by MyCell during cells creation (inside the Simulate() method). For example // auto* cells = rm- template Get Cell (); // previous structure containing Cell objects auto * cells = rm - template Get MyCell (); // new structure containing MyCell objects [...] // Cell cell({x_coord, y_coord, z_coord}); // creats a cell as a Cell object; so doesn t contain cell_colour_ MyCell cell ({ x_coord , y_coord , z_coord }); // creats a cell as a MyCell object; so contains cell_colour_ Now that we are creating cells implementing MyCell, we can set the cancerous cell cell_colour_ value to 8 (so it will have a really distinct colour from non cancerous cells). To do so, simply use the method SetCellColour() we created cell . SetCellColour ( 8 ); Do the same for the regular cells, setting the value depending on the y axis value. One possibility is to write cell . SetCellColour (( int )( y_coord / param - max_bound_ * 6 )); // will vary from 0 to 5. so 6 different layers depending on y_coord This new simulation is now functional, however before running it, we need to tell BioDynamo to communicates all cell_colour_ values. Do do that, we will modify the configuration file bdm.toml by modifying the visualize_sim_object [[ visualize_sim_object ]] name = MyCell additional_data_members = [ cell_colour_ ] With those changes, we are now able to colourise our different layers. All you have to do, after displaying cells and creating the Glyph filter (chapter 3.1) is to select your Glyph filter and to select cell_colour_ in the Coloring section. Well done, we can now visualise the different layers and the cancerous cell in red! However, there still is a little problem. The attribute cell_colour_ is not transmitted to the daughter cell after a division. You can also notice that it is not really easy to see the cancerous cells. We will solve those issues in the next chapter. Transmitting its colour and playing with Filters To enable dividing cells to transmit its colour - meaning its cell_colour_ attribute value - we have to modify a little our biology module. // cell- Divide(); // old auto daughter = cell - Divide (); // we now have access to the daughter daughter - SetCellColour ( cell - GetCellColour ()); // daughter cell_colour_ is setted to her mother cell_colour_ value Even if our cancerous cells transmit their colour to their daughter, it still is not really easy to spot them in the middle of thousands of other cells. This problem can be solve using the threshold filter function of Paraview. To do that, after displaying cells colour as at the end of 3.2, click on the threshold filter button. This filter will be applied to the currently selected Pipeline Browser , so pay attention to select the correct one ( Glyph1 ) before creating the threshold filter. On the Properties menu, select the Scalar cell_colour_ , put the minimum value at 7 and the maximum at 8 (so only the value of cancerous cell is selected) then click Apply Finaly, choose the Coloring mode cell_colour_ . Great, we can now choose to display either all the cells, or just the cancerous cells by selecting either the Glyph1 or the Threshold1 in the Pipeline Browser ! This is of course just an example of what you can do with the threshold filters. Adding some complexity We now have all we want to visualise our modelling in the best conditions, but this modelling itself is a bit limited. We should add some movements to it as well as a new mechanism to complexify cell division. To add cell movement, we will modify the Run() method of our biology module GrowthModule , and use the function UpdatePosition() . To generate the direction's random numbers we will again use the Uniform() function which allow us to generate a random number between two specified numbers. First, we need to add TSimulation to the template and to define the random engine. template typename T , typename TSimulation = Simulation void Run ( T * cell ) { auto * random = TSimulation :: GetActive () - GetRandom (); We choose here to give stochastic movement only to growing cells, so we will write the movement just after the volume change // create an array of 3 random numbers between -2 and 2 std :: array double , 3 cell_movements = random - template UniformArray 3 ( - 2 , 2 ); cell - UpdatePosition ( cell_movements ); // update the cell mass location, ie move the cell Using the previous chapters, you should now be able to visualise cell movement during their growth. This is great, but every cancerous cell grows and divides indefinitely, and that is a bit too much. We will now add a mechanism to reduce the probability to divide, and assuring that a cancerous cell that didn't divide, will never divide any more. To add a 0.8 probability to divide, simply write if ( random - Uniform ( 0 , 1 ) 0.8 ) { auto daughter = cell - Divide (); daughter - SetCellColour ( cell - GetCellColour ()); } Cells will now have only 80% chance to divide. However, it will have 80% chance to divide at every simulation step! We want that if a cell doesn't divide, it will not be able to divide any more. To do that, we will create a new MyCell boolean attribute called can_divide_. As well as for the cell_colour_ attribute (see chapter 3.2), add it our MyCell object header BDM_SIM_OBJECT_HEADER ( MyCellExt , 1 , can_divide_ , cell_colour_ ); and create two methods, SetCanDivide() and GetCanDivide() . void SetCanDivide ( bool d ) { can_divide_ [ kIdx ] = d ; } bool GetCanDivide () { return can_divide_ [ kIdx ]; } Then, as for cell_colour_, declare this data member as private vec bool can_divide_ ; Now that we got a new attribute can_divide_, we need to change the Run() method to prevent cells that failed the 80% test to divide again. Finally, don't forget to set the daughter can_divide_ value to true after a cell division. if ( cell - GetCanDivide () random - Uniform ( 0 , 1 ) 0.8 ) { auto daughter = cell - Divide (); // daughter take the cell_colour_ value of her mother daughter - SetCellColour ( cell - GetCellColour ()); daughter - SetCanDivide ( true ); // the daughter will be able to divide } else { cell - SetCanDivide ( false ); // this cell won t divide anymore } Codes corresponding to this chapter is accessible here . You now have all the BioDynaMo cell basic knowledge to construct your own modelling! Diffusion Coming soon. Code tutorial.h - chapter 2.2 #ifndef TUTORIAL_H_ #define TUTORIAL_H_ #include biodynamo.h namespace bdm { // 1. Define growth behaviour struct GrowthModule : public BaseBiologyModule { GrowthModule () : BaseBiologyModule ( gAllBmEvents ) {} template typename T void Run ( T * cell ) { if ( cell - GetDiameter () 8 ) { cell - ChangeVolume ( 400 ); } else { cell - Divide (); } } ClassDefNV ( GrowthModule , 1 ); }; // Define compile time parameter template typename Backend struct CompileTimeParam : public DefaultCompileTimeParam Backend { using BiologyModules = Variant GrowthModule ; // add GrowthModule }; inline int Simulate ( int argc , const char ** argv ) { Simulation simulation ( argc , argv ); auto * rm = simulation . GetResourceManager (); // set up resource manager auto * param = simulation . GetParam (); // set up params auto * random = simulation . GetRandom (); // set up the random engine size_t nb_of_cells = 2400 ; // number of cells in the simulation double x_coord , y_coord , z_coord ; param - bound_space_ = true ; param - min_bound_ = 0 ; param - max_bound_ = 100 ; // cube of 100*100*100 param - run_mechanical_interactions_ = true ; // create a structure to contain cells auto * cells = rm - template Get Cell (); // allocate the correct number of cell in our cells structure before // cell creation cells - reserve ( nb_of_cells ); for ( size_t i = 0 ; i nb_of_cells ; ++ i ) { // our modelling will be a cell cube of 100*100*100 // random double between 0 and 100 x_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); y_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); z_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); // creating the cell at position x, y, z Cell cell ({ x_coord , y_coord , z_coord }); // set cell parameters cell . SetDiameter ( 7.5 ); cells - push_back ( cell ); // put the created cell in our cells structure } // create a cancerous cell, containing the BiologyModule GrowthModule Cell cell ({ 20 , 50 , 50 }); cell . SetDiameter ( 6 ); cell . AddBiologyModule ( GrowthModule ()); cells - push_back ( cell ); // put the created cell in our cells structure cells - Commit (); // commit cells // Run simulation std :: cout simulating std :: endl ; simulation . GetScheduler () - Simulate ( 200 ); std :: cout Simulation completed successfully! std :: endl ; return 0 ; } // end simulate } // namespace bdm #endif // TUTORIAL_H_","title":"Tumor Concept"},{"location":"jean_tuto/#biodynamo-short-tutorial","text":"Written by Jean de Montigny","title":"BioDynaMo short tutorial"},{"location":"jean_tuto/#introduction","text":"BioDynaMo is platform for computer simulations of biological dynamics. You can learn more about BioDynaMo by accessing its official website. This Tutorial in designed for user with limited knowledge of C++ language and will teach you the basics of BioDynaMo: Create, build and run a new project Create cells with a specific behaviour through a biological module Extend an existing structure visualise a simulation","title":"Introduction"},{"location":"jean_tuto/#installation","text":"You can access the installation page by clicking here .","title":"Installation"},{"location":"jean_tuto/#structure-creation","text":"As BioDynaMo is written is C++, it needs a particular structure. Fortunately, this procedure is really easy with BioDynaMo. To create a new project, you just need to run the command biodynamo new project . If you wish to have your Github account linked to your project you can append the --github option to the command. Try opening a terminal and running the command biodynamo new tutorial . This will create a folder named tutorial in your current directory, containing everything that BioDynaMo needs. Inside tutorial/src, two files with the basic structure already written have been created: tutorial.cc and tutorial.h. tutorial.cc will only contain the call to the header tutorial.h which will be the core of our work. You can easily compile your code using the command biodynamo build and run your simulation by typing the command biodynamo run . You can also directly use biodynamo demo tumor_concept to try this demo.","title":"Structure creation"},{"location":"jean_tuto/#cells-and-biology-module","text":"The structure build in the previous chapter only creates a single cell. In this chapter we will in a first time create more cells in order to building a square of 2 400 randomly distributed cells. Then in a second time, we will create a number of cancerous cells, that will grow and divide.","title":"Cells and biology Module"},{"location":"jean_tuto/#creating-cells","text":"To do so, we will work only on the Simulate function of the tutorial.h file. Inside the Simulate method, we need to define a resource manager and a structure to contain our cells: Simulation simulation ( argc , argv ); auto * rm = simulation . GetResourceManager (); // set up resource manager auto * cells = rm - template Get Cell (); // create a structure to contain cells Because we want 2400 cells randomly distributed, it is mandatory to have an random number generator to generate x, y and z coordinate of each cell. For that, we will declare three double (x_coord, y_coord and z_coord) and use the included random engine. Still inside the Simulate method, write: auto * random = simulation . GetRandom (); // set up the random engine auto * param = simulation . GetParam (); // set up param size_t nb_of_cells = 2400 ; // number of cells in the simulation param - min_bound_ = 0 ; param - max_bound_ = 100 ; // cube of 100*100*100 double x_coord , y_coord , z_coord ; cells - reserve ( nb_of_cells ); // allocate the correct number of cell in our cells structure before cell creation Then, with a simple loop from 0 to the number of cells, we will be able to fill this cells structure with cell elements. for ( size_t i = 0 ; i nb_of_cells ; ++ i ) { // our modelling will be a cell cube of 100*100*100 // random double between min_bound and max_bound ( 0 and 100) x_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); y_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); z_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); // creating the cell at position x, y, z Cell cell ({ x_coord , y_coord , z_coord }); // set cell parameters cell . SetDiameter ( 7.5 ); cells - push_back ( cell ); // put the created cell in our cells structure } cells - Commit (); // commit cells We now have our structure containing all the 2400 cells! The code in charge of running our modelling is already written and will simulate it for only one step. Lets change this to simulate for 100 steps. simulation . GetScheduler () - Simulate ( 200 );","title":"Creating cells"},{"location":"jean_tuto/#biology-module","text":"In the previous chapter, we created a great number of cells. However, those cells don\u2019t do anything! We will here create a cancerous cell that will grow and divide when it reaches a certain diameter. For this, we will define a new biology module structure GrowthModule that will be applied to cell elements, and we will make this GrowthModule copied into the cell daughter (so the daughter will also contain an instance of the biology module GrowthModule) struct GrowthModule : public BaseBiologyModule { GrowthModule () : BaseBiologyModule ( gAllBmEvents ) {} template typename T void Run ( T * cell ) { // code to be executed each at simulation step } ClassDefNV ( GrowthModule , 1 ); }; We are now able to add any code in the Run() method, that will be executed at each simulation step for each cell containing this GrowthModule. In our case, it will be a cellular growth, until a certain diameter is reached and then a cell division: if ( cell - GetDiameter () 8 ) { cell - ChangeVolume ( 400 ); } else { cell - Divide (); } After creating our GrowthModule, we need to add this Biology module to the compile time parameter, to tell BioDynaMo to use this new BiologyModule template typename Backend struct CompileTimeParam : public DefaultCompileTimeParam Backend { using BiologyModules = Variant GrowthModule ; // add GrowthModule }; Of course, we need to create at least one new cell that contains our GrowthModule in our Simulate method Cell cell ({ 20 , 50 , 50 }); cell . SetDiameter ( 6 ); cell . AddBiologyModule ( GrowthModule ()); cells - push_back ( cell ); Run running it using biodynamo run . This code is now able to create and simulate 2 400 normal cells and 1 cancerous cell that will grow and divide! Complete codes for tutorial.cc and tutorial.h of this chapter are accessible at the end of this tutorial.","title":"Biology module"},{"location":"jean_tuto/#visualisation-using-paraview","text":"In the previous chapter we created a simulation of a great number of cell, also containing dividing cancerous cells, but we were not able to visualise anything! In this chapter, we will set up a visualisation using Paraview (included in the BioDynaMo package). Dedicated page about visualisation can be accessed here","title":"Visualisation using Paraview"},{"location":"jean_tuto/#paraview","text":"Paraview is an open source application for interactive and scientific visualisation. First of all, we need to tell BioDynaMo that we will use Paraview and so that we want the visualisation to be enable. To do that, we need to create a configuration file bdm.toml in the tutorial folder. Visualisation is of course not the only configuration we can do using this file. You can allow live visualisation and/or export visualisation (here every 2 simulation step) by adding in bdm.toml [ visualization ] live = false export = false export_interval = 2 you also can say to Paraview to visualise a particular parameter of ours cells, for example the diameter of every cells. Do do that, add below [visualization] in the configuration file the following lines [[ visualize_sim_object ]] name = Cell Because those visualisation parameters are not in the source code, you don\u2019t need to compile your code again. We can note that instead of creating a configuration file, you can do the same by adding directly in our Simulate function the lines param - live_visualization_ = true ; // allows live visualisation param - export_visualization_ = true ; // allows export of visualisation files param - visualization_export_interval_ = 2 ; // export visualisation files every 2 steps param - visualize_sim_objects_ [ Cell ] = std :: set std :: string { diameter_ }; // add the data member diameter_ to the visualisation objects Once again, it is important to note that if you want to change any visualisation parameter using this second method, you will have to compile again your code. That is not the case using a configuration file. Hence, using the toml file is highly recommended. We will first see export visualisation then the live visualisation. In both cases, simply run Paraview using the console line command paraview . This windows should appears","title":"Paraview"},{"location":"jean_tuto/#export-visualisation-recommended","text":"In the configuration file (bdm.toml), turn the export parameter to true then run your modelling. You\u2019ll notice the creation of several new files with the following file extensions *.pvsm, *.pvtu, *.vtu, *pvti, *.vti in the folder output/tutorial. Open ParaView and load the generated state file as described in Section Visualization (file - load state) A major advantage of export visualisation, in addition of not impacting the simulation time, is that you can visualise your modelling freely in time. using the arrows in the top menu, you can choose respectively to go back to the beginning of the simulation, go one step back, run normally, go one step further or go to the end of the simulation. You also can see witch step you are currently visualising (remember that this step number is the number of your modelling step divided by the export_interval you choose in your configuration file).","title":"Export Visualisation (recommended)"},{"location":"jean_tuto/#live-visualisation","text":"To use live visualisation, turn the live option of your configuration file to true, then click on the Catalyst top menu, and select Connect . This windows should appears Click OK, then this windows should appears Your Paraview is now accepting connections! Click OK, go back to the Catalyst menu, and select Pause Simulation . Using the same console, launch your tutorial simulation. You now notice that the programme stop right before running the simulation, because we used the Paraview Pause Simulation . Go back to Paraview. You notice that new objects have appeared in the Pipeline Browser section. Click on the round shape in front of Cells Glyph . A new Builtin object have appeared: Extract: Cells Glyph . Click on the eye in front of it. All cells appear on the screen! You can now go to the Catalyst menu, and select Continue . The simulation will run the number of steps you specified in your code. Even if live visualisation is particularly useful to set or tune a simulation, it is capital to note that it also drastically slows down the simulation! One way to avoid this major problem is to export visualisation files and read then after the modelling is done. In both cases, even if we can now visualise our cell, they have all the same colour, which can be a bit confusing and doesn't allow us to visualise properly what is going on.","title":"Live visualisation"},{"location":"jean_tuto/#adding-layers-colour","text":"In this chapter, we will modify our code in order to create a better colouring for our simulation. A good idea would be to create a colouring depending on the y axis coordinate. By this way, we could display several layers of cell, and have an other colour for our cancerous cells. To do that, we can extend the existing Cell class in order to add a new data member cell_colour . We will do that directly in our tutorial.h file by writing // Define my custom cell MyCell, which extends Cell by adding extra data members: cell_colour BDM_SIM_OBJECT ( MyCell , bdm :: Cell ) { // our object extends the Cell object BDM_SIM_OBJECT_HEADER ( MyCellExt , 1 , cell_colour_ ); // create the header with our new data member public : MyCellExt () {} MyCellExt ( const std :: array double , 3 position ) : Base ( position ) {} // our creator // getter and setter for our new data member void SetCelColour ( int cellColour ) { cell_colour_ [ kIdx ] = cellColour ; } int GetCellColour () { return cell_colour_ [ kIdx ]; } int * GetCellColourPtr () { return cell_colour_ . data (); } private : // private data can only be accessed by public function and not directly vec int cell_colour_ ; // declare our new data member and define its type }; Don't forget to add this new object to your compile time parameters (inside \"struct CompileTimeParam\") so BioDynaMo know that we want to use our custom MyCell object. This is done by adding the line using AtomicTypes = VariadicTypedef MyCell ; Each cell (implementing our new object MyCell ) of the modelling is now able to have a value cell_colour_ that we will choose and use to display different colours! In order to create cells with this attribute, we need to replace all Cell object by MyCell during cells creation (inside the Simulate() method). For example // auto* cells = rm- template Get Cell (); // previous structure containing Cell objects auto * cells = rm - template Get MyCell (); // new structure containing MyCell objects [...] // Cell cell({x_coord, y_coord, z_coord}); // creats a cell as a Cell object; so doesn t contain cell_colour_ MyCell cell ({ x_coord , y_coord , z_coord }); // creats a cell as a MyCell object; so contains cell_colour_ Now that we are creating cells implementing MyCell, we can set the cancerous cell cell_colour_ value to 8 (so it will have a really distinct colour from non cancerous cells). To do so, simply use the method SetCellColour() we created cell . SetCellColour ( 8 ); Do the same for the regular cells, setting the value depending on the y axis value. One possibility is to write cell . SetCellColour (( int )( y_coord / param - max_bound_ * 6 )); // will vary from 0 to 5. so 6 different layers depending on y_coord This new simulation is now functional, however before running it, we need to tell BioDynamo to communicates all cell_colour_ values. Do do that, we will modify the configuration file bdm.toml by modifying the visualize_sim_object [[ visualize_sim_object ]] name = MyCell additional_data_members = [ cell_colour_ ] With those changes, we are now able to colourise our different layers. All you have to do, after displaying cells and creating the Glyph filter (chapter 3.1) is to select your Glyph filter and to select cell_colour_ in the Coloring section. Well done, we can now visualise the different layers and the cancerous cell in red! However, there still is a little problem. The attribute cell_colour_ is not transmitted to the daughter cell after a division. You can also notice that it is not really easy to see the cancerous cells. We will solve those issues in the next chapter.","title":"Adding layers colour"},{"location":"jean_tuto/#transmitting-its-colour-and-playing-with-filters","text":"To enable dividing cells to transmit its colour - meaning its cell_colour_ attribute value - we have to modify a little our biology module. // cell- Divide(); // old auto daughter = cell - Divide (); // we now have access to the daughter daughter - SetCellColour ( cell - GetCellColour ()); // daughter cell_colour_ is setted to her mother cell_colour_ value Even if our cancerous cells transmit their colour to their daughter, it still is not really easy to spot them in the middle of thousands of other cells. This problem can be solve using the threshold filter function of Paraview. To do that, after displaying cells colour as at the end of 3.2, click on the threshold filter button. This filter will be applied to the currently selected Pipeline Browser , so pay attention to select the correct one ( Glyph1 ) before creating the threshold filter. On the Properties menu, select the Scalar cell_colour_ , put the minimum value at 7 and the maximum at 8 (so only the value of cancerous cell is selected) then click Apply Finaly, choose the Coloring mode cell_colour_ . Great, we can now choose to display either all the cells, or just the cancerous cells by selecting either the Glyph1 or the Threshold1 in the Pipeline Browser ! This is of course just an example of what you can do with the threshold filters.","title":"Transmitting its colour and playing with Filters"},{"location":"jean_tuto/#adding-some-complexity","text":"We now have all we want to visualise our modelling in the best conditions, but this modelling itself is a bit limited. We should add some movements to it as well as a new mechanism to complexify cell division. To add cell movement, we will modify the Run() method of our biology module GrowthModule , and use the function UpdatePosition() . To generate the direction's random numbers we will again use the Uniform() function which allow us to generate a random number between two specified numbers. First, we need to add TSimulation to the template and to define the random engine. template typename T , typename TSimulation = Simulation void Run ( T * cell ) { auto * random = TSimulation :: GetActive () - GetRandom (); We choose here to give stochastic movement only to growing cells, so we will write the movement just after the volume change // create an array of 3 random numbers between -2 and 2 std :: array double , 3 cell_movements = random - template UniformArray 3 ( - 2 , 2 ); cell - UpdatePosition ( cell_movements ); // update the cell mass location, ie move the cell Using the previous chapters, you should now be able to visualise cell movement during their growth. This is great, but every cancerous cell grows and divides indefinitely, and that is a bit too much. We will now add a mechanism to reduce the probability to divide, and assuring that a cancerous cell that didn't divide, will never divide any more. To add a 0.8 probability to divide, simply write if ( random - Uniform ( 0 , 1 ) 0.8 ) { auto daughter = cell - Divide (); daughter - SetCellColour ( cell - GetCellColour ()); } Cells will now have only 80% chance to divide. However, it will have 80% chance to divide at every simulation step! We want that if a cell doesn't divide, it will not be able to divide any more. To do that, we will create a new MyCell boolean attribute called can_divide_. As well as for the cell_colour_ attribute (see chapter 3.2), add it our MyCell object header BDM_SIM_OBJECT_HEADER ( MyCellExt , 1 , can_divide_ , cell_colour_ ); and create two methods, SetCanDivide() and GetCanDivide() . void SetCanDivide ( bool d ) { can_divide_ [ kIdx ] = d ; } bool GetCanDivide () { return can_divide_ [ kIdx ]; } Then, as for cell_colour_, declare this data member as private vec bool can_divide_ ; Now that we got a new attribute can_divide_, we need to change the Run() method to prevent cells that failed the 80% test to divide again. Finally, don't forget to set the daughter can_divide_ value to true after a cell division. if ( cell - GetCanDivide () random - Uniform ( 0 , 1 ) 0.8 ) { auto daughter = cell - Divide (); // daughter take the cell_colour_ value of her mother daughter - SetCellColour ( cell - GetCellColour ()); daughter - SetCanDivide ( true ); // the daughter will be able to divide } else { cell - SetCanDivide ( false ); // this cell won t divide anymore } Codes corresponding to this chapter is accessible here . You now have all the BioDynaMo cell basic knowledge to construct your own modelling!","title":"Adding some complexity"},{"location":"jean_tuto/#diffusion","text":"Coming soon.","title":"Diffusion"},{"location":"jean_tuto/#code","text":"","title":"Code"},{"location":"jean_tuto/#tutorialh-chapter-22","text":"#ifndef TUTORIAL_H_ #define TUTORIAL_H_ #include biodynamo.h namespace bdm { // 1. Define growth behaviour struct GrowthModule : public BaseBiologyModule { GrowthModule () : BaseBiologyModule ( gAllBmEvents ) {} template typename T void Run ( T * cell ) { if ( cell - GetDiameter () 8 ) { cell - ChangeVolume ( 400 ); } else { cell - Divide (); } } ClassDefNV ( GrowthModule , 1 ); }; // Define compile time parameter template typename Backend struct CompileTimeParam : public DefaultCompileTimeParam Backend { using BiologyModules = Variant GrowthModule ; // add GrowthModule }; inline int Simulate ( int argc , const char ** argv ) { Simulation simulation ( argc , argv ); auto * rm = simulation . GetResourceManager (); // set up resource manager auto * param = simulation . GetParam (); // set up params auto * random = simulation . GetRandom (); // set up the random engine size_t nb_of_cells = 2400 ; // number of cells in the simulation double x_coord , y_coord , z_coord ; param - bound_space_ = true ; param - min_bound_ = 0 ; param - max_bound_ = 100 ; // cube of 100*100*100 param - run_mechanical_interactions_ = true ; // create a structure to contain cells auto * cells = rm - template Get Cell (); // allocate the correct number of cell in our cells structure before // cell creation cells - reserve ( nb_of_cells ); for ( size_t i = 0 ; i nb_of_cells ; ++ i ) { // our modelling will be a cell cube of 100*100*100 // random double between 0 and 100 x_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); y_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); z_coord = random - Uniform ( param - min_bound_ , param - max_bound_ ); // creating the cell at position x, y, z Cell cell ({ x_coord , y_coord , z_coord }); // set cell parameters cell . SetDiameter ( 7.5 ); cells - push_back ( cell ); // put the created cell in our cells structure } // create a cancerous cell, containing the BiologyModule GrowthModule Cell cell ({ 20 , 50 , 50 }); cell . SetDiameter ( 6 ); cell . AddBiologyModule ( GrowthModule ()); cells - push_back ( cell ); // put the created cell in our cells structure cells - Commit (); // commit cells // Run simulation std :: cout simulating std :: endl ; simulation . GetScheduler () - Simulate ( 200 ); std :: cout Simulation completed successfully! std :: endl ; return 0 ; } // end simulate } // namespace bdm #endif // TUTORIAL_H_","title":"tutorial.h - chapter 2.2"},{"location":"soma_clustering/","text":"Let's take a look at a more realistic example called soma clustering. In this example, we create two types of cells. Each type of cell secretes a specific substance, and moves along the gradient of its corresponding substance. This will form clusters of cells that are of the same type. Copy out the demo code Soma clustering is one of many installed demos. It can be copied to a target directory: biodynamo demo soma_clustering . Inspect the code Go into the soma_clustering directory and open the source file src/soma_clustering.h in your favorite editor. We can note the following things from its content: 1. Creating a custom simulation object In src/my_cell.h we can find the following code: BDM_SIM_OBJECT ( MyCell , bdm :: Cell ) { BDM_SIM_OBJECT_HEADER ( MyCellExt , 1 , cell_type_ ); public : MyCellExt () {} MyCellExt ( const std :: array double , 3 position ) : Base ( position ) {} void SetCellType ( int t ) { cell_type_ [ kIdx ] = t ; } int GetCellType () const { return cell_type_ [ kIdx ]; } private : vec int cell_type_ ; We create a new type of cell called \"MyCell\" that extends the default Cell. It contains a new data member called cell_type_ that makes it possible to assign a type to a cell. 2. Define substances and biology modules In src/soma_clustering_biology_modules.h we can find the listing of the two substances that are used in this simulation: enum Substances { kSubstance_0 , kSubstance_1 }; We can also find the biology modules that were used in the Diffusion exercise. Configure the simulation Create a bdm.toml file in the diffusion directory, and create the following configuration file: [visualization] export = true export_interval = 10 [[visualize_sim_object]] name = MyCell additional_data_members = [ diameter_ , cell_type_ ] [[visualize_diffusion]] name = Substance_0 [[visualize_diffusion]] name = Substance_1 This will enable exporting visualization files, so that we can visualize the simulation after it has finished. Furthermore, we enable the output of the diameter and the cell type of our simulation objects (named \"MyCell\"), and the two substances that are secreted. Build and run the simulation Run the following commands to build and run the simulation (do not forget to biodynamo source if you haven't already in your terminal): biodynamo build biodynamo run Visualize the simulation Open ParaView and navigate to the diffusion directory. Open the cells_data_* and Kalium_* files as Group (see the Visualization exercise as a reference). Click on the cells_data_ entry in the Pipeline Browser. From \"Filters\", select \"Search\" (or do Ctrl + Space). Search for the \"Glyph\" filter, Apply it, and set the following properties: Glyph Type = Sphere Scalars = Diameters Scale Mode = Scalar Scale Factor = 1 Glyph Mode = All Points And hit Apply. You might need to 'Zoom to Fit'. Hit the Play button on the top of the interface to play the simulation over time.","title":"Soma clustering"},{"location":"soma_clustering/#copy-out-the-demo-code","text":"Soma clustering is one of many installed demos. It can be copied to a target directory: biodynamo demo soma_clustering .","title":"Copy out the demo code"},{"location":"soma_clustering/#inspect-the-code","text":"Go into the soma_clustering directory and open the source file src/soma_clustering.h in your favorite editor. We can note the following things from its content:","title":"Inspect the code"},{"location":"soma_clustering/#1-creating-a-custom-simulation-object","text":"In src/my_cell.h we can find the following code: BDM_SIM_OBJECT ( MyCell , bdm :: Cell ) { BDM_SIM_OBJECT_HEADER ( MyCellExt , 1 , cell_type_ ); public : MyCellExt () {} MyCellExt ( const std :: array double , 3 position ) : Base ( position ) {} void SetCellType ( int t ) { cell_type_ [ kIdx ] = t ; } int GetCellType () const { return cell_type_ [ kIdx ]; } private : vec int cell_type_ ; We create a new type of cell called \"MyCell\" that extends the default Cell. It contains a new data member called cell_type_ that makes it possible to assign a type to a cell.","title":"1. Creating a custom simulation object"},{"location":"soma_clustering/#2-define-substances-and-biology-modules","text":"In src/soma_clustering_biology_modules.h we can find the listing of the two substances that are used in this simulation: enum Substances { kSubstance_0 , kSubstance_1 }; We can also find the biology modules that were used in the Diffusion exercise.","title":"2. Define substances and biology modules"},{"location":"soma_clustering/#configure-the-simulation","text":"Create a bdm.toml file in the diffusion directory, and create the following configuration file: [visualization] export = true export_interval = 10 [[visualize_sim_object]] name = MyCell additional_data_members = [ diameter_ , cell_type_ ] [[visualize_diffusion]] name = Substance_0 [[visualize_diffusion]] name = Substance_1 This will enable exporting visualization files, so that we can visualize the simulation after it has finished. Furthermore, we enable the output of the diameter and the cell type of our simulation objects (named \"MyCell\"), and the two substances that are secreted.","title":"Configure the simulation"},{"location":"soma_clustering/#build-and-run-the-simulation","text":"Run the following commands to build and run the simulation (do not forget to biodynamo source if you haven't already in your terminal): biodynamo build biodynamo run","title":"Build and run the simulation"},{"location":"soma_clustering/#visualize-the-simulation","text":"Open ParaView and navigate to the diffusion directory. Open the cells_data_* and Kalium_* files as Group (see the Visualization exercise as a reference). Click on the cells_data_ entry in the Pipeline Browser. From \"Filters\", select \"Search\" (or do Ctrl + Space). Search for the \"Glyph\" filter, Apply it, and set the following properties: Glyph Type = Sphere Scalars = Diameters Scale Mode = Scalar Scale Factor = 1 Glyph Mode = All Points And hit Apply. You might need to 'Zoom to Fit'. Hit the Play button on the top of the interface to play the simulation over time.","title":"Visualize the simulation"},{"location":"substance_initializers/","text":"You might want to initialize the concentration of one or more of the substances in your simulation. In this tutorial we shal take a look on how to do so. Tutorial by example Go into the test/integration directory and open the source file substance_initialization.h in your favorite editor. 1. List the substance(s) We start the code of by listing the s we will use in our simulation in an enum data structure. In this example we just create one substance. enum Substances { kSubstance }; 2. Specify the space dimensions We bound our space to keep things simple. Param :: bound_space_ = true ; Param :: min_bound_ = 0 ; Param :: max_bound_ = 250 ; 3. Create a cell We create one cell with diameter 10, at a random location auto construct = []( const std :: array double , 3 position ) { Cell cell ( position ); cell . SetDiameter ( 10 ); return cell ; }; ModelInitializer :: CreateCellsRandom ( Param :: min_bound_ , Param :: max_bound_ , 1 , construct ); 4. Define the substance(s) We define the diffusion parameters of the substance(s) in our simulation. We choose a diffusion coefficient of 0.5, a decay constant 0f 0.1 and a resolution of 1. ModelInitializer :: DefineSubstance ( kSubstance , Substance , 0.5 , 0.1 , 1 ); 5. Initialize the substance(s) Now comes the most important part of the tutorial: initializing our substance(s) concentration values throught the space. We will use the function ModelInitializer::InitializeSubstance for this purpose. ModelInitializer :: InitializeSubstance ( kSubstance , Substance , GaussianBand ( 120 , 5 , Axis :: kXAxis )); Let's break this down. We first pass the substance enum id and name in the function in order to specify which substance we want to initialize. Then we simply pass the model we want to initialize the substance with (we call these \"initializers\"). In this case we choose for a GaussianBand with a mean value of 120 along the x-axis, and a variance of 5. The result (visualized with ParaView) is the following: Creating a custom substance initializer In this tutorial you have seen how to initialize a substance's concentration values with the GaussianBand initializer. Of course this is not the only model to initialize a substance with. We have several predefined initializers available in BioDynaMo, and you can create your own. Let's take a look at an existing substance initializer. Option 1: Functors struct GaussianBand { double mean_ ; double sigma_ ; uint8_t axis_ ; GaussianBand ( double mean , double sigma , uint8_t axis ) { mean_ = mean ; sigma_ = sigma ; axis_ = axis ; } double operator ()( double x , double y , double z ) { switch ( axis_ ) { case Axis :: kXAxis : return ROOT :: Math :: normal_pdf ( x , sigma_ , mean_ ); case Axis :: kYAxis : return ROOT :: Math :: normal_pdf ( y , sigma_ , mean_ ); case Axis :: kZAxis : return ROOT :: Math :: normal_pdf ( z , sigma_ , mean_ ); default : throw std :: logic_error ( You have chosen an non-existing axis! ); } } }; The above code is what is called a 'functor' in C++. Here it basically describes the model or operation that you want to perform on the entire diffusion space. In the constructor we save the mean, variance and orientation axis, so that this initializer can be used generically. The operator tells BioDynaMo what the concentration value should be for x, y, and z. BioDynaMo will make sure that your operator is executed over the whole simulation space. In this example we make use of a function that models the normal (i.e. Gaussian) probability density function. Option 2: Lambdas Functors are nice if you want to create a generic model that you can apply for several input variables (e.g. different means, sigmas in the above example). But you might want to just keep it short and simple; in which case lambdas are nice to use. We can accomplish exactly the same result as the above example with the following lambda: auto gaussian_band = [] ( double x , double y , double z ) { return ROOT : : Math :: normal_pdf ( x , 5 , 120 ); } ; Much simpler right? As you can see we have hard-coded some of the variables that we had generalized in our functor. So depending on your use case or preference, lambdas might be the way to go.","title":"Substance Initialization"},{"location":"substance_initializers/#tutorial-by-example","text":"Go into the test/integration directory and open the source file substance_initialization.h in your favorite editor.","title":"Tutorial by example"},{"location":"substance_initializers/#1-list-the-substances","text":"We start the code of by listing the s we will use in our simulation in an enum data structure. In this example we just create one substance. enum Substances { kSubstance };","title":"1. List the substance(s)"},{"location":"substance_initializers/#2-specify-the-space-dimensions","text":"We bound our space to keep things simple. Param :: bound_space_ = true ; Param :: min_bound_ = 0 ; Param :: max_bound_ = 250 ;","title":"2. Specify the space dimensions"},{"location":"substance_initializers/#3-create-a-cell","text":"We create one cell with diameter 10, at a random location auto construct = []( const std :: array double , 3 position ) { Cell cell ( position ); cell . SetDiameter ( 10 ); return cell ; }; ModelInitializer :: CreateCellsRandom ( Param :: min_bound_ , Param :: max_bound_ , 1 , construct );","title":"3. Create a cell"},{"location":"substance_initializers/#4-define-the-substances","text":"We define the diffusion parameters of the substance(s) in our simulation. We choose a diffusion coefficient of 0.5, a decay constant 0f 0.1 and a resolution of 1. ModelInitializer :: DefineSubstance ( kSubstance , Substance , 0.5 , 0.1 , 1 );","title":"4. Define the substance(s)"},{"location":"substance_initializers/#5-initialize-the-substances","text":"Now comes the most important part of the tutorial: initializing our substance(s) concentration values throught the space. We will use the function ModelInitializer::InitializeSubstance for this purpose. ModelInitializer :: InitializeSubstance ( kSubstance , Substance , GaussianBand ( 120 , 5 , Axis :: kXAxis )); Let's break this down. We first pass the substance enum id and name in the function in order to specify which substance we want to initialize. Then we simply pass the model we want to initialize the substance with (we call these \"initializers\"). In this case we choose for a GaussianBand with a mean value of 120 along the x-axis, and a variance of 5. The result (visualized with ParaView) is the following:","title":"5. Initialize the substance(s)"},{"location":"substance_initializers/#creating-a-custom-substance-initializer","text":"In this tutorial you have seen how to initialize a substance's concentration values with the GaussianBand initializer. Of course this is not the only model to initialize a substance with. We have several predefined initializers available in BioDynaMo, and you can create your own. Let's take a look at an existing substance initializer.","title":"Creating a custom substance initializer"},{"location":"substance_initializers/#option-1-functors","text":"struct GaussianBand { double mean_ ; double sigma_ ; uint8_t axis_ ; GaussianBand ( double mean , double sigma , uint8_t axis ) { mean_ = mean ; sigma_ = sigma ; axis_ = axis ; } double operator ()( double x , double y , double z ) { switch ( axis_ ) { case Axis :: kXAxis : return ROOT :: Math :: normal_pdf ( x , sigma_ , mean_ ); case Axis :: kYAxis : return ROOT :: Math :: normal_pdf ( y , sigma_ , mean_ ); case Axis :: kZAxis : return ROOT :: Math :: normal_pdf ( z , sigma_ , mean_ ); default : throw std :: logic_error ( You have chosen an non-existing axis! ); } } }; The above code is what is called a 'functor' in C++. Here it basically describes the model or operation that you want to perform on the entire diffusion space. In the constructor we save the mean, variance and orientation axis, so that this initializer can be used generically. The operator tells BioDynaMo what the concentration value should be for x, y, and z. BioDynaMo will make sure that your operator is executed over the whole simulation space. In this example we make use of a function that models the normal (i.e. Gaussian) probability density function.","title":"Option 1: Functors"},{"location":"substance_initializers/#option-2-lambdas","text":"Functors are nice if you want to create a generic model that you can apply for several input variables (e.g. different means, sigmas in the above example). But you might want to just keep it short and simple; in which case lambdas are nice to use. We can accomplish exactly the same result as the above example with the following lambda: auto gaussian_band = [] ( double x , double y , double z ) { return ROOT : : Math :: normal_pdf ( x , 5 , 120 ); } ; Much simpler right? As you can see we have hard-coded some of the variables that we had generalized in our functor. So depending on your use case or preference, lambdas might be the way to go.","title":"Option 2: Lambdas"},{"location":"visualization/","text":"Enabling visualization is very easy. BioDynaMo can be configured through its own configuration file: bdm.toml . Visualization is just one of the many configuration options. Let's take a look at how to set it. We shall continue using the hello_world example from the previous exercise. Create the configuration file In your simulation directory hello_world create a new file called bdm.toml . You can also do this from the command line with the following command: touch bdm.toml Export visualization files One way to enable visualization is to export a visualization file every time step (or every N time steps). In the bmd.toml file add the following lines: [visualization] export = true export_interval = 1 [[visualize_sim_object]] name = Cell additional_data_members = [ diameter_ ] This will export a visualization file every time step. You can set the frequency by setting the export_interval . Make sure that you run a good number of steps so that the cells have time to divide. Set it to around 2000 for the hello_world example. You can do this in src/hello_world.h in the scheduler.Simulate(time_steps) function. Run your simulation with biodynamo run . Now we need to open ParaView: Warning Make sure you start ParaView from the project directory. Otherwise, ParaView might not find the exported files. paraview Select \"File- Load State\" as shown below: Navigate to your simulation output directory and select the pvsm file. In the next window keep the default ( Use File Names From State ) and click OK.","title":"Visualization"},{"location":"visualization/#create-the-configuration-file","text":"In your simulation directory hello_world create a new file called bdm.toml . You can also do this from the command line with the following command: touch bdm.toml","title":"Create the configuration file"},{"location":"visualization/#export-visualization-files","text":"One way to enable visualization is to export a visualization file every time step (or every N time steps). In the bmd.toml file add the following lines: [visualization] export = true export_interval = 1 [[visualize_sim_object]] name = Cell additional_data_members = [ diameter_ ] This will export a visualization file every time step. You can set the frequency by setting the export_interval . Make sure that you run a good number of steps so that the cells have time to divide. Set it to around 2000 for the hello_world example. You can do this in src/hello_world.h in the scheduler.Simulate(time_steps) function. Run your simulation with biodynamo run . Now we need to open ParaView: Warning Make sure you start ParaView from the project directory. Otherwise, ParaView might not find the exported files. paraview Select \"File- Load State\" as shown below: Navigate to your simulation output directory and select the pvsm file. In the next window keep the default ( Use File Names From State ) and click OK.","title":"Export visualization files"}]}
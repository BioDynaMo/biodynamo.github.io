{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to BioDynaMo\n\n\nWhat is BioDynaMo?\n\n\nBioDynaMo is a platform through which life scientists\ncan easily create, run, and visualise three-dimensional\nbiological simulations. Built on top of the latest computing\ntechnologies, the BioDynaMo platform will enable users to\nperform simulations of previously unachievable scale and\ncomplexity, making it possible to tackle challenging scientific\nresearch questions.", 
            "title": "Welcome"
        }, 
        {
            "location": "/#welcome-to-biodynamo", 
            "text": "", 
            "title": "Welcome to BioDynaMo"
        }, 
        {
            "location": "/#what-is-biodynamo", 
            "text": "BioDynaMo is a platform through which life scientists\ncan easily create, run, and visualise three-dimensional\nbiological simulations. Built on top of the latest computing\ntechnologies, the BioDynaMo platform will enable users to\nperform simulations of previously unachievable scale and\ncomplexity, making it possible to tackle challenging scientific\nresearch questions.", 
            "title": "What is BioDynaMo?"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n\n\nTo install BioDynaMo for the first time execute the following commands.\nThe installation will also install all required packages including Paraview.\n\n\ngit clone https://github.com/BioDynaMo/biodynamo.git\n\ncd\n biodynamo\n./install.sh\n\n\n\n\n\n\nImportant\n\n\n\n\n\n\nAfter the installation you need to restart your terminal.\n  In every new terminal execute \nsource \npath-to-bdm-installation\n/biodynamo-env.sh\n\n  to use BioDynaMo!\n\n\n\n\n\n\nBioDynaMo uses a customized version of ParaView.\n     Therefore, you should not install ParaView separately.\n\n\n\n\n\n\n\n\nUpdate Installation\n\n\nThe following commands update your BioDynaMo installation:\n\n\ncd\n path/to/biodynamo\n\n# make sure you are on the master branch\n\ngit checkout master\n\n# get latest changes\n\ngit pull origin master\n./install.sh\n\n\n\n\nSupported platforms\n\n\n\n\nUbuntu 16.04\n\n\nMac OSX", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "To install BioDynaMo for the first time execute the following commands.\nThe installation will also install all required packages including Paraview.  git clone https://github.com/BioDynaMo/biodynamo.git cd  biodynamo\n./install.sh   Important    After the installation you need to restart your terminal.\n  In every new terminal execute  source  path-to-bdm-installation /biodynamo-env.sh \n  to use BioDynaMo!    BioDynaMo uses a customized version of ParaView.\n     Therefore, you should not install ParaView separately.", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#update-installation", 
            "text": "The following commands update your BioDynaMo installation:  cd  path/to/biodynamo # make sure you are on the master branch \ngit checkout master # get latest changes \ngit pull origin master\n./install.sh", 
            "title": "Update Installation"
        }, 
        {
            "location": "/installation/#supported-platforms", 
            "text": "Ubuntu 16.04  Mac OSX", 
            "title": "Supported platforms"
        }, 
        {
            "location": "/first_steps/", 
            "text": "First Steps\n\n\nSetting up a simulation and running it is done with the BioDynaMo command line\ninterface (CLI). Open a new terminal and execute:\n\n\nsource\n \npath-to-bdm-installation\n/biodynamo-env.sh\n\n\n\n\nThis command must be executed whenever you want to use BioDynaMo in a new\nterminal!\n\n\nBasic Workflow\n\n\nA basic BioDynaMo workflow looks as follows:\n\n\n1. Create a new project\n\n\nTo create a new project run the following command:\n\n\nbiodynamo new \nenter_name\n\n\n\n\n\nThis command creates a new Git repository for you with the name specified\nin the \nenter_name\n placeholder. It will ask you to login with your Github\ncredentials to make your project files remotely accessible. You will see a folder appear with the same\nname, containing some template files to get you started.\n\n\n\n\nTip\n\n\nIf you wish not to have your Github account linked to your project you can\nappend the \n--no-github\n option to the command. You will however not be able\nto use the \nbiodynamo assist\n command as explained below.\n\n\n\n\n2. Implement your model\n\n\nThe provided template files in your newly created folder can be used as a\nstarting point for your simulation. The \nsrc\n directory contains the files with\nthe source code that defines the simulation. You can edit and add the code that\ndescribes your model in this folder.\n\n\n3. Run the simulation\n\n\nBuilding the simulation and running it can be done with the command:\n\n\nbiodynamo run\n\n\n\n\nAll your source code will be compiled and linked against the BioDynaMo libraries, and an executable file\nwill be created and run. It is at this point you might encounter compilation errors.\nYou will need to fix them before the simulation can actually run.\n\n\nRequest assistance\n\n\nIt can happen that you encounter an error or issue that you cannot solve on your own.\nOr you might be convinced that there is a bug in BioDynaMo.\nFor such occasions we have provided you with BioDynaMo assistance:\n\n\nbiodynamo assist\n\n\n\n\nThis command will create a folder called \ndebug\n in which debug information will be collected.\nA git branch will be created and uploaded to Github. Send the link to this branch to us,\nso we can take a look at the issue. Check out \nContact\n on how to contact us.", 
            "title": "First Steps"
        }, 
        {
            "location": "/first_steps/#first-steps", 
            "text": "Setting up a simulation and running it is done with the BioDynaMo command line\ninterface (CLI). Open a new terminal and execute:  source   path-to-bdm-installation /biodynamo-env.sh  This command must be executed whenever you want to use BioDynaMo in a new\nterminal!", 
            "title": "First Steps"
        }, 
        {
            "location": "/first_steps/#basic-workflow", 
            "text": "A basic BioDynaMo workflow looks as follows:", 
            "title": "Basic Workflow"
        }, 
        {
            "location": "/first_steps/#1-create-a-new-project", 
            "text": "To create a new project run the following command:  biodynamo new  enter_name   This command creates a new Git repository for you with the name specified\nin the  enter_name  placeholder. It will ask you to login with your Github\ncredentials to make your project files remotely accessible. You will see a folder appear with the same\nname, containing some template files to get you started.   Tip  If you wish not to have your Github account linked to your project you can\nappend the  --no-github  option to the command. You will however not be able\nto use the  biodynamo assist  command as explained below.", 
            "title": "1. Create a new project"
        }, 
        {
            "location": "/first_steps/#2-implement-your-model", 
            "text": "The provided template files in your newly created folder can be used as a\nstarting point for your simulation. The  src  directory contains the files with\nthe source code that defines the simulation. You can edit and add the code that\ndescribes your model in this folder.", 
            "title": "2. Implement your model"
        }, 
        {
            "location": "/first_steps/#3-run-the-simulation", 
            "text": "Building the simulation and running it can be done with the command:  biodynamo run  All your source code will be compiled and linked against the BioDynaMo libraries, and an executable file\nwill be created and run. It is at this point you might encounter compilation errors.\nYou will need to fix them before the simulation can actually run.", 
            "title": "3. Run the simulation"
        }, 
        {
            "location": "/first_steps/#request-assistance", 
            "text": "It can happen that you encounter an error or issue that you cannot solve on your own.\nOr you might be convinced that there is a bug in BioDynaMo.\nFor such occasions we have provided you with BioDynaMo assistance:  biodynamo assist  This command will create a folder called  debug  in which debug information will be collected.\nA git branch will be created and uploaded to Github. Send the link to this branch to us,\nso we can take a look at the issue. Check out  Contact  on how to contact us.", 
            "title": "Request assistance"
        }, 
        {
            "location": "/hello_world/", 
            "text": "The most basic BioDynaMo simulation (i.e. our Hello World program) is a\nstatic single cell. It is the default model that comes with the installation of\nBioDynaMo. In this section we shall go over the three simple steps of running\nthis simple simulation.\n\n\nStep 1: Create your simulation\n\n\nRun the following command to create a new project called \"hello_world\":\n\n\nbiodynamo new hello_world\n\n\n\n\nLog in with your Github account when prompted. Or append \n--no-github\n if you\ndo not want this.\n\n\nStep 2: Build your simulation\n\n\nGo into the newly created directory \nhello_world\n with:\n\n\ncd\n hello_world\n\n\n\n\nAnd build the project files with:\n\n\nbiodynamo build\n\n\n\n\nStep 3: Run your simulation\n\n\nbiodynamo run\n\n\n\n\nYou should see \"Simulation completed succesfully\" as the output.\n\n\nExtra: Cell division\n\n\nLet's make the simulation more interesting by adding a biological behavior to the\ncell: cell division. Open the \nsrc/hello_world.h\n\n\nReplace the \nCompileTimeParameters\n struct with the following one:\n\n\ntemplate\n \ntypename\n \nBackend\n\n\nstruct\n \nCompileTimeParam\n \n:\n \npublic\n \nDefaultCompileTimeParam\nBackend\n \n{\n\n  \nusing\n \nBiologyModules\n \n=\n \nVariant\nGrowDivide\n;\n\n\n};\n\n\n\n\n\nAnd add the following line to the \nconstruct\n function:\n\n\ncell\n.\nAddBiologyModule\n(\nGrowDivide\n(\n32\n,\n \n3000\n,\n \n{\ngAllBmEvents\n}));\n\n\n\n\n\nRebuild and rerun the simulation to have the cell division take effect. visit the\nnext exercise to learn about the visualization features of BioDynaMo.\n\n\n\n\nInfo\n\n\nYou might want to run for a few more simulation steps to witness cells dividing", 
            "title": "Hello World"
        }, 
        {
            "location": "/hello_world/#step-1-create-your-simulation", 
            "text": "Run the following command to create a new project called \"hello_world\":  biodynamo new hello_world  Log in with your Github account when prompted. Or append  --no-github  if you\ndo not want this.", 
            "title": "Step 1: Create your simulation"
        }, 
        {
            "location": "/hello_world/#step-2-build-your-simulation", 
            "text": "Go into the newly created directory  hello_world  with:  cd  hello_world  And build the project files with:  biodynamo build", 
            "title": "Step 2: Build your simulation"
        }, 
        {
            "location": "/hello_world/#step-3-run-your-simulation", 
            "text": "biodynamo run  You should see \"Simulation completed succesfully\" as the output.", 
            "title": "Step 3: Run your simulation"
        }, 
        {
            "location": "/hello_world/#extra-cell-division", 
            "text": "Let's make the simulation more interesting by adding a biological behavior to the\ncell: cell division. Open the  src/hello_world.h  Replace the  CompileTimeParameters  struct with the following one:  template   typename   Backend  struct   CompileTimeParam   :   public   DefaultCompileTimeParam Backend   { \n   using   BiologyModules   =   Variant GrowDivide ;  };   And add the following line to the  construct  function:  cell . AddBiologyModule ( GrowDivide ( 32 ,   3000 ,   { gAllBmEvents }));   Rebuild and rerun the simulation to have the cell division take effect. visit the\nnext exercise to learn about the visualization features of BioDynaMo.   Info  You might want to run for a few more simulation steps to witness cells dividing", 
            "title": "Extra: Cell division"
        }, 
        {
            "location": "/visualization/", 
            "text": "Enabling visualization is very easy. BioDynaMo can be configured through its own\nconfiguration file: \nbdm.toml\n. Visualization is just one of the many configuration\noptions. Let's take a look at how to set it. We shall continue using the \nhello_world\n\nexample from the previous exercise.\n\n\nCreate the configuration file\n\n\nIn your simulation directory \nhello_world\n create a new file called \nbdm.toml\n.\nYou can also do this from the command line with the following command:\n\n\ntouch bdm.toml\n\n\n\n\nExport visualization files\n\n\nOne way to enable visualization is to export a visualization file every time step\n(or every N time steps). In the \nbmd.toml\n file add the following lines:\n\n\n[visualization]\n\n\nexport\n \n=\n \ntrue\n\n\nexport_interval\n \n=\n \n1\n\n\n    \n[[visualize_sim_object]]\n\n    \nname\n \n=\n \nCell\n\n\n    additional_data_members = [ \ndiameter_\n ]\n\n\n\n\n\nThis will export a visualization file every time step. You can set the frequency\nby setting the \nexport_interval\n. Make sure that you run a good number of steps\nso that the cells have time to divide. Set it to around 2000 for the \nhello_world\n example.\nYou can do this in \nsrc/hello_world.h\n in the \nscheduler.Simulate(time_steps)\n function.\nRun your simulation with \nbiodynamo run\n.\n\n\nNow we need to open ParaView:\n\n\n\n\nWarning\n\n\nMake sure you start ParaView from the project directory. Otherwise, ParaView might not find the exported files.\n\n\n\n\nOn Linux:\n\n\nbiodynamo.paraview\n\n\n\n\nOn Mac OS:\n\n\nparaview\n\n\n\n\nSelect \"File-\nLoad State\" as shown below:\n\n\n\n\nNavigate to your simulation directory and select the \npvsm\n file.\n\n\n\n\nIn the next window keep the default (\nUse File Names From State\n) and click OK.", 
            "title": "Visualization"
        }, 
        {
            "location": "/visualization/#create-the-configuration-file", 
            "text": "In your simulation directory  hello_world  create a new file called  bdm.toml .\nYou can also do this from the command line with the following command:  touch bdm.toml", 
            "title": "Create the configuration file"
        }, 
        {
            "location": "/visualization/#export-visualization-files", 
            "text": "One way to enable visualization is to export a visualization file every time step\n(or every N time steps). In the  bmd.toml  file add the following lines:  [visualization]  export   =   true  export_interval   =   1 \n\n     [[visualize_sim_object]] \n     name   =   Cell      additional_data_members = [  diameter_  ]   This will export a visualization file every time step. You can set the frequency\nby setting the  export_interval . Make sure that you run a good number of steps\nso that the cells have time to divide. Set it to around 2000 for the  hello_world  example.\nYou can do this in  src/hello_world.h  in the  scheduler.Simulate(time_steps)  function.\nRun your simulation with  biodynamo run .  Now we need to open ParaView:   Warning  Make sure you start ParaView from the project directory. Otherwise, ParaView might not find the exported files.", 
            "title": "Export visualization files"
        }, 
        {
            "location": "/visualization/#on-linux", 
            "text": "biodynamo.paraview", 
            "title": "On Linux:"
        }, 
        {
            "location": "/visualization/#on-mac-os", 
            "text": "paraview  Select \"File- Load State\" as shown below:   Navigate to your simulation directory and select the  pvsm  file.   In the next window keep the default ( Use File Names From State ) and click OK.", 
            "title": "On Mac OS:"
        }, 
        {
            "location": "/diffusion/", 
            "text": "One of BioDynaMo's built-in biological processes is extracellular diffusion.\nIt is the process of extracellular substances diffusing through space. The constants\nthat govern the diffusion process can be set by the user. Let's go through an\nexample where diffusion plays a role.\n\n\nDownload the code from Github\n\n\nIf you are still in the \nhello_world\n directory.\n\n\nOn Linux:\n\n\nbiodynamo.git clone https://github.com/BioDynaMo/simulation-templates.git\n\ncd\n simulation-templates\nbiodynamo.git checkout newcastle\n\n\n\n\nOn Mac OS:\n\n\ngit clone https://github.com/BioDynaMo/simulation-templates.git\n\ncd\n simulation-templates\ngit checkout newcastle\n\n\n\n\nInspect the code\n\n\nGo into the \ndiffusion\n directory and open the source file \nsrc/diffusion_biology_modules.h\n in your favorite editor.\nWe can note the following things from its content:\n\n\n1. List the substances\n\n\nenum\n \nSubstances\n \n{\n \nkKalium\n \n};\n\n\n\n\n\nThe extracellular substances that will be used in the simulation are listed in\nan \nenum\n data structure. In this case it is just a single substance. According to our C++\ncoding style we will prepend the substance's name with the letter \"k\".\n\n\n2. Set up the biology modules\n\n\nOpen the \nsrc/diffusion.h\n source file.\n\n\nIn order for BioDynaMo to anticipate the biology modules that you want to use in\nthe simulation, we need to declare them in our \nCompileTimeParameters\n as such:\n\n\ntemplate\n \ntypename\n \nBackend\n\n\nstruct\n \nCompileTimeParam\n \n:\n \npublic\n \nDefaultCompileTimeParam\nBackend\n \n{\n\n  \nusing\n \nBiologyModules\n \n=\n \nVariant\nChemotaxis\n,\n \nKaliumSecretion\n;\n\n\n};\n\n\n\n\n\nThe important part here is the \nChemotaxis\n and\n\nKaliumSecretion\n biology modules. These are the modules that will govern the\nbehavior of the simulation objects (i.e. cells). We import them at the top of the\nsource code with \n#include diffusion_biology_modules\n.\n\n\n3. Set up the simulation objects\n\n\nNext up is creating simulation objects:\n\n\n  \nauto\n \nconstruct\n \n=\n \n[](\nconst\n \nstd\n::\narray\ndouble\n,\n \n3\n \nposition\n)\n \n{\n\n    \nCell\n \ncell\n(\nposition\n);\n\n    \ncell\n.\nSetDiameter\n(\n30\n);\n\n    \ncell\n.\nSetMass\n(\n1.0\n);\n\n    \ncell\n.\nAddBiologyModule\n(\nChemotaxis\n());\n\n    \nstd\n::\narray\ndouble\n,\n \n3\n \nsecretion_position\n \n=\n \n{{\n50\n,\n \n50\n,\n \n50\n}};\n\n    \nif\n \n(\nposition\n \n==\n \nsecretion_position\n)\n \n{\n\n      \ncell\n.\nAddBiologyModule\n(\nKaliumSecretion\n());\n\n    \n}\n\n    \nreturn\n \ncell\n;\n\n  \n};\n\n  \nstd\n::\nvector\nstd\n::\narray\ndouble\n,\n \n3\n \npositions\n;\n\n  \npositions\n.\npush_back\n({\n0\n,\n \n0\n,\n \n0\n});\n\n  \npositions\n.\npush_back\n({\n100\n,\n \n0\n,\n \n0\n});\n\n  \npositions\n.\npush_back\n({\n0\n,\n \n100\n,\n \n0\n});\n\n  \npositions\n.\npush_back\n({\n0\n,\n \n0\n,\n \n100\n});\n\n  \npositions\n.\npush_back\n({\n0\n,\n \n100\n,\n \n100\n});\n\n  \npositions\n.\npush_back\n({\n100\n,\n \n0\n,\n \n100\n});\n\n  \npositions\n.\npush_back\n({\n100\n,\n \n100\n,\n \n0\n});\n\n  \npositions\n.\npush_back\n({\n100\n,\n \n100\n,\n \n100\n});\n\n  \n// the cell responsible for secretion\n\n  \npositions\n.\npush_back\n({\n50\n,\n \n50\n,\n \n50\n});\n\n  \nModelInitializer\n::\nCreateCells\n(\npositions\n,\n \nconstruct\n);\n\n\n\n\n\nThe \nconstruct\n lambda defines the properties of each cell that we create. These can be\nphysical properties (diameter, mass), but also biological properties and behaviors\n(chemotaxis, substance secretion)\n\n\nIn this example, each cell is assigned the \nChemotaxis\n behavior. In \ndiffusion_biology_behaviors.h\n you can\ncheck the source code of this module. Basically it makes cells move according to the gradient,\ncaused by a concentration difference of the substance. One of the cells\n(the cell at position \n{50, 50, 50}\n) will be the one secreting the substance;\nit therefore gets assigned the \nSubstanceSecretion\n behavior.\n\n\nFurthermore, we define the initial positions of the cells. In this example it is\ndone explicitly, but one could also generate a grid of cells, or a random distribution\nof cells.\n\n\nConfigure the simulation\n\n\nCreate a \nbdm.toml\n file in the \ndiffusion\n directory, and copy the following lines\ninto it:\n\n\n[visualization]\n\n\nexport\n \n=\n \ntrue\n\n\nexport_interval\n \n=\n \n10\n\n\n    \n[[visualize_sim_object]]\n\n    \nname\n \n=\n \nCell\n\n\n    additional_data_members = [ \ndiameter_\n ]\n\n\n    \n[[visualize_diffusion]]\n\n    \nname\n \n=\n \nKalium\n\n\n    gradient = true\n\n\n\n\n\nThis will enable exporting visualization files, so that we can visualize the\nsimulation after it has finished. Furthermore, we enable the output of the diameter\nof our simulation objects (by default named \"Cell\"), and the gradient data of the\nextracellular diffusion\n\n\nBuild and run the simulation\n\n\nRun the following commands to build and run the simulation.\n\n\nbiodynamo run\n\n\n\n\nVisualize the simulation\n\n\nLoad the generated ParaView state file as described in \nSection Visualization\n.\n\n\nFrom \"View\", select \"Animation Panel\". This will display some animation settings\nat the bottom of the screen. From the \"Mode\" select \"Real Time\".\nThen click the Play button at the top of the screen to run the simulation visualization.\n\n\n\n  \n\n  Your browser does not support the video tag.", 
            "title": "Diffusion"
        }, 
        {
            "location": "/diffusion/#download-the-code-from-github", 
            "text": "If you are still in the  hello_world  directory.", 
            "title": "Download the code from Github"
        }, 
        {
            "location": "/diffusion/#on-linux", 
            "text": "biodynamo.git clone https://github.com/BioDynaMo/simulation-templates.git cd  simulation-templates\nbiodynamo.git checkout newcastle", 
            "title": "On Linux:"
        }, 
        {
            "location": "/diffusion/#on-mac-os", 
            "text": "git clone https://github.com/BioDynaMo/simulation-templates.git cd  simulation-templates\ngit checkout newcastle", 
            "title": "On Mac OS:"
        }, 
        {
            "location": "/diffusion/#inspect-the-code", 
            "text": "Go into the  diffusion  directory and open the source file  src/diffusion_biology_modules.h  in your favorite editor.\nWe can note the following things from its content:", 
            "title": "Inspect the code"
        }, 
        {
            "location": "/diffusion/#1-list-the-substances", 
            "text": "enum   Substances   {   kKalium   };   The extracellular substances that will be used in the simulation are listed in\nan  enum  data structure. In this case it is just a single substance. According to our C++\ncoding style we will prepend the substance's name with the letter \"k\".", 
            "title": "1. List the substances"
        }, 
        {
            "location": "/diffusion/#2-set-up-the-biology-modules", 
            "text": "Open the  src/diffusion.h  source file.  In order for BioDynaMo to anticipate the biology modules that you want to use in\nthe simulation, we need to declare them in our  CompileTimeParameters  as such:  template   typename   Backend  struct   CompileTimeParam   :   public   DefaultCompileTimeParam Backend   { \n   using   BiologyModules   =   Variant Chemotaxis ,   KaliumSecretion ;  };   The important part here is the  Chemotaxis  and KaliumSecretion  biology modules. These are the modules that will govern the\nbehavior of the simulation objects (i.e. cells). We import them at the top of the\nsource code with  #include diffusion_biology_modules .", 
            "title": "2. Set up the biology modules"
        }, 
        {
            "location": "/diffusion/#3-set-up-the-simulation-objects", 
            "text": "Next up is creating simulation objects:     auto   construct   =   []( const   std :: array double ,   3   position )   { \n     Cell   cell ( position ); \n     cell . SetDiameter ( 30 ); \n     cell . SetMass ( 1.0 ); \n     cell . AddBiologyModule ( Chemotaxis ()); \n     std :: array double ,   3   secretion_position   =   {{ 50 ,   50 ,   50 }}; \n     if   ( position   ==   secretion_position )   { \n       cell . AddBiologyModule ( KaliumSecretion ()); \n     } \n     return   cell ; \n   }; \n   std :: vector std :: array double ,   3   positions ; \n   positions . push_back ({ 0 ,   0 ,   0 }); \n   positions . push_back ({ 100 ,   0 ,   0 }); \n   positions . push_back ({ 0 ,   100 ,   0 }); \n   positions . push_back ({ 0 ,   0 ,   100 }); \n   positions . push_back ({ 0 ,   100 ,   100 }); \n   positions . push_back ({ 100 ,   0 ,   100 }); \n   positions . push_back ({ 100 ,   100 ,   0 }); \n   positions . push_back ({ 100 ,   100 ,   100 }); \n   // the cell responsible for secretion \n   positions . push_back ({ 50 ,   50 ,   50 }); \n   ModelInitializer :: CreateCells ( positions ,   construct );   The  construct  lambda defines the properties of each cell that we create. These can be\nphysical properties (diameter, mass), but also biological properties and behaviors\n(chemotaxis, substance secretion)  In this example, each cell is assigned the  Chemotaxis  behavior. In  diffusion_biology_behaviors.h  you can\ncheck the source code of this module. Basically it makes cells move according to the gradient,\ncaused by a concentration difference of the substance. One of the cells\n(the cell at position  {50, 50, 50} ) will be the one secreting the substance;\nit therefore gets assigned the  SubstanceSecretion  behavior.  Furthermore, we define the initial positions of the cells. In this example it is\ndone explicitly, but one could also generate a grid of cells, or a random distribution\nof cells.", 
            "title": "3. Set up the simulation objects"
        }, 
        {
            "location": "/diffusion/#configure-the-simulation", 
            "text": "Create a  bdm.toml  file in the  diffusion  directory, and copy the following lines\ninto it:  [visualization]  export   =   true  export_interval   =   10 \n\n     [[visualize_sim_object]] \n     name   =   Cell      additional_data_members = [  diameter_  ] \n\n     [[visualize_diffusion]] \n     name   =   Kalium      gradient = true   This will enable exporting visualization files, so that we can visualize the\nsimulation after it has finished. Furthermore, we enable the output of the diameter\nof our simulation objects (by default named \"Cell\"), and the gradient data of the\nextracellular diffusion", 
            "title": "Configure the simulation"
        }, 
        {
            "location": "/diffusion/#build-and-run-the-simulation", 
            "text": "Run the following commands to build and run the simulation.  biodynamo run", 
            "title": "Build and run the simulation"
        }, 
        {
            "location": "/diffusion/#visualize-the-simulation", 
            "text": "Load the generated ParaView state file as described in  Section Visualization .  From \"View\", select \"Animation Panel\". This will display some animation settings\nat the bottom of the screen. From the \"Mode\" select \"Real Time\".\nThen click the Play button at the top of the screen to run the simulation visualization.  \n   \n  Your browser does not support the video tag.", 
            "title": "Visualize the simulation"
        }, 
        {
            "location": "/jean_tuto/", 
            "text": "BioDynaMo short tutorial\n\n\nWritten by Jean de Montigny  \n\n\nIntroduction\n\n\nBioDynaMo is platform for computer simulations of biological dynamics. You can learn more about BioDynaMo by accessing its official website.\n\n\nThis Tutorial in designed for user with limited knowledge of C++ language and will teach you the basics of BioDynaMo:\n* Create, build and run a new project\n* Create cells with a specific behaviour through a biological module\n* Extend an existing structure\n* visualise a simulation\n\n\nInstallation\n\n\nYou can access the installation page by clicking \nhere\n.\n\n\nStructure creation\n\n\nAs BioDynaMo is written is C++, it needs a particular structure. Fortunately, this procedure is really easy with BioDynaMo. To create a new project, you just need to run the command \nbiodynamo new tutorial\n. If you wish not to have your Github account linked to your project you can append the \n--no-github\n option to the command. This will create two files, in a src folder with the basic structure already written: tutorial.cc and tutorial.h. tutorial.cc will only contain the call to the header tutorial.h which will be the core of our work. You can run easily your code by typing the command \nbiodynamo run\n.\n\n\nCells and biology Module\n\n\nThe structure build in the previous chapter only create a single cell for now. In this chapter we will in a first time create more cells in order to building a square of 2 400 randomly distributed cells. Then in a second time, we will create a number of cancerous cells, that will grow and divide.\n\n\nCreating cells\n\n\nTo do so, we will work only on the Simulate function of the tutorial.h file. First, before the Simulate method, we will tell BioDynaMo to use the ResourceManager by adding the line\n\ntemplate\n \ntypename\n \nTResourceManager\n \n=\n \nResourceManager\n \n\n\n\n\nThis ResourceManager will be used to create cells. Inside the Simulate method, we need to define a resource manager and a structure to contain our cells:\n\nauto\n \nrm\n \n=\n \nTResourceManager\n::\nGet\n();\n\n\nauto\n \ncells\n \n=\n \nrm\n-\ntemplate\n \nGet\nCell\n();\n\n\n\n\nBecause we want 2400 cells randomly distributed, it is mandatory to have an random number generator to generate x, y and z coordinate of each cell. For that, we will declare three double (x_coord, y_coord and z_coord) and use the gTRandom.Uniform random engine\n\n  \nsize_t\n \nnb_of_cells\n=\n2400\n;\n \n// number of cells in the simulation\n\n  \nint\n \ncube_dim\n \n=\n \n100\n;\n \n// cube of 100*100*100\n\n  \ndouble\n \nx_coord\n,\n \ny_coord\n,\n \nz_coord\n;\n\n  \ncells\n-\nreserve\n(\nnb_of_cells\n);\n \n// allocate the correct number of cell in our cells structure before cell creation\n\n\n\n\nThen, with a simple loop from 0 to the number of cells, we will be able to fill this cells structure with cell elements.\n\n  \nfor\n \n(\nsize_t\n \ni\n \n=\n \n0\n;\n \ni\n \n \nnb_of_cells\n;\n \n++\ni\n)\n \n{\n\n    \n// our modelling will be a cell cube of 100*100*100\n\n    \nx_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n    \ny_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n    \nz_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n    \nCell\n \ncell\n({\nx_coord\n,\n \ny_coord\n,\n \nz_coord\n});\n \n// creating the cell at position x, y, z\n\n    \n// set cell parameters\n\n    \ncell\n.\nSetDiameter\n(\n7.5\n);\n\n\n    \ncells\n-\npush_back\n(\ncell\n);\n \n// put the created cell in our cells structure\n\n  \n}\n\n\n\n\nWe now have our structure containing all the 2400 cells! The code in charge of running our modelling is already written and will simulate it for only one step. Lets change this to simulate for 100 steps.\n\nScheduler\n \nscheduler\n;\n\n\nscheduler\n.\nSimulate\n(\n100\n);\n\n\n\n\nBiology module\n\n\nIn the previous chapter, we created a great number of cells. However, those cells don\u2019t do anything! We will here create a cancerous cell that will grows and divides when it reaches a certain diameter. For this, we will define a new biology module structure GrowthModule that will be applied to cell elements, and we will make this GrowthModule copied into the cell daughter (so the daughter will also contain an instance of the biology module GrowthModule)\n\n  \nstruct\n \nGrowthModule\n \n:\n \npublic\n \nBaseBiologyModule\n \n{\n\n  \nGrowthModule\n()\n \n:\n \nBaseBiologyModule\n(\ngAllBmEvents\n)\n \n{}\n\n\n    \ntemplate\n \ntypename\n \nT\n\n      \nvoid\n \nRun\n(\nT\n*\n \ncell\n)\n \n{\n\n        \n// code to be executed\n\n      \n}\n\n\n    \nClassDefNV\n(\nGrowthModule\n,\n \n1\n);\n\n  \n};\n\n\n\n\nWe are now able to add any code in the Run() method, that will be executed at each simulation step for each cell containing this GrowthModule In our case, it will be a cellular growth, until a certain diameter is reached and then a cell division\n\n      \nif\n \n(\ncell\n-\nGetDiameter\n()\n \n \n8\n)\n \n{\n\n        \ncell\n-\nChangeVolume\n(\n400\n);\n\n      \n}\n\n      \nelse\n \n{\n\n        \nDivide\n(\n*\ncell\n);\n\n      \n}\n\n\n\n\nAfter creating our GrowthModule, we need to add this Biology module to the compile time parameter, to tell BioDynaMo to use this new BiologyModule\n\n  \ntemplate\n \ntypename\n \nBackend\n\n    \nstruct\n \nCompileTimeParam\n \n:\n \npublic\n \nDefaultCompileTimeParam\nBackend\n \n{\n\n      \nusing\n \nBiologyModules\n \n=\n \nVariant\nGrowthModule\n;\n \n// add GrowthModule\n\n  \n};\n\n\n\n\nOf course, we need to create at least one cell that contain our GrowthModule in our Simulate method\n\n  \nCell\n \ncell\n \n({\n20\n,\n \n50\n,\n \n50\n});\n\n  \ncell\n.\nSetDiameter\n(\n6\n);\n\n  \ncell\n.\nAddBiologyModule\n(\nGrowthModule\n());\n\n  \ncells\n-\npush_back\n(\ncell\n);\n\n\n\n\nThis code is now able to create and simulate 2 400 normal cells and 1 cancerous cell that will grow and divide! Complete codes for tutorial.cc and tutorial.h of this chapter are accessible at the end of this tutorial.\n\n\nVisualisation using Paraview\n\n\nIn the previous chapter we created a simulation of a great number of cell, also containing dividing cancerous cells, but we were not able to visualize anything! In this chapter, we will set up a visualisation using Paraview (included in the BioDynaMo package).\n\n\nParaview\n\n\nParaview\n is an open source application for interactive and scientific visualisation. First of all, we need to tell BioDynaMo that we will use Paraview and so that we want the visualisation to be enable. To do that, we need to create a configuration file \nbdm.toml\n in the tutorial folder. Visualisation is of course not the only configuration we can do using this file. You can allow live visualisation and/or export visualisation (here every 2 simulation step) by adding in bdm.toml\n\n[\n \nvisualization\n \n]\n\n\nlive\n \n=\n \ntrue\n\n\nexport\n \n=\n \nfalse\n\n\nexport_interval\n \n=\n \n2\n\n\n\n\nyou also can say to Paraview to visualize a particular parameter of ours cells, for example the diameter of every cells. Do do that, add below [visualization] in the configuration file the following lines\n\n    \n[[\n \nv\n \ni\n \ns\n \nualize_sim_object\n \n]]\n\n    \nname\n \n=\n \nCell\n\n    \nadditional_data_members\n \n=\n \n[\n \ndiameter_\n \n]\n\n\n\nBecause those visualization parameters are not in the source code, you don\u2019t need to compile your code again.\nWe can note that instead of creating a configuration file, you can do the same by adding directly in our Simulate function the lines\n\n    \nParam\n::\nlive_visualization_\n \n=\n \ntrue\n;\n \n// allows live visualization\n\n    \nParam\n::\nexport_visualization_\n \n=\n \ntrue\n;\n \n// allows export of visualization files\n\n    \nParam\n::\nvisualization_export_interval_\n \n=\n \n2\n;\n \n// export visualization files every 2 steps\n\n    \nParam\n::\nvisualize_sim_objects_\n[\nCell\n]\n \n=\n \nstd\n::\nset\nstd\n::\nstring\n{\n \ndiameter_\n \n};\n \n// add the data member diameter_ to the visualization objects\n\n\n\nOnce again, it is important to note that if you want to change any visualization parameter using this second method, you will have to compile again your code. That is not the case using a configuration file.  \n\n\nWe will first see live visualization then the export visualization. In both cases, simply run Paraview using the console line command \nparaview \n. This windows should appears\n\n\n\n\nLive visualisation\n\n\nClick on the \nCatalyst\n top menu, and select \nConnect\n This windows should appears\n\n\n\n\nClick OK, then this windows should appears\n\n\n\n\nYour Paraview is now accepting connections! Click OK, and go back to the \nCatalyst\n menu, and select \nPause Simulation\n. Using the same console, launch your tutorial simulation. You now notice that the programme stop right before running the simulation, because we used the Paraview \nPause Simulation\n.\n\n\n\n\nGo back to Paraview. You notice that new objects have appeared in the \nPipeline Browser\n section. Click on the round shape in front of \nCells Glyph\n.\n\n\n\n\nA new Builtin object have appeared: \nExtract: Cells Glyph\n. Click on the eye in front of it.\n\n\n\n\nAll cells appear on the screen!\nYou can now go to the \nCatalyst\n menu, and select \nContinue\n. The simulation will run the number of steps you specified in your code.\n\n\n\n\nEven if live visualization is particularly useful to set or tune a simulation, it is capital to note that it also drastically slows down the simulation! One way to avoid this major problem is to export visualization files and read then after the modelling is done.\n\n\nExport Visualisation\n\n\nIn the configuration file, turn the export parameter to true then run your modelling. You\u2019ll notice the creation of several new files with the following file extensions \n*.pvsm, *.pvtu, *.vtu, *pvti, *.vti\n. Open ParaView and load the generated state file as described in \nSection Visualization\n.\n\n\nA major advantage of export visualization, in addition of not impacting the simulation time, is that you can visualize your modelling freely in time. using the arrows in the top menu, you can choose respectively to go back to the beginning of the simulation, go one step back, run normally, go one step further or go to the end of the simulation. You also can see witch step you are currently visualising (remember that this step number is the number of your modelling step divided by the export_interval you choose in your configuration file).\n\n\n\n\nIn both cases, even if we can now visualize our cell, they have all the same color, which can be a bit confusing and doesn't allow us to visualise properly what is going on.\n\n\nAdding layers colour\n\n\nIn this chapter, we will modify our code in order to create a better colouring for our simulation.\n\nA good idea would be to create a colouring depending on the y axis coordinate. By this way, we could display several layers of cell, and have an other colour for our cancerous cells.\nTo do that, we can extend the existing \nCell\n class in order to add a new data member \ncell_colour\n.\nWe will do that directly in our tutorial.h file by writing\n\n  \n// Define my custom cell MyCell, which extends Cell by adding extra data members: cell_colour\n\n  \nBDM_SIM_OBJECT\n(\nMyCell\n,\n \nbdm\n::\nCell\n)\n \n{\n \n// our object extends the Cell object\n\n    \nBDM_SIM_OBJECT_HEADER\n(\nMyCellExt\n,\n \n1\n,\n \ncell_colour_\n);\n \n// create the header with our new data member\n\n\n    \npublic\n:\n\n      \nMyCellExt\n()\n \n{}\n\n      \nMyCellExt\n(\nconst\n \nstd\n::\narray\ndouble\n,\n \n3\n \nposition\n)\n \n:\n \nBase\n(\nposition\n)\n \n{}\n \n// our creator\n\n      \n// getter and setter for our new data member\n\n      \nvoid\n \nSetCelColour\n(\nint\n \ncellColour\n)\n \n{\n \ncell_colour_\n[\nkIdx\n]\n \n=\n \ncellColour\n;\n \n}\n\n      \nint\n \nGetCellColour\n()\n \n{\n \nreturn\n \ncell_colour_\n[\nkIdx\n];\n \n}\n\n      \nint\n*\n \nGetCellColourPtr\n()\n \n{\n \nreturn\n \ncell_colour_\n.\ndata\n();\n \n}\n\n\n    \nprivate\n:\n\n    \n// private data can only be accessed by public function and not directly\n\n      \nvec\nint\n \ncell_colour_\n;\n \n// declare our new data member and define its type\n\n  \n};\n\n\n\n\nDon't forget to add this new object to your compile time parameters (inside \"struct CompileTimeParam\") so BioDynaMo know that we want to use our custom \nMyCell\n object. This is done by adding the line\n\n    \nusing\n \nAtomicTypes\n \n=\n \nVariadicTypedef\nMyCell\n;\n\n\n\n\nEach cell (implementing our new object \nMyCell\n) of the modelling is now able to have a value cell_colour_ that we will choose and use to display different colours!\n\nIn order to create cells with this attribute, we need to replace all Cell object by MyCell during cells creation (inside the \nSimulate()\n method). for example\n\n//  auto cells = rm-\ntemplate Get\nCell\n(); // previous structure containing Cell objects\n\n  \nauto\n \ncells\n \n=\n \nrm\n-\ntemplate\n \nGet\nMyCell\n();\n \n// new structure containing MyCell objects\n\n\n[...]\n\n\n//     Cell cell({x_coord, y_coord, z_coord}); // creats a cell as a Cell object; so doesn\nt contain cell_colour_\n\n    \nMyCell\n \ncell\n({\nx_coord\n,\n \ny_coord\n,\n \nz_coord\n});\n \n// creats a cell as a MyCell object; so contains cell_colour_\n\n\n\n\nNow that we are creating cells implementing MyCell, we can set the cancerous cell cell_colour_ value to 8 (so it will have a really distinct colour from non cancerous cells). To do so, simply use the method SetCellColour() we created\n\n    \ncell\n.\nSetCellColour\n(\n8\n);\n\n\n\n\nDo the same for the regular cells, setting the value depending on the y axis value. One possibility is to write\n\n    \ncell\n.\nSetCellColour\n((\nint\n)\n \ny_coord\n/\ncube_dim\n*\n6\n);\n \n// will vary from 0 to 5. so 6 different layers depending on y_coord\n\n\n\n\nThis new simulation is now functional, however before running it, we need to tell BioDynamo to communicates all cell_colour_ values. Do do that, we will modify the configuration file bdm.toml by modifying the visualize_sim_object\n\n    \n[[\nvisualize_sim_object\n]]\n\n        \nname\n \n=\n \nMyCell\n\n        \nadditional_data_members\n \n=\n \n[\n \ndiameter_\n \n,\n \ncell_colour_\n \n]\n\n\n\n\nWith those changes, we are now able to colourise our different layers. All you have to do, after displaying cells and creating the \nGlyph\n filter (chapter 3.1) is to select your \nGlyph\n filter and to select cell_colour_ in the \nColoring\n section.\n\n\n\n\nWell done, we can now visualise the different layers and the cancerous cell in red!\n\n\n\n\nHowever, there still is a little problem. The attribute cell_colour_ is not transmitted to the daughter cell after a division. You can also notice that it is not really easy to see the cancerous cells. We will solve those issues in the next chapter.\n\n\nTransmitting its color and playing with Filters\n\n\nTo enable dividing cells to transmit its color - meaning its cell_color_ attribute value - we have to modify a little our biology module.\n\n//        Divide(*cell); // old\n\n        \nauto\n \ndaughter\n \n=\n \nDivide\n(\n*\ncell\n);\n \n// we now have access to the daughter\n\n        \ndaughter\n.\nSetCellColour\n(\ncell\n-\nGetCellColour\n());\n \n// daughter cell_colour_ is setted to her mother cell_colour_ value\n\n\n\n\nEven if our cancerous cells transmit their colour to their daughter, it still is not really easy to spot them in the middle of thousands of other cells. This problem can be solve using the threshold filter function of Paraview. To do that, after displaying cells colour as at the end of 3.2, click on the threshold filter button. This filter will be applied to the currently selected \nPipeline Browser\n, so pay attention to select the correct one (\nGlyph1\n) before creating the threshold filter.\n\n\n\n\nOn the \nProperties\n menu, select the \nScalar\n \ncell_colour_\n, put the minimum value at 7 and the maximum at 8 (so only the value of cancerous cell is selected) then click \nApply\n\n\n\n\nFinaly, choose the \nColoring\n mode \ncell_colour_\n.\n\n\n\n\nGreat, we can now choose to display either all the cells, or just the cancerous cells by selecting either the \nGlyph1\n or the \nThreshold1\n in the \nPipeline Browser\n!\n\n\n\n\nThis is of course just an example of what you can do with the threshold filters.\n\n\nAdding some complexity\n\n\nWe now have all we want to visualise our modelling in the best conditions, but this modelling itself is a bit limited. We should add some movements to it as well as a new mechanism to complexify cells division.\nTo add cell movement, we will modify the \nRun()\n method of our biology module \nGrowthModule\n, and use the function \nUpdateMassLocation()\n. To generate the direction's random numbers we will again use the \ngTRandom.Uniform()\n function which allow us to generate a random number between two specified numbers.\n\nWe choose here to give stochastic movement only to growing cells, so we will write the movement just after the volume change\n\n    \narray\ndouble\n,\n \n3\n \ncell_movements\n{\ngTRandom\n.\nUniform\n(\n-\n2\n,\n \n2\n),\n \ngTRandom\n.\nUniform\n(\n-\n2\n,\n \n2\n),\n \ngTRandom\n.\nUniform\n(\n-\n2\n,\n \n2\n)};\n \n// create an array of 3 ramdom numbers between -2 and 2\n\n    \ncell\n-\nUpdateMassLocation\n(\ncell_movements\n);\n \n// update the cell mass location, ie move the cell\n\n    \ncell\n-\nSetPosition\n(\ncell\n-\nGetMassLocation\n());\n \n// set the cell position\n\n    \ncell\n-\nSetTractorForce\n({\n0\n,\n \n0\n,\n \n0\n});\n \n// avoid unwanted movements after our cell displacement\n\n\n\n\nUsing the previous chapters, you should now be able to visualise cell movement during their growth.\n\nThis is great, but every cancerous cell grows and divides indefinitely, and that is a bit too much. We will now add a mechanism to reduce the probability to divide, and assuring that a cancerous cell that didn't divide, will never divide any more.\n\nTo add a probability to divide of 0.8, simply write\n\n    \nif\n \n(\ngTRandom\n.\nUniform\n(\n0\n,\n \n1\n)\n \n \n0.8\n){\n\n      \nauto\n \ndaughter\n \n=\n \nDivide\n(\n*\ncell\n);\n\n      \ndaughter\n.\nSetCellColour\n(\ncell\n-\nGetCellColour\n());\n\n    \n}\n\n\n\n\nCells will now have only 60% chance to divide. However, it will have 60% chance to divide at every time step! We want that if a cell doesn't divide, it will not be able to divide any more.\nTo do that, we will create a new MyCell boolean attribute called can_divide_. As well as for the cell_colour_ attribute (see chapter 3.2), add it our MyCell object header\n\nBDM_SIM_OBJECT_HEADER\n(\nMyCellExt\n,\n \n1\n,\n \ncan_divide_\n,\n \ncell_colour_\n);\n\n\n\n\nand create three methods, \nSetCanDivide()\n, \nGetCanDivide()\n and \nGetCanDividePtr()\n.\n\n    \nvoid\n \nSetCanDivide\n(\nbool\n \nd\n)\n \n{\n \ncan_divide_\n[\nkIdx\n]\n \n=\n \nd\n;\n \n}\n\n    \nbool\n \nGetCanDivide\n()\n \n{\n \nreturn\n \ncan_divide_\n[\nkIdx\n];\n \n}\n\n    \nbool\n*\n \nGetCanDividePtr\n()\n \n{\n \nreturn\n \ncan_divide_\n.\ndata\n();\n \n}\n\n\n\n\nThen, as for cell_colour_, declare this data member as private\n\n    \nvec\nbool\n \ncan_divide_\n;\n\n\n\n\nNow that we got a new attribute can_divide_, we need to change the \nRun()\n method to prevent cells that failed the 60% test to divide again.\nFinaly, don't forget to set the daughter can_divide_ value to true after a cell division.\n\n        \nif\n \n(\ngTRandom\n.\nUniform\n(\n0\n,\n \n1\n)\n \n0.8\n \n \ncell\n-\nGetCanDivide\n()\n==\ntrue\n){\n\n          \nauto\n \ndaughter\n \n=\n \nDivide\n(\n*\ncell\n);\n\n          \ndaughter\n.\nSetCellColour\n(\ncell\n-\nGetCellColour\n());\n \n// daughter take the cell_colour_ value of her mother\n\n          \ndaughter\n.\nSetCanDivide\n(\ntrue\n);\n \n// the daughter will be able to divide\n\n        \n}\n\n        \nelse\n \n{\n\n          \ncell\n-\nSetCanDivide\n(\nfalse\n);\n \n// this cell won\nt divide anymore\n\n        \n}\n\n\n\n\nThe tutorial.h code corresponding to this chapter is accessible at the end of this tutorial.\n\n\nYou now have all the BioDynaMo cell basic knowledge to construct your own modelling!\n\n\nDiffusion\n\n\nComing soon.\n\n\nCode\n\n\ntutorial.cc\n\n\n#include\n \ntutorial.h\n\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nconst\n \nchar\n**\n \nargv\n)\n \n{\n \nreturn\n \nbdm\n::\nSimulate\n(\nargc\n,\n \nargv\n);\n \n}\n\n\n\n\n\ntutorial.h - chapter 2.2\n\n\n#ifndef TUTORIAL_H_\n\n\n#define TUTORIAL_H_\n\n\n\n#include\n \nbiodynamo.h\n\n\n//using namespace std;\n\n\n\nnamespace\n \nbdm\n \n{\n\n\n\n// 1. Define growth behaviour\n\n  \nstruct\n \nGrowthModule\n \n:\n \npublic\n \nBaseBiologyModule\n \n{\n\n  \nGrowthModule\n()\n \n:\n \nBaseBiologyModule\n(\ngAllBmEvents\n)\n \n{}\n\n\n    \ntemplate\n \ntypename\n \nT\n\n      \nvoid\n \nRun\n(\nT\n*\n \ncell\n)\n \n{\n\n\n      \nif\n \n(\ncell\n-\nGetDiameter\n()\n \n \n8\n)\n \n{\n\n        \ncell\n-\nChangeVolume\n(\n400\n);\n\n      \n}\n\n      \nelse\n{\n\n        \nDivide\n(\n*\ncell\n);\n\n      \n}\n\n    \n}\n\n\n    \nClassDefNV\n(\nGrowthModule\n,\n \n1\n);\n\n  \n};\n\n\n\n// Define compile time parameter\n\n  \ntemplate\n \ntypename\n \nBackend\n\n    \nstruct\n \nCompileTimeParam\n \n:\n \npublic\n \nDefaultCompileTimeParam\nBackend\n \n{\n\n  \nusing\n \nBiologyModules\n \n=\n \nVariant\nGrowthModule\n;\n\n  \n};\n\n\n\n\ntemplate\n \ntypename\n \nTResourceManager\n \n=\n \nResourceManager\n\n\ninline\n \nint\n \nSimulate\n(\nint\n \nargc\n,\n \nconst\n \nchar\n**\n \nargv\n)\n \n{\n\n  \nInitializeBiodynamo\n(\nargc\n,\n \nargv\n);\n\n\n  \nsize_t\n \nnb_of_cells\n=\n2400\n;\n \n// number of cells in the simulation\n\n  \nint\n \ncube_dim\n \n=\n \n100\n;\n \n// cube of 100*100*100\n\n  \ndouble\n \nx_coord\n,\n \ny_coord\n,\n \nz_coord\n;\n\n\n  \nauto\n \nrm\n \n=\n \nTResourceManager\n::\nGet\n();\n \n// set up resource manager\n\n  \nauto\n \ncells\n \n=\n \nrm\n-\ntemplate\n \nGet\nCell\n();\n \n// create a structure to contain cells\n\n  \ncells\n-\nreserve\n(\nnb_of_cells\n);\n \n// allocate the correct number of cell in our cells structure before cell creation\n\n\n  \nfor\n \n(\nsize_t\n \ni\n \n=\n \n0\n;\n \ni\n \n \nnb_of_cells\n;\n \n++\ni\n)\n \n{\n\n    \n// our modelling will be a cell cube of 100*100*100\n\n    \nx_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n    \ny_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n    \nz_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n\n    \nCell\n \ncell\n({\nx_coord\n,\n \ny_coord\n,\n \nz_coord\n});\n \n// creating the cell at position x, y, z\n\n    \n// set cell parameters\n\n    \ncell\n.\nSetDiameter\n(\n7.5\n);\n\n\n    \ncells\n-\npush_back\n(\ncell\n);\n \n// put the created cell in our cells structure\n\n  \n}\n\n\n  \n// create a cancerous cell, containing the BiologyModule GrowthModule\n\n  \nCell\n \ncell\n({\n20\n,\n \n50\n,\n \n50\n});\n\n  \ncell\n.\nSetDiameter\n(\n6\n);\n\n  \ncell\n.\nAddBiologyModule\n(\nGrowthModule\n());\n\n  \ncells\n-\npush_back\n(\ncell\n);\n \n// put the created cell in our cells structure\n\n\n  \ncells\n-\nCommit\n();\n \n// commit cells\n\n\n  \n// Run simulation\n\n  \nScheduler\n \nscheduler\n;\n\n  \nscheduler\n.\nSimulate\n(\n1000\n);\n\n\n  \nstd\n::\ncout\n \n \nSimulation completed successfully!\n \n \nstd\n::\nendl\n;\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n}\n \n// namespace bdm\n\n\n\n#endif \n// TUTORIAL_H_\n\n\n\n\n\ntutorial.h - chapter 3.4\n\n\n#ifndef TUTORIAL_H_\n\n\n#define TUTORIAL_H_\n\n\n\n#include\n \nbiodynamo.h\n\n\n#include\n \nrandom.h\n\n\n//using namespace std;\n\n\n\nnamespace\n \nbdm\n \n{\n\n\n  \n// 0. Define my custom cell MyCell, which extends Cell by adding extra data members: cell_color and can_divide\n\n  \nBDM_SIM_OBJECT\n(\nMyCell\n,\n \nbdm\n::\nCell\n)\n \n{\n \n// our object extends the Cell object\n\n    \nBDM_SIM_OBJECT_HEADER\n(\nMyCellExt\n,\n \n1\n,\n \ncan_divide_\n,\n \ncell_colour_\n);\n \n// create the header with our new data member\n\n\n    \npublic\n:\n\n      \nMyCellExt\n()\n \n{}\n\n      \nMyCellExt\n(\nconst\n \nstd\n::\narray\ndouble\n,\n \n3\n \nposition\n)\n \n:\n \nBase\n(\nposition\n)\n \n{}\n \n// our creator\n\n\n      \n// getter and setter for our new data member\n\n      \nvoid\n \nSetCanDivide\n(\nbool\n \nd\n)\n \n{\n \ncan_divide_\n[\nkIdx\n]\n \n=\n \nd\n;\n \n}\n\n      \nbool\n \nGetCanDivide\n()\n \n{\n \nreturn\n \ncan_divide_\n[\nkIdx\n];\n \n}\n\n      \nbool\n*\n \nGetCanDividePtr\n()\n \n{\n \nreturn\n \ncan_divide_\n.\ndata\n();\n \n}\n\n\n      \nvoid\n \nSetCellColour\n(\nint\n \ncellColour\n)\n \n{\n \ncell_colour_\n[\nkIdx\n]\n \n=\n \ncellColour\n;\n \n}\n\n      \nint\n \nGetCellColour\n()\n \n{\n \nreturn\n \ncell_colour_\n[\nkIdx\n];\n \n}\n\n      \nint\n*\n \nGetCellColourPtr\n()\n \n{\n \nreturn\n \ncell_colour_\n.\ndata\n();\n \n}\n\n\n    \nprivate\n:\n\n      \n// declare new data member and define their type\n\n      \n// private data can only be accessed by public function and not directly\n\n      \nvec\nbool\n \ncan_divide_\n;\n\n      \nvec\nint\n \ncell_colour_\n;\n\n  \n};\n\n\n\n// 1. Define growth behaviour\n\n  \nstruct\n \nGrowthModule\n \n:\n \npublic\n \nBaseBiologyModule\n \n{\n\n  \nGrowthModule\n()\n \n:\n \nBaseBiologyModule\n(\ngAllBmEvents\n)\n \n{}\n\n\n    \ntemplate\n \ntypename\n \nT\n\n      \nvoid\n \nRun\n(\nT\n*\n \ncell\n)\n \n{\n\n\n      \nif\n \n(\ncell\n-\nGetDiameter\n()\n \n \n8\n)\n \n{\n\n        \ncell\n-\nChangeVolume\n(\n400\n);\n\n\n        \narray\ndouble\n,\n \n3\n \ncell_movements\n{\ngTRandom\n.\nUniform\n(\n-\n2\n,\n \n2\n),\n \ngTRandom\n.\nUniform\n(\n-\n2\n,\n \n2\n),\n \ngTRandom\n.\nUniform\n(\n-\n2\n,\n \n2\n)};\n \n// create an array of 3 ramdom numbers between -2 and 2\n\n        \ncell\n-\nUpdateMassLocation\n(\ncell_movements\n);\n \n// update the cell mass location, ie move the cell\n\n        \ncell\n-\nSetPosition\n(\ncell\n-\nGetMassLocation\n());\n \n// set the cell position\n\n        \n//Reset biological movement to 0.\n\n        \ncell\n-\nSetTractorForce\n({\n0\n,\n \n0\n,\n \n0\n});\n \n// avoid unwanted movements after our cell displacement\n\n      \n}\n\n\n      \nelse\n \n{\n \n// if diameter \n 8\n\n        \nif\n \n(\ngTRandom\n.\nUniform\n(\n0\n,\n \n1\n)\n \n0.8\n \n \ncell\n-\nGetCanDivide\n()){\n\n          \nauto\n \ndaughter\n \n=\n \nDivide\n(\n*\ncell\n);\n\n          \ndaughter\n.\nSetCellColour\n(\ncell\n-\nGetCellColour\n());\n \n// daughter take the cell_colour_ value of her mother\n\n          \ndaughter\n.\nSetCanDivide\n(\ntrue\n);\n \n// the daughter will be able to divide\n\n        \n}\n\n        \nelse\n \n{\n\n          \ncell\n-\nSetCanDivide\n(\nfalse\n);\n \n// this cell won\nt divide anymore\n\n        \n}\n\n      \n}\n\n    \n}\n\n\n    \nClassDefNV\n(\nGrowthModule\n,\n \n1\n);\n\n  \n};\n\n\n\n// Define compile time parameter\n\n  \ntemplate\n \ntypename\n \nBackend\n\n    \nstruct\n \nCompileTimeParam\n \n:\n \npublic\n \nDefaultCompileTimeParam\nBackend\n \n{\n\n  \nusing\n \nBiologyModules\n \n=\n \nVariant\nGrowthModule\n;\n\n  \nusing\n \nAtomicTypes\n \n=\n \nVariadicTypedef\nMyCell\n;\n \n// use MyCell object\n\n  \n};\n\n\n\n\ntemplate\n \ntypename\n \nTResourceManager\n \n=\n \nResourceManager\n\n\n\ninline\n \nint\n \nSimulate\n(\nint\n \nargc\n,\n \nconst\n \nchar\n**\n \nargv\n)\n \n{\n\n  \nInitializeBiodynamo\n(\nargc\n,\n \nargv\n);\n\n\n  \nsize_t\n \nnb_of_cells\n=\n2400\n;\n \n// number of cells in the simulation\n\n  \nint\n \ncube_dim\n \n=\n \n100\n;\n \n// cube of 100*100*100\n\n  \ndouble\n \nx_coord\n,\n \ny_coord\n,\n \nz_coord\n;\n\n\n  \nauto\n \nrm\n \n=\n \nTResourceManager\n::\nGet\n();\n \n// set up resource manager\n\n  \nauto\n \ncells\n \n=\n \nrm\n-\ntemplate\n \nGet\nMyCell\n();\n \n// create a structure to contain cells\n\n  \ncells\n-\nreserve\n(\nnb_of_cells\n);\n \n// allocate the correct number of cell in our cells structure before cell creation\n\n\n  \nfor\n \n(\nsize_t\n \ni\n \n=\n \n0\n;\n \ni\n \n \nnb_of_cells\n;\n \n++\ni\n)\n \n{\n\n    \n// our modelling will be a cell cube of 100*100*100\n\n    \nx_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n    \ny_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n    \nz_coord\n=\ngTRandom\n.\nUniform\n(\n0\n,\n \ncube_dim\n);\n\n\n    \nMyCell\n \ncell\n({\nx_coord\n,\n \ny_coord\n,\n \nz_coord\n});\n \n// creating the cell at position x, y, z\n\n    \n// set cell parameters\n\n    \ncell\n.\nSetDiameter\n(\n7.5\n);\n\n    \ncell\n.\nSetCellColour\n((\nint\n)\n \n(\ny_coord\n/\ncube_dim\n*\n6\n));\n \n// will vary from 0 to 5. so 6 different layers depending on y_coord\n\n\n    \ncells\n-\npush_back\n(\ncell\n);\n \n// put the created cell in our cells structure\n\n  \n}\n\n\n  \n// create a cancerous cell, containing the BiologyModule GrowthModule\n\n  \nMyCell\n \ncell\n({\n20\n,\n \n50\n,\n \n50\n});\n\n  \ncell\n.\nSetDiameter\n(\n6\n);\n\n  \ncell\n.\nSetCellColour\n(\n8\n);\n\n  \ncell\n.\nSetCanDivide\n(\ntrue\n);\n\n  \ncell\n.\nAddBiologyModule\n(\nGrowthModule\n());\n\n  \ncells\n-\npush_back\n(\ncell\n);\n \n// put the created cell in our cells structure\n\n\n  \ncells\n-\nCommit\n();\n \n// commit cells\n\n\n\n//  Param::live_visualization_ = true; // allows live visualization\n\n\n//  Param::export_visualization_ = true; // allows export of visualization files\n\n\n//  Param::visualization_export_interval_ = 10; // export visualization files every 10 steps\n\n\n//  Param::visualize_sim_objects_[\nMyCell\n] = std::set\nstd::string\n{\ndiameter_\n}; // add the data member diameter_ to the visualization objects\n\n\n  \n// Run simulation\n\n  \nScheduler\n \nscheduler\n;\n\n  \nfor\n \n(\nint\n \ni\n=\n0\n;\n \ni\n100\n;\n \ni\n++\n){\n\n    \nscheduler\n.\nSimulate\n(\n1\n);\n\n  \n}\n\n\n  \nstd\n::\ncout\n \n \nSimulation completed successfully!\n \n \nstd\n::\nendl\n;\n\n  \nreturn\n \n0\n;\n\n\n}\n\n\n\n}\n \n// namespace bdm\n\n\n\n#endif \n// TUTORIAL_H_", 
            "title": "Tumor Concept"
        }, 
        {
            "location": "/jean_tuto/#biodynamo-short-tutorial", 
            "text": "Written by Jean de Montigny", 
            "title": "BioDynaMo short tutorial"
        }, 
        {
            "location": "/jean_tuto/#introduction", 
            "text": "BioDynaMo is platform for computer simulations of biological dynamics. You can learn more about BioDynaMo by accessing its official website.  This Tutorial in designed for user with limited knowledge of C++ language and will teach you the basics of BioDynaMo:\n* Create, build and run a new project\n* Create cells with a specific behaviour through a biological module\n* Extend an existing structure\n* visualise a simulation", 
            "title": "Introduction"
        }, 
        {
            "location": "/jean_tuto/#installation", 
            "text": "You can access the installation page by clicking  here .", 
            "title": "Installation"
        }, 
        {
            "location": "/jean_tuto/#structure-creation", 
            "text": "As BioDynaMo is written is C++, it needs a particular structure. Fortunately, this procedure is really easy with BioDynaMo. To create a new project, you just need to run the command  biodynamo new tutorial . If you wish not to have your Github account linked to your project you can append the  --no-github  option to the command. This will create two files, in a src folder with the basic structure already written: tutorial.cc and tutorial.h. tutorial.cc will only contain the call to the header tutorial.h which will be the core of our work. You can run easily your code by typing the command  biodynamo run .", 
            "title": "Structure creation"
        }, 
        {
            "location": "/jean_tuto/#cells-and-biology-module", 
            "text": "The structure build in the previous chapter only create a single cell for now. In this chapter we will in a first time create more cells in order to building a square of 2 400 randomly distributed cells. Then in a second time, we will create a number of cancerous cells, that will grow and divide.", 
            "title": "Cells and biology Module"
        }, 
        {
            "location": "/jean_tuto/#creating-cells", 
            "text": "To do so, we will work only on the Simulate function of the tutorial.h file. First, before the Simulate method, we will tell BioDynaMo to use the ResourceManager by adding the line template   typename   TResourceManager   =   ResourceManager     This ResourceManager will be used to create cells. Inside the Simulate method, we need to define a resource manager and a structure to contain our cells: auto   rm   =   TResourceManager :: Get ();  auto   cells   =   rm - template   Get Cell ();   Because we want 2400 cells randomly distributed, it is mandatory to have an random number generator to generate x, y and z coordinate of each cell. For that, we will declare three double (x_coord, y_coord and z_coord) and use the gTRandom.Uniform random engine    size_t   nb_of_cells = 2400 ;   // number of cells in the simulation \n   int   cube_dim   =   100 ;   // cube of 100*100*100 \n   double   x_coord ,   y_coord ,   z_coord ; \n   cells - reserve ( nb_of_cells );   // allocate the correct number of cell in our cells structure before cell creation   Then, with a simple loop from 0 to the number of cells, we will be able to fill this cells structure with cell elements.    for   ( size_t   i   =   0 ;   i     nb_of_cells ;   ++ i )   { \n     // our modelling will be a cell cube of 100*100*100 \n     x_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n     y_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n     z_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n     Cell   cell ({ x_coord ,   y_coord ,   z_coord });   // creating the cell at position x, y, z \n     // set cell parameters \n     cell . SetDiameter ( 7.5 ); \n\n     cells - push_back ( cell );   // put the created cell in our cells structure \n   }   We now have our structure containing all the 2400 cells! The code in charge of running our modelling is already written and will simulate it for only one step. Lets change this to simulate for 100 steps. Scheduler   scheduler ;  scheduler . Simulate ( 100 );", 
            "title": "Creating cells"
        }, 
        {
            "location": "/jean_tuto/#biology-module", 
            "text": "In the previous chapter, we created a great number of cells. However, those cells don\u2019t do anything! We will here create a cancerous cell that will grows and divides when it reaches a certain diameter. For this, we will define a new biology module structure GrowthModule that will be applied to cell elements, and we will make this GrowthModule copied into the cell daughter (so the daughter will also contain an instance of the biology module GrowthModule)    struct   GrowthModule   :   public   BaseBiologyModule   { \n   GrowthModule ()   :   BaseBiologyModule ( gAllBmEvents )   {} \n\n     template   typename   T \n       void   Run ( T *   cell )   { \n         // code to be executed \n       } \n\n     ClassDefNV ( GrowthModule ,   1 ); \n   };   We are now able to add any code in the Run() method, that will be executed at each simulation step for each cell containing this GrowthModule In our case, it will be a cellular growth, until a certain diameter is reached and then a cell division        if   ( cell - GetDiameter ()     8 )   { \n         cell - ChangeVolume ( 400 ); \n       } \n       else   { \n         Divide ( * cell ); \n       }   After creating our GrowthModule, we need to add this Biology module to the compile time parameter, to tell BioDynaMo to use this new BiologyModule    template   typename   Backend \n     struct   CompileTimeParam   :   public   DefaultCompileTimeParam Backend   { \n       using   BiologyModules   =   Variant GrowthModule ;   // add GrowthModule \n   };   Of course, we need to create at least one cell that contain our GrowthModule in our Simulate method    Cell   cell   ({ 20 ,   50 ,   50 }); \n   cell . SetDiameter ( 6 ); \n   cell . AddBiologyModule ( GrowthModule ()); \n   cells - push_back ( cell );   This code is now able to create and simulate 2 400 normal cells and 1 cancerous cell that will grow and divide! Complete codes for tutorial.cc and tutorial.h of this chapter are accessible at the end of this tutorial.", 
            "title": "Biology module"
        }, 
        {
            "location": "/jean_tuto/#visualisation-using-paraview", 
            "text": "In the previous chapter we created a simulation of a great number of cell, also containing dividing cancerous cells, but we were not able to visualize anything! In this chapter, we will set up a visualisation using Paraview (included in the BioDynaMo package).", 
            "title": "Visualisation using Paraview"
        }, 
        {
            "location": "/jean_tuto/#paraview", 
            "text": "Paraview  is an open source application for interactive and scientific visualisation. First of all, we need to tell BioDynaMo that we will use Paraview and so that we want the visualisation to be enable. To do that, we need to create a configuration file  bdm.toml  in the tutorial folder. Visualisation is of course not the only configuration we can do using this file. You can allow live visualisation and/or export visualisation (here every 2 simulation step) by adding in bdm.toml [   visualization   ]  live   =   true  export   =   false  export_interval   =   2   you also can say to Paraview to visualize a particular parameter of ours cells, for example the diameter of every cells. Do do that, add below [visualization] in the configuration file the following lines      [[   v   i   s   ualize_sim_object   ]] \n     name   =   Cell \n     additional_data_members   =   [   diameter_   ]  \nBecause those visualization parameters are not in the source code, you don\u2019t need to compile your code again.\nWe can note that instead of creating a configuration file, you can do the same by adding directly in our Simulate function the lines      Param :: live_visualization_   =   true ;   // allows live visualization \n     Param :: export_visualization_   =   true ;   // allows export of visualization files \n     Param :: visualization_export_interval_   =   2 ;   // export visualization files every 2 steps \n     Param :: visualize_sim_objects_ [ Cell ]   =   std :: set std :: string {   diameter_   };   // add the data member diameter_ to the visualization objects  \nOnce again, it is important to note that if you want to change any visualization parameter using this second method, you will have to compile again your code. That is not the case using a configuration file.    We will first see live visualization then the export visualization. In both cases, simply run Paraview using the console line command  paraview  . This windows should appears", 
            "title": "Paraview"
        }, 
        {
            "location": "/jean_tuto/#live-visualisation", 
            "text": "Click on the  Catalyst  top menu, and select  Connect  This windows should appears   Click OK, then this windows should appears   Your Paraview is now accepting connections! Click OK, and go back to the  Catalyst  menu, and select  Pause Simulation . Using the same console, launch your tutorial simulation. You now notice that the programme stop right before running the simulation, because we used the Paraview  Pause Simulation .   Go back to Paraview. You notice that new objects have appeared in the  Pipeline Browser  section. Click on the round shape in front of  Cells Glyph .   A new Builtin object have appeared:  Extract: Cells Glyph . Click on the eye in front of it.   All cells appear on the screen!\nYou can now go to the  Catalyst  menu, and select  Continue . The simulation will run the number of steps you specified in your code.   Even if live visualization is particularly useful to set or tune a simulation, it is capital to note that it also drastically slows down the simulation! One way to avoid this major problem is to export visualization files and read then after the modelling is done.", 
            "title": "Live visualisation"
        }, 
        {
            "location": "/jean_tuto/#export-visualisation", 
            "text": "In the configuration file, turn the export parameter to true then run your modelling. You\u2019ll notice the creation of several new files with the following file extensions  *.pvsm, *.pvtu, *.vtu, *pvti, *.vti . Open ParaView and load the generated state file as described in  Section Visualization .  A major advantage of export visualization, in addition of not impacting the simulation time, is that you can visualize your modelling freely in time. using the arrows in the top menu, you can choose respectively to go back to the beginning of the simulation, go one step back, run normally, go one step further or go to the end of the simulation. You also can see witch step you are currently visualising (remember that this step number is the number of your modelling step divided by the export_interval you choose in your configuration file).   In both cases, even if we can now visualize our cell, they have all the same color, which can be a bit confusing and doesn't allow us to visualise properly what is going on.", 
            "title": "Export Visualisation"
        }, 
        {
            "location": "/jean_tuto/#adding-layers-colour", 
            "text": "In this chapter, we will modify our code in order to create a better colouring for our simulation. \nA good idea would be to create a colouring depending on the y axis coordinate. By this way, we could display several layers of cell, and have an other colour for our cancerous cells.\nTo do that, we can extend the existing  Cell  class in order to add a new data member  cell_colour .\nWe will do that directly in our tutorial.h file by writing    // Define my custom cell MyCell, which extends Cell by adding extra data members: cell_colour \n   BDM_SIM_OBJECT ( MyCell ,   bdm :: Cell )   {   // our object extends the Cell object \n     BDM_SIM_OBJECT_HEADER ( MyCellExt ,   1 ,   cell_colour_ );   // create the header with our new data member \n\n     public : \n       MyCellExt ()   {} \n       MyCellExt ( const   std :: array double ,   3   position )   :   Base ( position )   {}   // our creator \n       // getter and setter for our new data member \n       void   SetCelColour ( int   cellColour )   {   cell_colour_ [ kIdx ]   =   cellColour ;   } \n       int   GetCellColour ()   {   return   cell_colour_ [ kIdx ];   } \n       int *   GetCellColourPtr ()   {   return   cell_colour_ . data ();   } \n\n     private : \n     // private data can only be accessed by public function and not directly \n       vec int   cell_colour_ ;   // declare our new data member and define its type \n   };   Don't forget to add this new object to your compile time parameters (inside \"struct CompileTimeParam\") so BioDynaMo know that we want to use our custom  MyCell  object. This is done by adding the line      using   AtomicTypes   =   VariadicTypedef MyCell ;   Each cell (implementing our new object  MyCell ) of the modelling is now able to have a value cell_colour_ that we will choose and use to display different colours! \nIn order to create cells with this attribute, we need to replace all Cell object by MyCell during cells creation (inside the  Simulate()  method). for example //  auto cells = rm- template Get Cell (); // previous structure containing Cell objects \n   auto   cells   =   rm - template   Get MyCell ();   // new structure containing MyCell objects  [...]  //     Cell cell({x_coord, y_coord, z_coord}); // creats a cell as a Cell object; so doesn t contain cell_colour_ \n     MyCell   cell ({ x_coord ,   y_coord ,   z_coord });   // creats a cell as a MyCell object; so contains cell_colour_   Now that we are creating cells implementing MyCell, we can set the cancerous cell cell_colour_ value to 8 (so it will have a really distinct colour from non cancerous cells). To do so, simply use the method SetCellColour() we created      cell . SetCellColour ( 8 );   Do the same for the regular cells, setting the value depending on the y axis value. One possibility is to write      cell . SetCellColour (( int )   y_coord / cube_dim * 6 );   // will vary from 0 to 5. so 6 different layers depending on y_coord   This new simulation is now functional, however before running it, we need to tell BioDynamo to communicates all cell_colour_ values. Do do that, we will modify the configuration file bdm.toml by modifying the visualize_sim_object      [[ visualize_sim_object ]] \n         name   =   MyCell \n         additional_data_members   =   [   diameter_   ,   cell_colour_   ]   With those changes, we are now able to colourise our different layers. All you have to do, after displaying cells and creating the  Glyph  filter (chapter 3.1) is to select your  Glyph  filter and to select cell_colour_ in the  Coloring  section.   Well done, we can now visualise the different layers and the cancerous cell in red!   However, there still is a little problem. The attribute cell_colour_ is not transmitted to the daughter cell after a division. You can also notice that it is not really easy to see the cancerous cells. We will solve those issues in the next chapter.", 
            "title": "Adding layers colour"
        }, 
        {
            "location": "/jean_tuto/#transmitting-its-color-and-playing-with-filters", 
            "text": "To enable dividing cells to transmit its color - meaning its cell_color_ attribute value - we have to modify a little our biology module. //        Divide(*cell); // old \n         auto   daughter   =   Divide ( * cell );   // we now have access to the daughter \n         daughter . SetCellColour ( cell - GetCellColour ());   // daughter cell_colour_ is setted to her mother cell_colour_ value   Even if our cancerous cells transmit their colour to their daughter, it still is not really easy to spot them in the middle of thousands of other cells. This problem can be solve using the threshold filter function of Paraview. To do that, after displaying cells colour as at the end of 3.2, click on the threshold filter button. This filter will be applied to the currently selected  Pipeline Browser , so pay attention to select the correct one ( Glyph1 ) before creating the threshold filter.   On the  Properties  menu, select the  Scalar   cell_colour_ , put the minimum value at 7 and the maximum at 8 (so only the value of cancerous cell is selected) then click  Apply   Finaly, choose the  Coloring  mode  cell_colour_ .   Great, we can now choose to display either all the cells, or just the cancerous cells by selecting either the  Glyph1  or the  Threshold1  in the  Pipeline Browser !   This is of course just an example of what you can do with the threshold filters.", 
            "title": "Transmitting its color and playing with Filters"
        }, 
        {
            "location": "/jean_tuto/#adding-some-complexity", 
            "text": "We now have all we want to visualise our modelling in the best conditions, but this modelling itself is a bit limited. We should add some movements to it as well as a new mechanism to complexify cells division.\nTo add cell movement, we will modify the  Run()  method of our biology module  GrowthModule , and use the function  UpdateMassLocation() . To generate the direction's random numbers we will again use the  gTRandom.Uniform()  function which allow us to generate a random number between two specified numbers. \nWe choose here to give stochastic movement only to growing cells, so we will write the movement just after the volume change      array double ,   3   cell_movements { gTRandom . Uniform ( - 2 ,   2 ),   gTRandom . Uniform ( - 2 ,   2 ),   gTRandom . Uniform ( - 2 ,   2 )};   // create an array of 3 ramdom numbers between -2 and 2 \n     cell - UpdateMassLocation ( cell_movements );   // update the cell mass location, ie move the cell \n     cell - SetPosition ( cell - GetMassLocation ());   // set the cell position \n     cell - SetTractorForce ({ 0 ,   0 ,   0 });   // avoid unwanted movements after our cell displacement   Using the previous chapters, you should now be able to visualise cell movement during their growth. \nThis is great, but every cancerous cell grows and divides indefinitely, and that is a bit too much. We will now add a mechanism to reduce the probability to divide, and assuring that a cancerous cell that didn't divide, will never divide any more. \nTo add a probability to divide of 0.8, simply write      if   ( gTRandom . Uniform ( 0 ,   1 )     0.8 ){ \n       auto   daughter   =   Divide ( * cell ); \n       daughter . SetCellColour ( cell - GetCellColour ()); \n     }   Cells will now have only 60% chance to divide. However, it will have 60% chance to divide at every time step! We want that if a cell doesn't divide, it will not be able to divide any more.\nTo do that, we will create a new MyCell boolean attribute called can_divide_. As well as for the cell_colour_ attribute (see chapter 3.2), add it our MyCell object header BDM_SIM_OBJECT_HEADER ( MyCellExt ,   1 ,   can_divide_ ,   cell_colour_ );   and create three methods,  SetCanDivide() ,  GetCanDivide()  and  GetCanDividePtr() .      void   SetCanDivide ( bool   d )   {   can_divide_ [ kIdx ]   =   d ;   } \n     bool   GetCanDivide ()   {   return   can_divide_ [ kIdx ];   } \n     bool *   GetCanDividePtr ()   {   return   can_divide_ . data ();   }   Then, as for cell_colour_, declare this data member as private      vec bool   can_divide_ ;   Now that we got a new attribute can_divide_, we need to change the  Run()  method to prevent cells that failed the 60% test to divide again.\nFinaly, don't forget to set the daughter can_divide_ value to true after a cell division.          if   ( gTRandom . Uniform ( 0 ,   1 )   0.8     cell - GetCanDivide () == true ){ \n           auto   daughter   =   Divide ( * cell ); \n           daughter . SetCellColour ( cell - GetCellColour ());   // daughter take the cell_colour_ value of her mother \n           daughter . SetCanDivide ( true );   // the daughter will be able to divide \n         } \n         else   { \n           cell - SetCanDivide ( false );   // this cell won t divide anymore \n         }   The tutorial.h code corresponding to this chapter is accessible at the end of this tutorial.  You now have all the BioDynaMo cell basic knowledge to construct your own modelling!", 
            "title": "Adding some complexity"
        }, 
        {
            "location": "/jean_tuto/#diffusion", 
            "text": "Coming soon.", 
            "title": "Diffusion"
        }, 
        {
            "location": "/jean_tuto/#code", 
            "text": "", 
            "title": "Code"
        }, 
        {
            "location": "/jean_tuto/#tutorialcc", 
            "text": "#include   tutorial.h  int   main ( int   argc ,   const   char **   argv )   {   return   bdm :: Simulate ( argc ,   argv );   }", 
            "title": "tutorial.cc"
        }, 
        {
            "location": "/jean_tuto/#tutorialh-chapter-22", 
            "text": "#ifndef TUTORIAL_H_  #define TUTORIAL_H_  #include   biodynamo.h  //using namespace std;  namespace   bdm   {  // 1. Define growth behaviour \n   struct   GrowthModule   :   public   BaseBiologyModule   { \n   GrowthModule ()   :   BaseBiologyModule ( gAllBmEvents )   {} \n\n     template   typename   T \n       void   Run ( T *   cell )   { \n\n       if   ( cell - GetDiameter ()     8 )   { \n         cell - ChangeVolume ( 400 ); \n       } \n       else { \n         Divide ( * cell ); \n       } \n     } \n\n     ClassDefNV ( GrowthModule ,   1 ); \n   };  // Define compile time parameter \n   template   typename   Backend \n     struct   CompileTimeParam   :   public   DefaultCompileTimeParam Backend   { \n   using   BiologyModules   =   Variant GrowthModule ; \n   };  template   typename   TResourceManager   =   ResourceManager  inline   int   Simulate ( int   argc ,   const   char **   argv )   { \n   InitializeBiodynamo ( argc ,   argv ); \n\n   size_t   nb_of_cells = 2400 ;   // number of cells in the simulation \n   int   cube_dim   =   100 ;   // cube of 100*100*100 \n   double   x_coord ,   y_coord ,   z_coord ; \n\n   auto   rm   =   TResourceManager :: Get ();   // set up resource manager \n   auto   cells   =   rm - template   Get Cell ();   // create a structure to contain cells \n   cells - reserve ( nb_of_cells );   // allocate the correct number of cell in our cells structure before cell creation \n\n   for   ( size_t   i   =   0 ;   i     nb_of_cells ;   ++ i )   { \n     // our modelling will be a cell cube of 100*100*100 \n     x_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n     y_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n     z_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n\n     Cell   cell ({ x_coord ,   y_coord ,   z_coord });   // creating the cell at position x, y, z \n     // set cell parameters \n     cell . SetDiameter ( 7.5 ); \n\n     cells - push_back ( cell );   // put the created cell in our cells structure \n   } \n\n   // create a cancerous cell, containing the BiologyModule GrowthModule \n   Cell   cell ({ 20 ,   50 ,   50 }); \n   cell . SetDiameter ( 6 ); \n   cell . AddBiologyModule ( GrowthModule ()); \n   cells - push_back ( cell );   // put the created cell in our cells structure \n\n   cells - Commit ();   // commit cells \n\n   // Run simulation \n   Scheduler   scheduler ; \n   scheduler . Simulate ( 1000 ); \n\n   std :: cout     Simulation completed successfully!     std :: endl ; \n   return   0 ;  }  }   // namespace bdm  #endif  // TUTORIAL_H_", 
            "title": "tutorial.h - chapter 2.2"
        }, 
        {
            "location": "/jean_tuto/#tutorialh-chapter-34", 
            "text": "#ifndef TUTORIAL_H_  #define TUTORIAL_H_  #include   biodynamo.h  #include   random.h  //using namespace std;  namespace   bdm   { \n\n   // 0. Define my custom cell MyCell, which extends Cell by adding extra data members: cell_color and can_divide \n   BDM_SIM_OBJECT ( MyCell ,   bdm :: Cell )   {   // our object extends the Cell object \n     BDM_SIM_OBJECT_HEADER ( MyCellExt ,   1 ,   can_divide_ ,   cell_colour_ );   // create the header with our new data member \n\n     public : \n       MyCellExt ()   {} \n       MyCellExt ( const   std :: array double ,   3   position )   :   Base ( position )   {}   // our creator \n\n       // getter and setter for our new data member \n       void   SetCanDivide ( bool   d )   {   can_divide_ [ kIdx ]   =   d ;   } \n       bool   GetCanDivide ()   {   return   can_divide_ [ kIdx ];   } \n       bool *   GetCanDividePtr ()   {   return   can_divide_ . data ();   } \n\n       void   SetCellColour ( int   cellColour )   {   cell_colour_ [ kIdx ]   =   cellColour ;   } \n       int   GetCellColour ()   {   return   cell_colour_ [ kIdx ];   } \n       int *   GetCellColourPtr ()   {   return   cell_colour_ . data ();   } \n\n     private : \n       // declare new data member and define their type \n       // private data can only be accessed by public function and not directly \n       vec bool   can_divide_ ; \n       vec int   cell_colour_ ; \n   };  // 1. Define growth behaviour \n   struct   GrowthModule   :   public   BaseBiologyModule   { \n   GrowthModule ()   :   BaseBiologyModule ( gAllBmEvents )   {} \n\n     template   typename   T \n       void   Run ( T *   cell )   { \n\n       if   ( cell - GetDiameter ()     8 )   { \n         cell - ChangeVolume ( 400 ); \n\n         array double ,   3   cell_movements { gTRandom . Uniform ( - 2 ,   2 ),   gTRandom . Uniform ( - 2 ,   2 ),   gTRandom . Uniform ( - 2 ,   2 )};   // create an array of 3 ramdom numbers between -2 and 2 \n         cell - UpdateMassLocation ( cell_movements );   // update the cell mass location, ie move the cell \n         cell - SetPosition ( cell - GetMassLocation ());   // set the cell position \n         //Reset biological movement to 0. \n         cell - SetTractorForce ({ 0 ,   0 ,   0 });   // avoid unwanted movements after our cell displacement \n       } \n\n       else   {   // if diameter   8 \n         if   ( gTRandom . Uniform ( 0 ,   1 )   0.8     cell - GetCanDivide ()){ \n           auto   daughter   =   Divide ( * cell ); \n           daughter . SetCellColour ( cell - GetCellColour ());   // daughter take the cell_colour_ value of her mother \n           daughter . SetCanDivide ( true );   // the daughter will be able to divide \n         } \n         else   { \n           cell - SetCanDivide ( false );   // this cell won t divide anymore \n         } \n       } \n     } \n\n     ClassDefNV ( GrowthModule ,   1 ); \n   };  // Define compile time parameter \n   template   typename   Backend \n     struct   CompileTimeParam   :   public   DefaultCompileTimeParam Backend   { \n   using   BiologyModules   =   Variant GrowthModule ; \n   using   AtomicTypes   =   VariadicTypedef MyCell ;   // use MyCell object \n   };  template   typename   TResourceManager   =   ResourceManager  inline   int   Simulate ( int   argc ,   const   char **   argv )   { \n   InitializeBiodynamo ( argc ,   argv ); \n\n   size_t   nb_of_cells = 2400 ;   // number of cells in the simulation \n   int   cube_dim   =   100 ;   // cube of 100*100*100 \n   double   x_coord ,   y_coord ,   z_coord ; \n\n   auto   rm   =   TResourceManager :: Get ();   // set up resource manager \n   auto   cells   =   rm - template   Get MyCell ();   // create a structure to contain cells \n   cells - reserve ( nb_of_cells );   // allocate the correct number of cell in our cells structure before cell creation \n\n   for   ( size_t   i   =   0 ;   i     nb_of_cells ;   ++ i )   { \n     // our modelling will be a cell cube of 100*100*100 \n     x_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n     y_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n     z_coord = gTRandom . Uniform ( 0 ,   cube_dim ); \n\n     MyCell   cell ({ x_coord ,   y_coord ,   z_coord });   // creating the cell at position x, y, z \n     // set cell parameters \n     cell . SetDiameter ( 7.5 ); \n     cell . SetCellColour (( int )   ( y_coord / cube_dim * 6 ));   // will vary from 0 to 5. so 6 different layers depending on y_coord \n\n     cells - push_back ( cell );   // put the created cell in our cells structure \n   } \n\n   // create a cancerous cell, containing the BiologyModule GrowthModule \n   MyCell   cell ({ 20 ,   50 ,   50 }); \n   cell . SetDiameter ( 6 ); \n   cell . SetCellColour ( 8 ); \n   cell . SetCanDivide ( true ); \n   cell . AddBiologyModule ( GrowthModule ()); \n   cells - push_back ( cell );   // put the created cell in our cells structure \n\n   cells - Commit ();   // commit cells  //  Param::live_visualization_ = true; // allows live visualization  //  Param::export_visualization_ = true; // allows export of visualization files  //  Param::visualization_export_interval_ = 10; // export visualization files every 10 steps  //  Param::visualize_sim_objects_[ MyCell ] = std::set std::string { diameter_ }; // add the data member diameter_ to the visualization objects \n\n   // Run simulation \n   Scheduler   scheduler ; \n   for   ( int   i = 0 ;   i 100 ;   i ++ ){ \n     scheduler . Simulate ( 1 ); \n   } \n\n   std :: cout     Simulation completed successfully!     std :: endl ; \n   return   0 ;  }  }   // namespace bdm  #endif  // TUTORIAL_H_", 
            "title": "tutorial.h - chapter 3.4"
        }, 
        {
            "location": "/substance_initializers/", 
            "text": "You might want to initialize the concentration of one or more of the substances\nin your simulation. In this tutorial we shal take a look on how to do so.\n\n\nTutorial by example\n\n\nGo into the \ntest/integration\n directory and open the source file\n\nsubstance_initialization.h\n in your favorite editor. \n\n\n1. List the substance(s)\n\n\nWe start the code of by listing the s we will use in our simulation in an enum\ndata structure. In this example we just create one substance.\n\n\nenum\n \nSubstances\n \n{\n \nkSubstance\n \n};\n\n\n\n\n\n2. Specify the space dimensions\n\n\nWe bound our space to keep things simple.\n\n\nParam\n::\nbound_space_\n \n=\n \ntrue\n;\n\n\nParam\n::\nmin_bound_\n \n=\n \n0\n;\n\n\nParam\n::\nmax_bound_\n \n=\n \n250\n;\n\n\n\n\n\n3. Create a cell\n\n\nWe create one cell with diameter 10, at a random location\n\n\nauto\n \nconstruct\n \n=\n \n[](\nconst\n \nstd\n::\narray\ndouble\n,\n \n3\n \nposition\n)\n \n{\n\n  \nCell\n \ncell\n(\nposition\n);\n\n  \ncell\n.\nSetDiameter\n(\n10\n);\n\n  \nreturn\n \ncell\n;\n\n\n};\n\n\nModelInitializer\n::\nCreateCellsRandom\n(\nParam\n::\nmin_bound_\n,\n \nParam\n::\nmax_bound_\n,\n\n                                      \n1\n,\n \nconstruct\n);\n\n\n\n\n\n4. Define the substance(s)\n\n\nWe define the diffusion parameters of the substance(s) in our simulation. We\nchoose a diffusion coefficient of 0.5, a decay constant 0f 0.1 and a resolution\nof 1.\n\n\nModelInitializer\n::\nDefineSubstance\n(\nkSubstance\n,\n \nSubstance\n,\n \n0.5\n,\n \n0.1\n,\n \n1\n);\n\n\n\n\n\n5. Initialize the substance(s)\n\n\nNow comes the most important part of the tutorial: initializing our substance(s)\nconcentration values throught the space. We will use the function\n\nModelInitializer::InitializeSubstance\n for this purpose.\n\n\nModelInitializer\n::\nInitializeSubstance\n(\nkSubstance\n,\n \nSubstance\n,\n \nGaussianBand\n(\n120\n,\n \n5\n,\n \nAxis\n::\nkXAxis\n));\n\n\n\n\n\nLet's break this down. We first pass the substance enum id and name in the\nfunction in order to specify which substance we want to initialize. Then we\nsimply pass the model we want to initialize the substance with (we call these \"initializers\").\nIn this case we choose for a GaussianBand with a mean value of 120 along the\nx-axis, and a variance of 5.\n\n\nThe result (visualized with ParaView) is the following:\n\n\n\n\nCreating a custom substance initializer\n\n\nIn this tutorial you have seen how to initialize a substance's concentration\nvalues with the \nGaussianBand\n initializer. Of course this is not the only\nmodel to initialize a substance with. We have several predefined initializers\navailable in BioDynaMo, and you can create your own.\n\n\nLet's take a look at an existing substance initializer.\n\n\nOption 1: Functors\n\n\nstruct\n \nGaussianBand\n \n{\n\n  \ndouble\n \nmean_\n;\n\n  \ndouble\n \nsigma_\n;\n\n  \nuint8_t\n \naxis_\n;\n\n\n  \nGaussianBand\n(\ndouble\n \nmean\n,\n \ndouble\n \nsigma\n,\n \nuint8_t\n \naxis\n)\n \n{\n\n    \nmean_\n \n=\n \nmean\n;\n\n    \nsigma_\n \n=\n \nsigma\n;\n\n    \naxis_\n \n=\n \naxis\n;\n\n  \n}\n\n\n  \ndouble\n \noperator\n()(\ndouble\n \nx\n,\n \ndouble\n \ny\n,\n \ndouble\n \nz\n)\n \n{\n\n    \nswitch\n(\naxis_\n)\n \n{\n\n      \ncase\n \nAxis\n::\nkXAxis\n:\n \nreturn\n \nROOT\n::\nMath\n::\nnormal_pdf\n(\nx\n,\n \nsigma_\n,\n \nmean_\n);\n\n      \ncase\n \nAxis\n::\nkYAxis\n:\n \nreturn\n \nROOT\n::\nMath\n::\nnormal_pdf\n(\ny\n,\n \nsigma_\n,\n \nmean_\n);\n\n      \ncase\n \nAxis\n::\nkZAxis\n:\n \nreturn\n \nROOT\n::\nMath\n::\nnormal_pdf\n(\nz\n,\n \nsigma_\n,\n \nmean_\n);\n\n      \ndefault\n:\n \nthrow\n \nstd\n::\nlogic_error\n(\nYou have chosen an non-existing axis!\n);\n \n    \n}\n\n  \n}\n\n\n};\n\n\n\n\n\nThe above code is what is called a 'functor' in C++. Here it basically describes\nthe model or operation that you want to perform on the entire diffusion space.\nIn the constructor we save the mean, variance and orientation axis, so that this\ninitializer can be used generically. The operator tells BioDynaMo what the concentration\nvalue should be for x, y, and z. BioDynaMo will make sure that your operator is\nexecuted over the whole simulation space. In this example we make use of a function\nthat models the normal (i.e. Gaussian) probability density function.\n\n\nOption 2: Lambdas\n\n\nFunctors are nice if you want to create a generic model that you can apply for\nseveral input variables (e.g. different means, sigmas in the above example).\nBut you might want to just keep it short and simple; in which case lambdas are\nnice to use. We can accomplish exactly the same result as the above example with\nthe following lambda:\n\n\nauto\n \ngaussian_band\n \n=\n \n[]\n(\ndouble\n \nx\n,\n \ndouble\n \ny\n,\n \ndouble\n \nz\n)\n \n{\n\n  \nreturn\n \nROOT\n:\n:\nMath\n::\nnormal_pdf\n(\nx\n,\n \n5\n,\n \n120\n);\n\n\n}\n;\n\n\n\n\n\nMuch simpler right? As you can see we have hard-coded some of the variables that\nwe had generalized in our functor. So depending on your use case or preference,\nlambdas might be the way to go.", 
            "title": "Substance Initialization"
        }, 
        {
            "location": "/substance_initializers/#tutorial-by-example", 
            "text": "Go into the  test/integration  directory and open the source file substance_initialization.h  in your favorite editor.", 
            "title": "Tutorial by example"
        }, 
        {
            "location": "/substance_initializers/#1-list-the-substances", 
            "text": "We start the code of by listing the s we will use in our simulation in an enum\ndata structure. In this example we just create one substance.  enum   Substances   {   kSubstance   };", 
            "title": "1. List the substance(s)"
        }, 
        {
            "location": "/substance_initializers/#2-specify-the-space-dimensions", 
            "text": "We bound our space to keep things simple.  Param :: bound_space_   =   true ;  Param :: min_bound_   =   0 ;  Param :: max_bound_   =   250 ;", 
            "title": "2. Specify the space dimensions"
        }, 
        {
            "location": "/substance_initializers/#3-create-a-cell", 
            "text": "We create one cell with diameter 10, at a random location  auto   construct   =   []( const   std :: array double ,   3   position )   { \n   Cell   cell ( position ); \n   cell . SetDiameter ( 10 ); \n   return   cell ;  };  ModelInitializer :: CreateCellsRandom ( Param :: min_bound_ ,   Param :: max_bound_ , \n                                       1 ,   construct );", 
            "title": "3. Create a cell"
        }, 
        {
            "location": "/substance_initializers/#4-define-the-substances", 
            "text": "We define the diffusion parameters of the substance(s) in our simulation. We\nchoose a diffusion coefficient of 0.5, a decay constant 0f 0.1 and a resolution\nof 1.  ModelInitializer :: DefineSubstance ( kSubstance ,   Substance ,   0.5 ,   0.1 ,   1 );", 
            "title": "4. Define the substance(s)"
        }, 
        {
            "location": "/substance_initializers/#5-initialize-the-substances", 
            "text": "Now comes the most important part of the tutorial: initializing our substance(s)\nconcentration values throught the space. We will use the function ModelInitializer::InitializeSubstance  for this purpose.  ModelInitializer :: InitializeSubstance ( kSubstance ,   Substance ,   GaussianBand ( 120 ,   5 ,   Axis :: kXAxis ));   Let's break this down. We first pass the substance enum id and name in the\nfunction in order to specify which substance we want to initialize. Then we\nsimply pass the model we want to initialize the substance with (we call these \"initializers\").\nIn this case we choose for a GaussianBand with a mean value of 120 along the\nx-axis, and a variance of 5.  The result (visualized with ParaView) is the following:", 
            "title": "5. Initialize the substance(s)"
        }, 
        {
            "location": "/substance_initializers/#creating-a-custom-substance-initializer", 
            "text": "In this tutorial you have seen how to initialize a substance's concentration\nvalues with the  GaussianBand  initializer. Of course this is not the only\nmodel to initialize a substance with. We have several predefined initializers\navailable in BioDynaMo, and you can create your own.  Let's take a look at an existing substance initializer.", 
            "title": "Creating a custom substance initializer"
        }, 
        {
            "location": "/substance_initializers/#option-1-functors", 
            "text": "struct   GaussianBand   { \n   double   mean_ ; \n   double   sigma_ ; \n   uint8_t   axis_ ; \n\n   GaussianBand ( double   mean ,   double   sigma ,   uint8_t   axis )   { \n     mean_   =   mean ; \n     sigma_   =   sigma ; \n     axis_   =   axis ; \n   } \n\n   double   operator ()( double   x ,   double   y ,   double   z )   { \n     switch ( axis_ )   { \n       case   Axis :: kXAxis :   return   ROOT :: Math :: normal_pdf ( x ,   sigma_ ,   mean_ ); \n       case   Axis :: kYAxis :   return   ROOT :: Math :: normal_pdf ( y ,   sigma_ ,   mean_ ); \n       case   Axis :: kZAxis :   return   ROOT :: Math :: normal_pdf ( z ,   sigma_ ,   mean_ ); \n       default :   throw   std :: logic_error ( You have chosen an non-existing axis! );  \n     } \n   }  };   The above code is what is called a 'functor' in C++. Here it basically describes\nthe model or operation that you want to perform on the entire diffusion space.\nIn the constructor we save the mean, variance and orientation axis, so that this\ninitializer can be used generically. The operator tells BioDynaMo what the concentration\nvalue should be for x, y, and z. BioDynaMo will make sure that your operator is\nexecuted over the whole simulation space. In this example we make use of a function\nthat models the normal (i.e. Gaussian) probability density function.", 
            "title": "Option 1: Functors"
        }, 
        {
            "location": "/substance_initializers/#option-2-lambdas", 
            "text": "Functors are nice if you want to create a generic model that you can apply for\nseveral input variables (e.g. different means, sigmas in the above example).\nBut you might want to just keep it short and simple; in which case lambdas are\nnice to use. We can accomplish exactly the same result as the above example with\nthe following lambda:  auto   gaussian_band   =   [] ( double   x ,   double   y ,   double   z )   { \n   return   ROOT : : Math :: normal_pdf ( x ,   5 ,   120 );  } ;   Much simpler right? As you can see we have hard-coded some of the variables that\nwe had generalized in our functor. So depending on your use case or preference,\nlambdas might be the way to go.", 
            "title": "Option 2: Lambdas"
        }, 
        {
            "location": "/gpu_acceleration/", 
            "text": "GPU-acceleration: what and why?\n\n\nPhysical interactions are one of the most compute intensive operations in\nbiological simulations. The main reason is that the computations that are\ninvolved often include operators that require multiple CPU cycles to perform the corresponding operation. In an accurate model, physical interactions happen between all simulation objects and their local environment, for every time step. Therefore, you can imagine that a lot of performance can be gained by accelerating these interactions.\n\n\nGeneral purpose GPUs (GPGPUs) make it possible to obtain the computing performance of a small cluster computer. Almost any desktop computer, or laptop has a built-in GPU available. It mostly takes care of all the graphical computations that take place on a computer, but recent developments allow us to use GPUs for high-performance computing purposes. Frameworks such as CUDA and OpenCL make it possible to program a GPU to perform the computations that we specify at a speed much higher than on a regular CPU. Of course, this depends on the type of computation that you want to perform, but fortunately physical interactions in BioDynaMo fits the bill.\n\n\nRequirements\n\n\nWe try to keep things as simple as possible in terms of usage. So for the most part you are good to go as long as you meet either the following requirements:\n\n\n\n\nYou have a CUDA-compatible GPU and CUDA installed\n\n\nYou have an OpenCL-compatible GPU and OpenCL installed\n\n\n\n\nIf you have multiple GPUs on your machine, BioDynaMo will automatically select one. You can also configure this yourself if you prefer one GPU over the other(s). More on this below.\n\n\nEnabling GPU acceleration\n\n\nThe only thing you need to do to enjoy GPU acceleration is enabling it through the configuration file (bdm.toml) as following:\n\n\n[\nexperimental\n]\n\n\nuse_gpu\n \n=\n \ntrue\n\n\n\n\n\nBy default we assume that your GPU is only CUDA-compatible. If you want to let BioDynaMo know you have an OpenCL-compatible GPU just append the following to the above snippet:\n\n\nuse_opencl\n \n=\n \ntrue\n\n\n\n\n\n\n\nNote\n\n\nIf you have multiple GPUs on your system you can select which BioDynaMo uses by setting the following flag: \npreferred_gpu = \nvalue\n, where \nvalue\n is the index of the GPU in the list of all GPUs.", 
            "title": "GPU Acceleration"
        }, 
        {
            "location": "/gpu_acceleration/#gpu-acceleration-what-and-why", 
            "text": "Physical interactions are one of the most compute intensive operations in\nbiological simulations. The main reason is that the computations that are\ninvolved often include operators that require multiple CPU cycles to perform the corresponding operation. In an accurate model, physical interactions happen between all simulation objects and their local environment, for every time step. Therefore, you can imagine that a lot of performance can be gained by accelerating these interactions.  General purpose GPUs (GPGPUs) make it possible to obtain the computing performance of a small cluster computer. Almost any desktop computer, or laptop has a built-in GPU available. It mostly takes care of all the graphical computations that take place on a computer, but recent developments allow us to use GPUs for high-performance computing purposes. Frameworks such as CUDA and OpenCL make it possible to program a GPU to perform the computations that we specify at a speed much higher than on a regular CPU. Of course, this depends on the type of computation that you want to perform, but fortunately physical interactions in BioDynaMo fits the bill.", 
            "title": "GPU-acceleration: what and why?"
        }, 
        {
            "location": "/gpu_acceleration/#requirements", 
            "text": "We try to keep things as simple as possible in terms of usage. So for the most part you are good to go as long as you meet either the following requirements:   You have a CUDA-compatible GPU and CUDA installed  You have an OpenCL-compatible GPU and OpenCL installed   If you have multiple GPUs on your machine, BioDynaMo will automatically select one. You can also configure this yourself if you prefer one GPU over the other(s). More on this below.", 
            "title": "Requirements"
        }, 
        {
            "location": "/gpu_acceleration/#enabling-gpu-acceleration", 
            "text": "The only thing you need to do to enjoy GPU acceleration is enabling it through the configuration file (bdm.toml) as following:  [ experimental ]  use_gpu   =   true   By default we assume that your GPU is only CUDA-compatible. If you want to let BioDynaMo know you have an OpenCL-compatible GPU just append the following to the above snippet:  use_opencl   =   true    Note  If you have multiple GPUs on your system you can select which BioDynaMo uses by setting the following flag:  preferred_gpu =  value , where  value  is the index of the GPU in the list of all GPUs.", 
            "title": "Enabling GPU acceleration"
        }, 
        {
            "location": "/contact/", 
            "text": "Contact\n\n\nPlease contact us at: \nbiodynamo-talk@cern.ch", 
            "title": "Contact"
        }, 
        {
            "location": "/contact/#contact", 
            "text": "Please contact us at:  biodynamo-talk@cern.ch", 
            "title": "Contact"
        }
    ]
}
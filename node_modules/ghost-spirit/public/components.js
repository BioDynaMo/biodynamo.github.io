(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(factory());
}(this, (function () { 'use strict';

function expect(val, message) {
    if (val === null || val === undefined) throw new Error(message);
    return val;
}
function unreachable() {
    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "unreachable";

    return new Error(message);
}

// import Logger from './logger';
// let alreadyWarned = false;
function debugAssert(test, msg) {
    // if (!alreadyWarned) {
    //   alreadyWarned = true;
    //   Logger.warn("Don't leave debug assertions on in public builds");
    // }
    if (!test) {
        throw new Error(msg || "assertion failure");
    }
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

var objKeys = Object.keys;

function assign(obj) {
    for (var i = 1; i < arguments.length; i++) {
        var assignment = arguments[i];
        if (assignment === null || (typeof assignment === 'undefined' ? 'undefined' : _typeof(assignment)) !== 'object') continue;
        var keys = objKeys(assignment);
        for (var j = 0; j < keys.length; j++) {
            var key = keys[j];
            obj[key] = assignment[key];
        }
    }
    return obj;
}
function fillNulls(count) {
    var arr = new Array(count);
    for (var i = 0; i < count; i++) {
        arr[i] = null;
    }
    return arr;
}

var GUID = 0;
function initializeGuid(object) {
    return object._guid = ++GUID;
}
function ensureGuid(object) {
    return object._guid || initializeGuid(object);
}

function dict() {
    return Object.create(null);
}
var DictSet = function () {
    function DictSet() {
        classCallCheck(this, DictSet);

        this.dict = dict();
    }

    DictSet.prototype.add = function add(obj) {
        if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[ensureGuid(obj)] = obj;
        return this;
    };

    DictSet.prototype.delete = function _delete(obj) {
        if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];
    };

    return DictSet;
}();
var Stack = function () {
    function Stack() {
        classCallCheck(this, Stack);

        this.stack = [];
        this.current = null;
    }

    Stack.prototype.push = function push(item) {
        this.current = item;
        this.stack.push(item);
    };

    Stack.prototype.pop = function pop() {
        var item = this.stack.pop();
        var len = this.stack.length;
        this.current = len === 0 ? null : this.stack[len - 1];
        return item === undefined ? null : item;
    };

    Stack.prototype.isEmpty = function isEmpty() {
        return this.stack.length === 0;
    };

    createClass(Stack, [{
        key: 'size',
        get: function get$$1() {
            return this.stack.length;
        }
    }]);
    return Stack;
}();

var ListNode = function ListNode(value) {
    classCallCheck(this, ListNode);

    this.next = null;
    this.prev = null;
    this.value = value;
};
var LinkedList = function () {
    function LinkedList() {
        classCallCheck(this, LinkedList);

        this.clear();
    }

    LinkedList.prototype.head = function head() {
        return this._head;
    };

    LinkedList.prototype.tail = function tail() {
        return this._tail;
    };

    LinkedList.prototype.clear = function clear() {
        this._head = this._tail = null;
    };

    LinkedList.prototype.toArray = function toArray$$1() {
        var out = [];
        this.forEachNode(function (n) {
            return out.push(n);
        });
        return out;
    };

    LinkedList.prototype.nextNode = function nextNode(node) {
        return node.next;
    };

    LinkedList.prototype.forEachNode = function forEachNode(callback) {
        var node = this._head;
        while (node !== null) {
            callback(node);
            node = node.next;
        }
    };

    LinkedList.prototype.insertBefore = function insertBefore(node) {
        var reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        if (reference === null) return this.append(node);
        if (reference.prev) reference.prev.next = node;else this._head = node;
        node.prev = reference.prev;
        node.next = reference;
        reference.prev = node;
        return node;
    };

    LinkedList.prototype.append = function append(node) {
        var tail = this._tail;
        if (tail) {
            tail.next = node;
            node.prev = tail;
            node.next = null;
        } else {
            this._head = node;
        }
        return this._tail = node;
    };

    LinkedList.prototype.remove = function remove(node) {
        if (node.prev) node.prev.next = node.next;else this._head = node.next;
        if (node.next) node.next.prev = node.prev;else this._tail = node.prev;
        return node;
    };

    return LinkedList;
}();
var ListSlice = function () {
    function ListSlice(head, tail) {
        classCallCheck(this, ListSlice);

        this._head = head;
        this._tail = tail;
    }

    ListSlice.prototype.forEachNode = function forEachNode(callback) {
        var node = this._head;
        while (node !== null) {
            callback(node);
            node = this.nextNode(node);
        }
    };

    ListSlice.prototype.head = function head() {
        return this._head;
    };

    ListSlice.prototype.tail = function tail() {
        return this._tail;
    };

    ListSlice.prototype.toArray = function toArray$$1() {
        var out = [];
        this.forEachNode(function (n) {
            return out.push(n);
        });
        return out;
    };

    ListSlice.prototype.nextNode = function nextNode(node) {
        if (node === this._tail) return null;
        return node.next;
    };

    return ListSlice;
}();
var EMPTY_SLICE = new ListSlice(null, null);

var EMPTY_ARRAY = Object.freeze([]);

var CONSTANT = 0;
var INITIAL = 1;
var VOLATILE = NaN;
var RevisionTag = function () {
    function RevisionTag() {
        classCallCheck(this, RevisionTag);
    }

    RevisionTag.prototype.validate = function validate(snapshot) {
        return this.value() === snapshot;
    };

    return RevisionTag;
}();
RevisionTag.id = 0;
var VALUE = [];
var VALIDATE = [];
var TagWrapper = function () {
    function TagWrapper(type, inner) {
        classCallCheck(this, TagWrapper);

        this.type = type;
        this.inner = inner;
    }

    TagWrapper.prototype.value = function value() {
        var func = VALUE[this.type];
        return func(this.inner);
    };

    TagWrapper.prototype.validate = function validate(snapshot) {
        var func = VALIDATE[this.type];
        return func(this.inner, snapshot);
    };

    return TagWrapper;
}();
function register(Type) {
    var type = VALUE.length;
    VALUE.push(function (tag) {
        return tag.value();
    });
    VALIDATE.push(function (tag, snapshot) {
        return tag.validate(snapshot);
    });
    Type.id = type;
}
///
// CONSTANT: 0
VALUE.push(function () {
    return CONSTANT;
});
VALIDATE.push(function (_tag, snapshot) {
    return snapshot === CONSTANT;
});
var CONSTANT_TAG = new TagWrapper(0, null);
// VOLATILE: 1
VALUE.push(function () {
    return VOLATILE;
});
VALIDATE.push(function (_tag, snapshot) {
    return snapshot === VOLATILE;
});
var VOLATILE_TAG = new TagWrapper(1, null);
// CURRENT: 2
VALUE.push(function () {
    return $REVISION;
});
VALIDATE.push(function (_tag, snapshot) {
    return snapshot === $REVISION;
});
var CURRENT_TAG = new TagWrapper(2, null);
function isConst(_ref) {
    var tag = _ref.tag;

    return tag === CONSTANT_TAG;
}
function isConstTag(tag) {
    return tag === CONSTANT_TAG;
}
///
var $REVISION = INITIAL;
var DirtyableTag = function (_RevisionTag) {
    inherits(DirtyableTag, _RevisionTag);

    DirtyableTag.create = function create() {
        var revision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $REVISION;

        return new TagWrapper(this.id, new DirtyableTag(revision));
    };

    function DirtyableTag() {
        var revision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $REVISION;
        classCallCheck(this, DirtyableTag);

        var _this = possibleConstructorReturn(this, _RevisionTag.call(this));

        _this.revision = revision;
        return _this;
    }

    DirtyableTag.prototype.value = function value() {
        return this.revision;
    };

    DirtyableTag.prototype.dirty = function dirty() {
        this.revision = ++$REVISION;
    };

    return DirtyableTag;
}(RevisionTag);
register(DirtyableTag);
function combineTagged(tagged) {
    var optimized = [];
    for (var i = 0, l = tagged.length; i < l; i++) {
        var tag = tagged[i].tag;
        if (tag === VOLATILE_TAG) return VOLATILE_TAG;
        if (tag === CONSTANT_TAG) continue;
        optimized.push(tag);
    }
    return _combine(optimized);
}
function combineSlice(slice) {
    var optimized = [];
    var node = slice.head();
    while (node !== null) {
        var tag = node.tag;
        if (tag === VOLATILE_TAG) return VOLATILE_TAG;
        if (tag !== CONSTANT_TAG) optimized.push(tag);
        node = slice.nextNode(node);
    }
    return _combine(optimized);
}
function combine(tags) {
    var optimized = [];
    for (var i = 0, l = tags.length; i < l; i++) {
        var tag = tags[i];
        if (tag === VOLATILE_TAG) return VOLATILE_TAG;
        if (tag === CONSTANT_TAG) continue;
        optimized.push(tag);
    }
    return _combine(optimized);
}
function _combine(tags) {
    switch (tags.length) {
        case 0:
            return CONSTANT_TAG;
        case 1:
            return tags[0];
        case 2:
            return TagsPair.create(tags[0], tags[1]);
        default:
            return TagsCombinator.create(tags);
    }
}
var CachedTag = function (_RevisionTag2) {
    inherits(CachedTag, _RevisionTag2);

    function CachedTag() {
        classCallCheck(this, CachedTag);

        var _this2 = possibleConstructorReturn(this, _RevisionTag2.apply(this, arguments));

        _this2.lastChecked = null;
        _this2.lastValue = null;
        return _this2;
    }

    CachedTag.prototype.value = function value() {
        var lastChecked = this.lastChecked,
            lastValue = this.lastValue;

        if (lastChecked !== $REVISION) {
            this.lastChecked = $REVISION;
            this.lastValue = lastValue = this.compute();
        }
        return this.lastValue;
    };

    CachedTag.prototype.invalidate = function invalidate() {
        this.lastChecked = null;
    };

    return CachedTag;
}(RevisionTag);

var TagsPair = function (_CachedTag) {
    inherits(TagsPair, _CachedTag);

    TagsPair.create = function create(first, second) {
        return new TagWrapper(this.id, new TagsPair(first, second));
    };

    function TagsPair(first, second) {
        classCallCheck(this, TagsPair);

        var _this3 = possibleConstructorReturn(this, _CachedTag.call(this));

        _this3.first = first;
        _this3.second = second;
        return _this3;
    }

    TagsPair.prototype.compute = function compute() {
        return Math.max(this.first.value(), this.second.value());
    };

    return TagsPair;
}(CachedTag);

register(TagsPair);

var TagsCombinator = function (_CachedTag2) {
    inherits(TagsCombinator, _CachedTag2);

    TagsCombinator.create = function create(tags) {
        return new TagWrapper(this.id, new TagsCombinator(tags));
    };

    function TagsCombinator(tags) {
        classCallCheck(this, TagsCombinator);

        var _this4 = possibleConstructorReturn(this, _CachedTag2.call(this));

        _this4.tags = tags;
        return _this4;
    }

    TagsCombinator.prototype.compute = function compute() {
        var tags = this.tags;

        var max = -1;
        for (var i = 0; i < tags.length; i++) {
            var value = tags[i].value();
            max = Math.max(value, max);
        }
        return max;
    };

    return TagsCombinator;
}(CachedTag);

register(TagsCombinator);
var UpdatableTag = function (_CachedTag3) {
    inherits(UpdatableTag, _CachedTag3);

    UpdatableTag.create = function create(tag) {
        return new TagWrapper(this.id, new UpdatableTag(tag));
    };

    function UpdatableTag(tag) {
        classCallCheck(this, UpdatableTag);

        var _this5 = possibleConstructorReturn(this, _CachedTag3.call(this));

        _this5.tag = tag;
        _this5.lastUpdated = INITIAL;
        return _this5;
    }

    UpdatableTag.prototype.compute = function compute() {
        return Math.max(this.lastUpdated, this.tag.value());
    };

    UpdatableTag.prototype.update = function update(tag) {
        if (tag !== this.tag) {
            this.tag = tag;
            this.lastUpdated = $REVISION;
            this.invalidate();
        }
    };

    return UpdatableTag;
}(CachedTag);
register(UpdatableTag);
var CachedReference = function () {
    function CachedReference() {
        classCallCheck(this, CachedReference);

        this.lastRevision = null;
        this.lastValue = null;
    }

    CachedReference.prototype.value = function value() {
        var tag = this.tag,
            lastRevision = this.lastRevision,
            lastValue = this.lastValue;

        if (lastRevision === null || !tag.validate(lastRevision)) {
            lastValue = this.lastValue = this.compute();
            this.lastRevision = tag.value();
        }
        return lastValue;
    };

    CachedReference.prototype.invalidate = function invalidate() {
        this.lastRevision = null;
    };

    return CachedReference;
}();

var MapperReference = function (_CachedReference) {
    inherits(MapperReference, _CachedReference);

    function MapperReference(reference, mapper) {
        classCallCheck(this, MapperReference);

        var _this6 = possibleConstructorReturn(this, _CachedReference.call(this));

        _this6.tag = reference.tag;
        _this6.reference = reference;
        _this6.mapper = mapper;
        return _this6;
    }

    MapperReference.prototype.compute = function compute() {
        var reference = this.reference,
            mapper = this.mapper;

        return mapper(reference.value());
    };

    return MapperReference;
}(CachedReference);


//////////
var ReferenceCache = function () {
    function ReferenceCache(reference) {
        classCallCheck(this, ReferenceCache);

        this.lastValue = null;
        this.lastRevision = null;
        this.initialized = false;
        this.tag = reference.tag;
        this.reference = reference;
    }

    ReferenceCache.prototype.peek = function peek() {
        if (!this.initialized) {
            return this.initialize();
        }
        return this.lastValue;
    };

    ReferenceCache.prototype.revalidate = function revalidate() {
        if (!this.initialized) {
            return this.initialize();
        }
        var reference = this.reference,
            lastRevision = this.lastRevision;

        var tag = reference.tag;
        if (tag.validate(lastRevision)) return NOT_MODIFIED;
        this.lastRevision = tag.value();
        var lastValue = this.lastValue;

        var value = reference.value();
        if (value === lastValue) return NOT_MODIFIED;
        this.lastValue = value;
        return value;
    };

    ReferenceCache.prototype.initialize = function initialize() {
        var reference = this.reference;

        var value = this.lastValue = reference.value();
        this.lastRevision = reference.tag.value();
        this.initialized = true;
        return value;
    };

    return ReferenceCache;
}();
var NOT_MODIFIED = "adb3b78e-3d22-4e4b-877a-6317c2c5c145";
function isModified(value) {
    return value !== NOT_MODIFIED;
}

var ConstReference = function () {
    function ConstReference(inner) {
        classCallCheck(this, ConstReference);

        this.inner = inner;
        this.tag = CONSTANT_TAG;
    }

    ConstReference.prototype.value = function value() {
        return this.inner;
    };

    return ConstReference;
}();

var ListItem = function (_ListNode) {
    inherits(ListItem, _ListNode);

    function ListItem(iterable, result) {
        classCallCheck(this, ListItem);

        var _this = possibleConstructorReturn(this, _ListNode.call(this, iterable.valueReferenceFor(result)));

        _this.retained = false;
        _this.seen = false;
        _this.key = result.key;
        _this.iterable = iterable;
        _this.memo = iterable.memoReferenceFor(result);
        return _this;
    }

    ListItem.prototype.update = function update(item) {
        this.retained = true;
        this.iterable.updateValueReference(this.value, item);
        this.iterable.updateMemoReference(this.memo, item);
    };

    ListItem.prototype.shouldRemove = function shouldRemove() {
        return !this.retained;
    };

    ListItem.prototype.reset = function reset() {
        this.retained = false;
        this.seen = false;
    };

    return ListItem;
}(ListNode);
var IterationArtifacts = function () {
    function IterationArtifacts(iterable) {
        classCallCheck(this, IterationArtifacts);

        this.iterator = null;
        this.map = dict();
        this.list = new LinkedList();
        this.tag = iterable.tag;
        this.iterable = iterable;
    }

    IterationArtifacts.prototype.isEmpty = function isEmpty() {
        var iterator = this.iterator = this.iterable.iterate();
        return iterator.isEmpty();
    };

    IterationArtifacts.prototype.iterate = function iterate() {
        var iterator = void 0;
        if (this.iterator === null) {
            iterator = this.iterable.iterate();
        } else {
            iterator = this.iterator;
        }
        this.iterator = null;
        return iterator;
    };

    IterationArtifacts.prototype.has = function has(key) {
        return !!this.map[key];
    };

    IterationArtifacts.prototype.get = function get$$1(key) {
        return this.map[key];
    };

    IterationArtifacts.prototype.wasSeen = function wasSeen(key) {
        var node = this.map[key];
        return node !== undefined && node.seen;
    };

    IterationArtifacts.prototype.append = function append(item) {
        var map = this.map,
            list = this.list,
            iterable = this.iterable;

        var node = map[item.key] = new ListItem(iterable, item);
        list.append(node);
        return node;
    };

    IterationArtifacts.prototype.insertBefore = function insertBefore(item, reference) {
        var map = this.map,
            list = this.list,
            iterable = this.iterable;

        var node = map[item.key] = new ListItem(iterable, item);
        node.retained = true;
        list.insertBefore(node, reference);
        return node;
    };

    IterationArtifacts.prototype.move = function move(item, reference) {
        var list = this.list;

        item.retained = true;
        list.remove(item);
        list.insertBefore(item, reference);
    };

    IterationArtifacts.prototype.remove = function remove(item) {
        var list = this.list;

        list.remove(item);
        delete this.map[item.key];
    };

    IterationArtifacts.prototype.nextNode = function nextNode(item) {
        return this.list.nextNode(item);
    };

    IterationArtifacts.prototype.head = function head() {
        return this.list.head();
    };

    return IterationArtifacts;
}();
var ReferenceIterator = function () {
    // if anyone needs to construct this object with something other than
    // an iterable, let @wycats know.
    function ReferenceIterator(iterable) {
        classCallCheck(this, ReferenceIterator);

        this.iterator = null;
        var artifacts = new IterationArtifacts(iterable);
        this.artifacts = artifacts;
    }

    ReferenceIterator.prototype.next = function next() {
        var artifacts = this.artifacts;

        var iterator = this.iterator = this.iterator || artifacts.iterate();
        var item = iterator.next();
        if (item === null) return null;
        return artifacts.append(item);
    };

    return ReferenceIterator;
}();
var Phase;
(function (Phase) {
    Phase[Phase["Append"] = 0] = "Append";
    Phase[Phase["Prune"] = 1] = "Prune";
    Phase[Phase["Done"] = 2] = "Done";
})(Phase || (Phase = {}));
var IteratorSynchronizer = function () {
    function IteratorSynchronizer(_ref) {
        var target = _ref.target,
            artifacts = _ref.artifacts;
        classCallCheck(this, IteratorSynchronizer);

        this.target = target;
        this.artifacts = artifacts;
        this.iterator = artifacts.iterate();
        this.current = artifacts.head();
    }

    IteratorSynchronizer.prototype.sync = function sync() {
        var phase = Phase.Append;
        while (true) {
            switch (phase) {
                case Phase.Append:
                    phase = this.nextAppend();
                    break;
                case Phase.Prune:
                    phase = this.nextPrune();
                    break;
                case Phase.Done:
                    this.nextDone();
                    return;
            }
        }
    };

    IteratorSynchronizer.prototype.advanceToKey = function advanceToKey(key) {
        var current = this.current,
            artifacts = this.artifacts;

        var seek = current;
        while (seek !== null && seek.key !== key) {
            seek.seen = true;
            seek = artifacts.nextNode(seek);
        }
        if (seek !== null) {
            this.current = artifacts.nextNode(seek);
        }
    };

    IteratorSynchronizer.prototype.nextAppend = function nextAppend() {
        var iterator = this.iterator,
            current = this.current,
            artifacts = this.artifacts;

        var item = iterator.next();
        if (item === null) {
            return this.startPrune();
        }
        var key = item.key;

        if (current !== null && current.key === key) {
            this.nextRetain(item);
        } else if (artifacts.has(key)) {
            this.nextMove(item);
        } else {
            this.nextInsert(item);
        }
        return Phase.Append;
    };

    IteratorSynchronizer.prototype.nextRetain = function nextRetain(item) {
        var artifacts = this.artifacts,
            current = this.current;

        current = current;
        current.update(item);
        this.current = artifacts.nextNode(current);
        this.target.retain(item.key, current.value, current.memo);
    };

    IteratorSynchronizer.prototype.nextMove = function nextMove(item) {
        var current = this.current,
            artifacts = this.artifacts,
            target = this.target;
        var key = item.key;

        var found = artifacts.get(item.key);
        found.update(item);
        if (artifacts.wasSeen(item.key)) {
            artifacts.move(found, current);
            target.move(found.key, found.value, found.memo, current ? current.key : null);
        } else {
            this.advanceToKey(key);
        }
    };

    IteratorSynchronizer.prototype.nextInsert = function nextInsert(item) {
        var artifacts = this.artifacts,
            target = this.target,
            current = this.current;

        var node = artifacts.insertBefore(item, current);
        target.insert(node.key, node.value, node.memo, current ? current.key : null);
    };

    IteratorSynchronizer.prototype.startPrune = function startPrune() {
        this.current = this.artifacts.head();
        return Phase.Prune;
    };

    IteratorSynchronizer.prototype.nextPrune = function nextPrune() {
        var artifacts = this.artifacts,
            target = this.target,
            current = this.current;

        if (current === null) {
            return Phase.Done;
        }
        var node = current;
        this.current = artifacts.nextNode(node);
        if (node.shouldRemove()) {
            artifacts.remove(node);
            target.delete(node.key);
        } else {
            node.reset();
        }
        return Phase.Prune;
    };

    IteratorSynchronizer.prototype.nextDone = function nextDone() {
        this.target.done();
    };

    return IteratorSynchronizer;
}();

function tracked() {
    for (var _len = arguments.length, dependencies = Array(_len), _key = 0; _key < _len; _key++) {
        dependencies[_key] = arguments[_key];
    }

    var target = dependencies[0],
        key = dependencies[1],
        descriptor = dependencies[2];

    if (typeof target === "string") {
        return function (target, key, descriptor) {
            return descriptorForTrackedComputedProperty(target, key, descriptor, dependencies);
        };
    } else {
        if (descriptor) {
            return descriptorForTrackedComputedProperty(target, key, descriptor, []);
        } else {
            installTrackedProperty(target, key);
        }
    }
}
function descriptorForTrackedComputedProperty(target, key, descriptor, dependencies) {
    var meta = metaFor(target);
    meta.trackedProperties[key] = true;
    meta.trackedPropertyDependencies[key] = dependencies || [];
    return {
        enumerable: true,
        configurable: false,
        get: descriptor.get,
        set: function set$$1() {
            metaFor(this).dirtyableTagFor(key).inner.dirty();
            descriptor.set.apply(this, arguments);
            propertyDidChange();
        }
    };
}
/**
  Installs a getter/setter for change tracking. The accessor
  acts just like a normal property, but it triggers the `propertyDidChange`
  hook when written to.

  Values are saved on the object using a "shadow key," or a symbol based on the
  tracked property name. Sets write the value to the shadow key, and gets read
  from it.
 */
function installTrackedProperty(target, key) {
    var value = void 0;
    var shadowKey = Symbol(key);
    var meta = metaFor(target);
    meta.trackedProperties[key] = true;
    if (target[key] !== undefined) {
        value = target[key];
    }
    Object.defineProperty(target, key, {
        configurable: true,
        get: function get$$1() {
            return this[shadowKey];
        },
        set: function set$$1(newValue) {
            metaFor(this).dirtyableTagFor(key).inner.dirty();
            this[shadowKey] = newValue;
            propertyDidChange();
        }
    });
}
/**
 * Stores bookkeeping information about tracked properties on the target object
 * and includes helper methods for manipulating and retrieving that data.
 *
 * Computed properties (i.e., tracked getters/setters) deserve some explanation.
 * A computed property is invalidated when either it is set, or one of its
 * dependencies is invalidated. Therefore, we store two tags for each computed
 * property:
 *
 * 1. The dirtyable tag that we invalidate when the setter is invoked.
 * 2. A union tag (tag combinator) of the dirtyable tag and all of the computed
 *    property's dependencies' tags, used by Glimmer to determine "does this
 *    computed property need to be recomputed?"
 */

var Meta = function () {
    function Meta(parent) {
        classCallCheck(this, Meta);

        this.tags = dict();
        this.computedPropertyTags = dict();
        this.trackedProperties = parent ? Object.create(parent.trackedProperties) : dict();
        this.trackedPropertyDependencies = parent ? Object.create(parent.trackedPropertyDependencies) : dict();
    }
    /**
     * The tag representing whether the given property should be recomputed. Used
     * by e.g. Glimmer VM to detect when a property should be re-rendered. Think
     * of this as the "public-facing" tag.
     *
     * For static tracked properties, this is a single DirtyableTag. For computed
     * properties, it is a combinator of the property's DirtyableTag as well as
     * all of its dependencies' tags.
     */


    Meta.prototype.tagFor = function tagFor(key) {
        var tag = this.tags[key];
        if (tag) {
            return tag;
        }
        var dependencies = void 0;
        if (dependencies = this.trackedPropertyDependencies[key]) {
            return this.tags[key] = combinatorForComputedProperties(this, key, dependencies);
        }
        return this.tags[key] = DirtyableTag.create();
    };
    /**
     * The tag used internally to invalidate when a tracked property is set. For
     * static properties, this is the same DirtyableTag returned from `tagFor`.
     * For computed properties, it is the DirtyableTag used as one of the tags in
     * the tag combinator of the CP and its dependencies.
    */


    Meta.prototype.dirtyableTagFor = function dirtyableTagFor(key) {
        var dependencies = this.trackedPropertyDependencies[key];
        var tag = void 0;
        if (dependencies) {
            // The key is for a computed property.
            tag = this.computedPropertyTags[key];
            if (tag) {
                return tag;
            }
            return this.computedPropertyTags[key] = DirtyableTag.create();
        } else {
            // The key is for a static property.
            tag = this.tags[key];
            if (tag) {
                return tag;
            }
            return this.tags[key] = DirtyableTag.create();
        }
    };

    return Meta;
}();

function combinatorForComputedProperties(meta, key, dependencies) {
    // Start off with the tag for the CP's own dirty state.
    var tags = [meta.dirtyableTagFor(key)];
    // Next, add in all of the tags for its dependencies.
    if (dependencies && dependencies.length) {
        for (var i = 0; i < dependencies.length; i++) {
            tags.push(meta.tagFor(dependencies[i]));
        }
    }
    // Return a combinator across the CP's tags and its dependencies' tags.
    return combine(tags);
}
var META = Symbol("ember-object");
function metaFor(obj) {
    var meta = obj[META];
    if (meta && hasOwnProperty(obj, META)) {
        return meta;
    }
    return obj[META] = new Meta(meta);
}
var hOP = Object.prototype.hasOwnProperty;
function hasOwnProperty(obj, key) {
    return hOP.call(obj, key);
}
var propertyDidChange = function propertyDidChange() {};
function setPropertyDidChange(cb) {
    propertyDidChange = cb;
}
function hasTag(obj, key) {
    var meta = obj[META];
    if (!obj[META]) {
        return false;
    }
    if (!meta.trackedProperties[key]) {
        return false;
    }
    return true;
}
var UntrackedPropertyError = function (_Error) {
    inherits(UntrackedPropertyError, _Error);

    function UntrackedPropertyError(target, key, message) {
        classCallCheck(this, UntrackedPropertyError);

        var _this = possibleConstructorReturn(this, _Error.call(this, message));

        _this.target = target;
        _this.key = key;
        return _this;
    }

    UntrackedPropertyError.for = function _for(obj, key) {
        return new UntrackedPropertyError(obj, key, "The property '" + key + "' on " + obj + " was changed after being rendered. If you want to change a property used in a template after the component has rendered, mark the property as a tracked property with the @tracked decorator.");
    };

    return UntrackedPropertyError;
}(Error);
function defaultErrorThrower(obj, key) {
    throw UntrackedPropertyError.for(obj, key);
}
function tagForProperty(obj, key) {
    var throwError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultErrorThrower;

    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === "object" && obj) {
        if (true && !hasTag(obj, key)) {
            installDevModeErrorInterceptor(obj, key, throwError);
        }
        var meta = metaFor(obj);
        return meta.tagFor(key);
    } else {
        return CONSTANT_TAG;
    }
}
/**
 * In development mode only, we install an ad hoc setter on properties where a
 * tag is requested (i.e., it was used in a template) without being tracked. In
 * cases where the property is set, we raise an error.
 */
function installDevModeErrorInterceptor(obj, key, throwError) {
    var target = obj;
    var descriptor = void 0;
    // Find the descriptor for the current property. We may need to walk the
    // prototype chain to do so. If the property is undefined, we may never get a
    // descriptor here.
    var hasOwnDescriptor = true;
    while (target) {
        descriptor = Object.getOwnPropertyDescriptor(target, key);
        if (descriptor) {
            break;
        }
        hasOwnDescriptor = false;
        target = Object.getPrototypeOf(target);
    }
    // If possible, define a property descriptor that passes through the current
    // value on reads but throws an exception on writes.
    if (descriptor) {
        if (descriptor.configurable || !hasOwnDescriptor) {
            Object.defineProperty(obj, key, {
                configurable: descriptor.configurable,
                enumerable: descriptor.enumerable,
                get: function get$$1() {
                    if (descriptor.get) {
                        return descriptor.get.call(this);
                    } else {
                        return descriptor.value;
                    }
                },
                set: function set$$1() {
                    throwError(this, key);
                }
            });
        }
    } else {
        Object.defineProperty(obj, key, {
            set: function set$$1() {
                throwError(this, key);
            }
        });
    }
}

/**
 * The `Component` class defines an encapsulated UI element that is rendered to
 * the DOM. A component is made up of a template and, optionally, this component
 * object.
 *
 * ## Defining a Component
 *
 * To define a component, subclass `Component` and add your own properties,
 * methods and lifecycle hooks:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 * }
 * ```
 *
 * ## Lifecycle Hooks
 *
 * Lifecycle hooks allow you to respond to changes to a component, such as when
 * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a
 * component, implement the hook as a method on your component subclass.
 *
 * For example, to be notified when Glimmer has rendered your component so you
 * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   didInsertElement() {
 *     $(this.element).pickadate();
 *   }
 * }
 * ```
 *
 * ## Data for Templates
 *
 * `Component`s have two different kinds of data, or state, that can be
 * displayed in templates:
 *
 * 1. Arguments
 * 2. Properties
 *
 * Arguments are data that is passed in to a component from its parent
 * component. For example, if I have a `user-greeting` component, I can pass it
 * a name and greeting to use:
 *
 * ```hbs
 * <user-greeting @name="Ricardo" @greeting="Olá">
 * ```
 *
 * Inside my `user-greeting` template, I can access the `@name` and `@greeting`
 * arguments that I've been given:
 *
 * ```hbs
 * {{@greeting}}, {{@name}}!
 * ```
 *
 * Arguments are also available inside my component:
 *
 * ```ts
 * console.log(this.args.greeting); // prints "Olá"
 * ```
 *
 * Properties, on the other hand, are internal to the component and declared in
 * the class. You can use properties to store data that you want to show in the
 * template, or pass to another component as an argument.
 *
 * ```ts
 * import Component from '@glimmer/component';
 *
 * export default class extends Component {
 *   user = {
 *     name: 'Robbie'
 *   }
 * }
 * ```
 *
 * In the above example, we've defined a component with a `user` property that
 * contains an object with its own `name` property.
 *
 * We can render that property in our template:
 *
 * ```hbs
 * Hello, {{user.name}}!
 * ```
 *
 * We can also take that property and pass it as an argument to the
 * `user-greeting` component we defined above:
 *
 * ```hbs
 * <user-greeting @greeting="Hello" @name={{user.name}} />
 * ```
 *
 * ## Arguments vs. Properties
 *
 * Remember, arguments are data that was given to your component by its parent
 * component, and properties are data your component has defined for itself.
 *
 * You can tell the difference between arguments and properties in templates
 * because arguments always start with an `@` sign (think "A is for arguments"):
 *
 * ```hbs
 * {{@firstName}}
 * ```
 *
 * We know that `@firstName` came from the parent component, not the current
 * component, because it starts with `@` and is therefore an argument.
 *
 * On the other hand, if we see:
 *
 * ```hbs
 * {{name}}
 * ```
 *
 * We know that `name` is a property on the component. If we want to know where
 * the data is coming from, we can go look at our component class to find out.
 *
 * Inside the component itself, arguments always show up inside the component's
 * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,
 * inside the component `this.args.firstName` would also be `Tom`.
 */

var Component = function () {
  /**
   * Constructs a new component and assigns itself the passed properties. You
   * should not construct new components yourself. Instead, Glimmer will
   * instantiate new components automatically as it renders.
   *
   * @param options
   */
  function Component(options) {
    classCallCheck(this, Component);

    /**
     * Development-mode only name of the component, useful for debugging.
     */
    this.debugName = null;
    /** @private
     * Slot on the component to save Arguments object passed to the `args` setter.
     */
    this.__args__ = null;
    Object.assign(this, options);
  }
  /**
   * The element corresponding to the main element of the component's template.
   * The main element is the element in the template that has `...attributes` set on it:
   *
   * ```hbs
   * <h1>Modal</h1>
   * <div class="contents" ...attributes>
   *   {{yield}}
   * </div>
   * ```
   *
   * In this example, `this.element` would be the `div` with the class `contents`.
   *
   * You should not try to access this property until after the component's `didInsertElement()`
   * lifecycle hook is called.
   */


  Component.create = function create(injections) {
    return new this(injections);
  };
  /**
   * Called when the component has been inserted into the DOM.
   * Override this function to do any set up that requires an element in the document body.
   */


  Component.prototype.didInsertElement = function didInsertElement() {};
  /**
   * Called when the component has updated and rerendered itself.
   * Called only during a rerender, not during an initial render.
   */


  Component.prototype.didUpdate = function didUpdate() {};
  /**
   * Called before the component has been removed from the DOM.
   */


  Component.prototype.willDestroy = function willDestroy() {};

  Component.prototype.destroy = function destroy() {
    this.willDestroy();
  };

  Component.prototype.toString = function toString() {
    return this.debugName + " component";
  };

  createClass(Component, [{
    key: "element",
    get: function get$$1() {
      var bounds = this.bounds;

      debugAssert(bounds && bounds.firstNode === bounds.lastNode, "The 'element' property can only be accessed on components that contain a single root element in their template. Try using 'bounds' instead to access the first and last nodes.");
      return bounds.firstNode;
    }
    /**
     * Named arguments passed to the component from its parent component.
     * They can be accessed in JavaScript via `this.args.argumentName` and in the template via `@argumentName`.
     *
     * Say you have the following component, which will have two `args`, `firstName` and `lastName`:
     *
     * ```hbs
     * <my-component @firstName="Arthur" @lastName="Dent" />
     * ```
     *
     * If you needed to calculate `fullName` by combining both of them, you would do:
     *
     * ```ts
     * didInsertElement() {
     *   console.log(`Hi, my full name is ${this.args.firstName} ${this.args.lastName}`);
     * }
     * ```
     *
     * While in the template you could do:
     *
     * ```hbs
     * <p>Welcome, {{@firstName}} {{@lastName}}!</p>
     * ```
     *
     */

  }, {
    key: "args",
    get: function get$$1() {
      return this.__args__;
    },
    set: function set$$1(args) {
      this.__args__ = args;
      metaFor(this).dirtyableTagFor("args").inner.dirty();
    }
  }]);
  return Component;
}();

var capabilities = {
    dynamicLayout: false,
    dynamicTag: true,
    prepareArgs: false,
    createArgs: true,
    attributeHook: true,
    elementHook: true
};

var ComponentDefinition = function () {
    function ComponentDefinition(name, manager, ComponentClass, layout) {
        classCallCheck(this, ComponentDefinition);

        this.name = name;
        this.manager = manager;
        this.ComponentClass = ComponentClass;
        this.layout = layout;
        this.state = {
            name: name,
            capabilities: capabilities,
            ComponentClass: ComponentClass,
            layout: layout
        };
    }

    ComponentDefinition.prototype.toJSON = function toJSON() {
        return { GlimmerDebug: "<component-definition name=\"" + this.name + "\">" };
    };

    return ComponentDefinition;
}();

var Container = function () {
    function Container(registry) {
        var resolver = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        classCallCheck(this, Container);

        this._registry = registry;
        this._resolver = resolver;
        this._lookups = {};
        this._factoryDefinitionLookups = {};
    }

    Container.prototype.factoryFor = function factoryFor(specifier) {
        var factoryDefinition = this._factoryDefinitionLookups[specifier];
        if (!factoryDefinition) {
            if (this._resolver) {
                factoryDefinition = this._resolver.retrieve(specifier);
            }
            if (!factoryDefinition) {
                factoryDefinition = this._registry.registration(specifier);
            }
            if (factoryDefinition) {
                this._factoryDefinitionLookups[specifier] = factoryDefinition;
            }
        }
        if (!factoryDefinition) {
            return;
        }
        return this.buildFactory(specifier, factoryDefinition);
    };

    Container.prototype.lookup = function lookup(specifier) {
        var singleton = this._registry.registeredOption(specifier, 'singleton') !== false;
        if (singleton && this._lookups[specifier]) {
            return this._lookups[specifier];
        }
        var factory = this.factoryFor(specifier);
        if (!factory) {
            return;
        }
        if (this._registry.registeredOption(specifier, 'instantiate') === false) {
            return factory.class;
        }
        var object = factory.create();
        if (singleton && object) {
            this._lookups[specifier] = object;
        }
        return object;
    };

    Container.prototype.defaultInjections = function defaultInjections(specifier) {
        return {};
    };

    Container.prototype.buildInjections = function buildInjections(specifier) {
        var hash = this.defaultInjections(specifier);
        var injections = this._registry.registeredInjections(specifier);
        var injection = void 0;
        for (var i = 0; i < injections.length; i++) {
            injection = injections[i];
            hash[injection.property] = this.lookup(injection.source);
        }
        return hash;
    };

    Container.prototype.buildFactory = function buildFactory(specifier, factoryDefinition) {
        var injections = this.buildInjections(specifier);
        return {
            class: factoryDefinition,
            create: function create(options) {
                var mergedOptions = Object.assign({}, injections, options);
                return factoryDefinition.create(mergedOptions);
            }
        };
    };

    return Container;
}();

var Registry = function () {
    function Registry(options) {
        classCallCheck(this, Registry);

        this._registrations = {};
        this._registeredOptions = {};
        this._registeredInjections = {};
        if (options && options.fallback) {
            this._fallback = options.fallback;
        }
    }

    Registry.prototype.register = function register(specifier, factoryDefinition, options) {
        this._registrations[specifier] = factoryDefinition;
        if (options) {
            this._registeredOptions[specifier] = options;
        }
    };

    Registry.prototype.registration = function registration(specifier) {
        var registration = this._registrations[specifier];
        if (registration === undefined && this._fallback) {
            registration = this._fallback.registration(specifier);
        }
        return registration;
    };

    Registry.prototype.unregister = function unregister(specifier) {
        delete this._registrations[specifier];
        delete this._registeredOptions[specifier];
        delete this._registeredInjections[specifier];
    };

    Registry.prototype.registerOption = function registerOption(specifier, option, value) {
        var options = this._registeredOptions[specifier];
        if (!options) {
            options = {};
            this._registeredOptions[specifier] = options;
        }
        options[option] = value;
    };

    Registry.prototype.registeredOption = function registeredOption(specifier, option) {
        var result = void 0;
        var options = this.registeredOptions(specifier);
        if (options) {
            result = options[option];
        }
        if (result === undefined && this._fallback !== undefined) {
            result = this._fallback.registeredOption(specifier, option);
        }
        return result;
    };

    Registry.prototype.registeredOptions = function registeredOptions(specifier) {
        var options = this._registeredOptions[specifier];
        if (options === undefined) {
            var _specifier$split = specifier.split(':'),
                type = _specifier$split[0];

            options = this._registeredOptions[type];
        }
        return options;
    };

    Registry.prototype.unregisterOption = function unregisterOption(specifier, option) {
        var options = this._registeredOptions[specifier];
        if (options) {
            delete options[option];
        }
    };

    Registry.prototype.registerInjection = function registerInjection(specifier, property, source) {
        var injections = this._registeredInjections[specifier];
        if (injections === undefined) {
            this._registeredInjections[specifier] = injections = [];
        }
        injections.push({
            property: property,
            source: source
        });
    };

    Registry.prototype.registeredInjections = function registeredInjections(specifier) {
        var _specifier$split2 = specifier.split(':'),
            type = _specifier$split2[0];

        var injections = this._fallback ? this._fallback.registeredInjections(specifier) : [];
        Array.prototype.push.apply(injections, this._registeredInjections[type]);
        Array.prototype.push.apply(injections, this._registeredInjections[specifier]);
        return injections;
    };

    return Registry;
}();

// TODO - use symbol
var OWNER = '__owner__';
function getOwner(object) {
    return object[OWNER];
}
function setOwner(object, owner) {
    object[OWNER] = owner;
}

/**
 * Contains the first and last DOM nodes in a component's rendered
 * template. These nodes can be used to traverse the section of DOM
 * that belongs to a particular component.
 *
 * Note that these nodes *can* change over the lifetime of a component
 * if the beginning or ending of the template is dynamic.
 */
var Bounds = function () {
    function Bounds(_bounds) {
        classCallCheck(this, Bounds);

        this._bounds = _bounds;
    }

    createClass(Bounds, [{
        key: "firstNode",
        get: function get$$1() {
            return this._bounds.firstNode();
        }
    }, {
        key: "lastNode",
        get: function get$$1() {
            return this._bounds.lastNode();
        }
    }]);
    return Bounds;
}();

var AppendOpcodes = function () {
    function AppendOpcodes() {
        classCallCheck(this, AppendOpcodes);

        this.evaluateOpcode = fillNulls(78 /* Size */).slice();
    }

    AppendOpcodes.prototype.add = function add(name, evaluate) {
        this.evaluateOpcode[name] = evaluate;
    };

    AppendOpcodes.prototype.evaluate = function evaluate(vm, opcode, type) {
        var func = this.evaluateOpcode[type];
        var sp = void 0;
        var expectedChange = void 0;
        var state = void 0;
        func(vm, opcode);
        
    };

    return AppendOpcodes;
}();
var APPEND_OPCODES = new AppendOpcodes();
var AbstractOpcode = function AbstractOpcode() {
    classCallCheck(this, AbstractOpcode);

    initializeGuid(this);
};
var UpdatingOpcode = function (_AbstractOpcode) {
    inherits(UpdatingOpcode, _AbstractOpcode);

    function UpdatingOpcode() {
        classCallCheck(this, UpdatingOpcode);

        var _this = possibleConstructorReturn(this, _AbstractOpcode.apply(this, arguments));

        _this.next = null;
        _this.prev = null;
        return _this;
    }

    return UpdatingOpcode;
}(AbstractOpcode);

/**
 * Registers
 *
 * For the most part, these follows MIPS naming conventions, however the
 * register numbers are different.
 */
var Register;
(function (Register) {
    // $0 or $pc (program counter): pointer into `program` for the next insturction; -1 means exit
    Register[Register["pc"] = 0] = "pc";
    // $1 or $ra (return address): pointer into `program` for the return
    Register[Register["ra"] = 1] = "ra";
    // $2 or $fp (frame pointer): pointer into the `evalStack` for the base of the stack
    Register[Register["fp"] = 2] = "fp";
    // $3 or $sp (stack pointer): pointer into the `evalStack` for the top of the stack
    Register[Register["sp"] = 3] = "sp";
    // $4-$5 or $s0-$s1 (saved): callee saved general-purpose registers
    Register[Register["s0"] = 4] = "s0";
    Register[Register["s1"] = 5] = "s1";
    // $6-$7 or $t0-$t1 (temporaries): caller saved general-purpose registers
    Register[Register["t0"] = 6] = "t0";
    Register[Register["t1"] = 7] = "t1";
    // $8 or $v0 (return value)
    Register[Register["v0"] = 8] = "v0";
})(Register || (Register = {}));

var PrimitiveReference = function (_ConstReference) {
    inherits(PrimitiveReference, _ConstReference);

    function PrimitiveReference(value) {
        classCallCheck(this, PrimitiveReference);
        return possibleConstructorReturn(this, _ConstReference.call(this, value));
    }

    PrimitiveReference.create = function create(value) {
        if (value === undefined) {
            return UNDEFINED_REFERENCE;
        } else if (value === null) {
            return NULL_REFERENCE;
        } else if (value === true) {
            return TRUE_REFERENCE;
        } else if (value === false) {
            return FALSE_REFERENCE;
        } else if (typeof value === 'number') {
            return new ValueReference(value);
        } else {
            return new StringReference(value);
        }
    };

    PrimitiveReference.prototype.get = function get$$1(_key) {
        return UNDEFINED_REFERENCE;
    };

    return PrimitiveReference;
}(ConstReference);

var StringReference = function (_PrimitiveReference) {
    inherits(StringReference, _PrimitiveReference);

    function StringReference() {
        classCallCheck(this, StringReference);

        var _this2 = possibleConstructorReturn(this, _PrimitiveReference.apply(this, arguments));

        _this2.lengthReference = null;
        return _this2;
    }

    StringReference.prototype.get = function get$$1(key) {
        if (key === 'length') {
            var lengthReference = this.lengthReference;

            if (lengthReference === null) {
                lengthReference = this.lengthReference = new ValueReference(this.inner.length);
            }
            return lengthReference;
        } else {
            return _PrimitiveReference.prototype.get.call(this, key);
        }
    };

    return StringReference;
}(PrimitiveReference);

var ValueReference = function (_PrimitiveReference2) {
    inherits(ValueReference, _PrimitiveReference2);

    function ValueReference(value) {
        classCallCheck(this, ValueReference);
        return possibleConstructorReturn(this, _PrimitiveReference2.call(this, value));
    }

    return ValueReference;
}(PrimitiveReference);

var UNDEFINED_REFERENCE = new ValueReference(undefined);
var NULL_REFERENCE = new ValueReference(null);
var TRUE_REFERENCE = new ValueReference(true);
var FALSE_REFERENCE = new ValueReference(false);
var ConditionalReference$1 = function () {
    function ConditionalReference(inner) {
        classCallCheck(this, ConditionalReference);

        this.inner = inner;
        this.tag = inner.tag;
    }

    ConditionalReference.prototype.value = function value() {
        return this.toBool(this.inner.value());
    };

    ConditionalReference.prototype.toBool = function toBool(value) {
        return !!value;
    };

    return ConditionalReference;
}();

var ConcatReference = function (_CachedReference) {
    inherits(ConcatReference, _CachedReference);

    function ConcatReference(parts) {
        classCallCheck(this, ConcatReference);

        var _this = possibleConstructorReturn(this, _CachedReference.call(this));

        _this.parts = parts;
        _this.tag = combineTagged(parts);
        return _this;
    }

    ConcatReference.prototype.compute = function compute() {
        var parts = new Array();
        for (var i = 0; i < this.parts.length; i++) {
            var value = this.parts[i].value();
            if (value !== null && value !== undefined) {
                parts[i] = castToString(value);
            }
        }
        if (parts.length > 0) {
            return parts.join('');
        }
        return null;
    };

    return ConcatReference;
}(CachedReference);
function castToString(value) {
    if (typeof value.toString !== 'function') {
        return '';
    }
    return String(value);
}

function stackAssert(name, top) {
    return "Expected top of stack to be " + name + ", was " + String(top);
}

APPEND_OPCODES.add(1 /* Helper */, function (vm, _ref) {
    var handle = _ref.op1;

    var stack = vm.stack;
    var helper = vm.constants.resolveHandle(handle);
    var args = stack.pop();
    var value = helper(vm, args);
    vm.loadValue(Register.v0, value);
});
APPEND_OPCODES.add(4 /* GetVariable */, function (vm, _ref2) {
    var symbol = _ref2.op1;

    var expr = vm.referenceForSymbol(symbol);
    vm.stack.push(expr);
});
APPEND_OPCODES.add(2 /* SetVariable */, function (vm, _ref3) {
    var symbol = _ref3.op1;

    var expr = vm.stack.pop();
    vm.scope().bindSymbol(symbol, expr);
});
APPEND_OPCODES.add(3 /* SetBlock */, function (vm, _ref4) {
    var symbol = _ref4.op1;

    var handle = vm.stack.pop();
    var scope = vm.stack.pop(); // FIXME(mmun): shouldn't need to cast this
    var table = vm.stack.pop();
    var block = table ? [handle, scope, table] : null;
    vm.scope().bindBlock(symbol, block);
});
APPEND_OPCODES.add(76 /* ResolveMaybeLocal */, function (vm, _ref5) {
    var _name = _ref5.op1;

    var name = vm.constants.getString(_name);
    var locals = vm.scope().getPartialMap();
    var ref = locals[name];
    if (ref === undefined) {
        ref = vm.getSelf().get(name);
    }
    vm.stack.push(ref);
});
APPEND_OPCODES.add(17 /* RootScope */, function (vm, _ref6) {
    var symbols = _ref6.op1,
        bindCallerScope = _ref6.op2;

    vm.pushRootScope(symbols, !!bindCallerScope);
});
APPEND_OPCODES.add(5 /* GetProperty */, function (vm, _ref7) {
    var _key = _ref7.op1;

    var key = vm.constants.getString(_key);
    var expr = vm.stack.pop();
    vm.stack.push(expr.get(key));
});
APPEND_OPCODES.add(6 /* GetBlock */, function (vm, _ref8) {
    var _block = _ref8.op1;
    var stack = vm.stack;

    var block = vm.scope().getBlock(_block);
    if (block) {
        stack.push(block[2]);
        stack.push(block[1]);
        stack.push(block[0]);
    } else {
        stack.push(null);
        stack.push(null);
        stack.push(null);
    }
});
APPEND_OPCODES.add(7 /* HasBlock */, function (vm, _ref9) {
    var _block = _ref9.op1;

    var hasBlock = !!vm.scope().getBlock(_block);
    vm.stack.push(hasBlock ? TRUE_REFERENCE : FALSE_REFERENCE);
});
APPEND_OPCODES.add(8 /* HasBlockParams */, function (vm) {
    // FIXME(mmun): should only need to push the symbol table
    var table = vm.stack.pop();
    false && debugAssert(table === null || table && (typeof table === 'undefined' ? 'undefined' : _typeof(table)) === 'object' && Array.isArray(table.parameters), stackAssert('Option<BlockSymbolTable>', table));

    var hasBlockParams = table && table.parameters.length;
    vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);
});
APPEND_OPCODES.add(9 /* Concat */, function (vm, _ref10) {
    var count = _ref10.op1;

    var out = new Array(count);
    for (var i = count; i > 0; i--) {
        var offset = i - 1;
        out[offset] = vm.stack.pop();
    }
    vm.stack.push(new ConcatReference(out));
});

var Opcodes;
(function (Opcodes) {
    // Statements
    Opcodes[Opcodes["Text"] = 0] = "Text";
    Opcodes[Opcodes["Append"] = 1] = "Append";
    Opcodes[Opcodes["Comment"] = 2] = "Comment";
    Opcodes[Opcodes["Modifier"] = 3] = "Modifier";
    Opcodes[Opcodes["Block"] = 4] = "Block";
    Opcodes[Opcodes["Component"] = 5] = "Component";
    Opcodes[Opcodes["OpenElement"] = 6] = "OpenElement";
    Opcodes[Opcodes["OpenSplattedElement"] = 7] = "OpenSplattedElement";
    Opcodes[Opcodes["FlushElement"] = 8] = "FlushElement";
    Opcodes[Opcodes["CloseElement"] = 9] = "CloseElement";
    Opcodes[Opcodes["StaticAttr"] = 10] = "StaticAttr";
    Opcodes[Opcodes["DynamicAttr"] = 11] = "DynamicAttr";
    Opcodes[Opcodes["AttrSplat"] = 12] = "AttrSplat";
    Opcodes[Opcodes["Yield"] = 13] = "Yield";
    Opcodes[Opcodes["Partial"] = 14] = "Partial";
    Opcodes[Opcodes["DynamicArg"] = 15] = "DynamicArg";
    Opcodes[Opcodes["StaticArg"] = 16] = "StaticArg";
    Opcodes[Opcodes["TrustingAttr"] = 17] = "TrustingAttr";
    Opcodes[Opcodes["Debugger"] = 18] = "Debugger";
    Opcodes[Opcodes["ClientSideStatement"] = 19] = "ClientSideStatement";
    // Expressions
    Opcodes[Opcodes["Unknown"] = 20] = "Unknown";
    Opcodes[Opcodes["Get"] = 21] = "Get";
    Opcodes[Opcodes["MaybeLocal"] = 22] = "MaybeLocal";
    Opcodes[Opcodes["HasBlock"] = 23] = "HasBlock";
    Opcodes[Opcodes["HasBlockParams"] = 24] = "HasBlockParams";
    Opcodes[Opcodes["Undefined"] = 25] = "Undefined";
    Opcodes[Opcodes["Helper"] = 26] = "Helper";
    Opcodes[Opcodes["Concat"] = 27] = "Concat";
    Opcodes[Opcodes["ClientSideExpression"] = 28] = "ClientSideExpression";
})(Opcodes || (Opcodes = {}));

function is(variant) {
    return function (value) {
        return Array.isArray(value) && value[0] === variant;
    };
}
// Statements




// Expressions
var isGet = is(Opcodes.Get);
var isMaybeLocal = is(Opcodes.MaybeLocal);

var Ops$1;
(function (Ops) {
    Ops[Ops["OpenComponentElement"] = 0] = "OpenComponentElement";
    Ops[Ops["DidCreateElement"] = 1] = "DidCreateElement";
    Ops[Ops["SetComponentAttrs"] = 2] = "SetComponentAttrs";
    Ops[Ops["DidRenderLayout"] = 3] = "DidRenderLayout";
    Ops[Ops["Debugger"] = 4] = "Debugger";
})(Ops$1 || (Ops$1 = {}));

var Ops$$1 = Opcodes;
var ATTRS_BLOCK = '&attrs';
var Compilers = function () {
    function Compilers() {
        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        classCallCheck(this, Compilers);

        this.offset = offset;
        this.names = dict();
        this.funcs = [];
    }

    Compilers.prototype.add = function add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    };

    Compilers.prototype.compile = function compile(sexp, builder) {
        var name = sexp[this.offset];
        var index = this.names[name];
        var func = this.funcs[index];
        false && debugAssert(!!func, 'expected an implementation for ' + (this.offset === 0 ? Ops$$1[sexp[0]] : Ops$1[sexp[1]]));

        func(sexp, builder);
    };

    return Compilers;
}();
var _statementCompiler = void 0;
function statementCompiler() {
    if (_statementCompiler) {
        return _statementCompiler;
    }
    var STATEMENTS = _statementCompiler = new Compilers();
    STATEMENTS.add(Ops$$1.Text, function (sexp, builder) {
        builder.text(sexp[1]);
    });
    STATEMENTS.add(Ops$$1.Comment, function (sexp, builder) {
        builder.comment(sexp[1]);
    });
    STATEMENTS.add(Ops$$1.CloseElement, function (_sexp, builder) {
        builder.closeElement();
    });
    STATEMENTS.add(Ops$$1.FlushElement, function (_sexp, builder) {
        builder.flushElement();
    });
    STATEMENTS.add(Ops$$1.Modifier, function (sexp, builder) {
        var lookup = builder.lookup,
            referrer = builder.referrer;
        var name = sexp[1],
            params = sexp[2],
            hash = sexp[3];

        var specifier = lookup.lookupModifier(name, referrer);
        if (specifier) {
            builder.modifier(specifier, params, hash);
        } else {
            throw new Error('Compile Error ' + name + ' is not a modifier: Helpers may not be used in the element form.');
        }
    });
    STATEMENTS.add(Ops$$1.StaticAttr, function (sexp, builder) {
        var name = sexp[1],
            value = sexp[2],
            namespace = sexp[3];

        builder.staticAttr(name, namespace, value);
    });
    STATEMENTS.add(Ops$$1.DynamicAttr, function (sexp, builder) {
        dynamicAttr(sexp, false, builder);
    });
    STATEMENTS.add(Ops$$1.TrustingAttr, function (sexp, builder) {
        dynamicAttr(sexp, true, builder);
    });
    STATEMENTS.add(Ops$$1.OpenElement, function (sexp, builder) {
        builder.openPrimitiveElement(sexp[1]);
    });
    STATEMENTS.add(Ops$$1.OpenSplattedElement, function (sexp, builder) {
        builder.setComponentAttrs(true);
        builder.putComponentOperations();
        builder.openElementWithOperations(sexp[1]);
    });
    STATEMENTS.add(Ops$$1.Component, function (sexp, builder) {
        var tag = sexp[1],
            _attrs = sexp[2],
            args = sexp[3],
            block = sexp[4];
        var lookup = builder.lookup,
            referrer = builder.referrer;

        var handle = lookup.lookupComponentSpec(tag, referrer);
        if (handle !== null) {
            var capabilities = lookup.getCapabilities(handle);
            var attrs = [[Ops$$1.ClientSideStatement, Ops$1.SetComponentAttrs, true]].concat(_attrs, [[Ops$$1.ClientSideStatement, Ops$1.SetComponentAttrs, false]]);
            var attrsBlock = builder.inlineBlock({ statements: attrs, parameters: EMPTY_ARRAY });
            var child = builder.template(block);
            if (capabilities.dynamicLayout === false) {
                var layout = lookup.getLayout(handle);
                builder.pushComponentDefinition(handle);
                builder.invokeStaticComponent(capabilities, layout, attrsBlock, null, args, false, child && child);
            } else {
                builder.pushComponentDefinition(handle);
                builder.invokeComponent(attrsBlock, null, args, false, child && child);
            }
        } else {
            throw new Error('Compile Error: Cannot find component ' + tag);
        }
    });
    STATEMENTS.add(Ops$$1.Partial, function (sexp, builder) {
        var name = sexp[1],
            evalInfo = sexp[2];
        var referrer = builder.referrer;

        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        builder.expr(name);
        builder.dup();
        builder.enter(2);
        builder.jumpUnless('ELSE');
        builder.invokePartial(referrer, builder.evalSymbols(), evalInfo);
        builder.popScope();
        builder.popFrame();
        builder.label('ELSE');
        builder.exit();
        builder.return();
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    STATEMENTS.add(Ops$$1.Yield, function (sexp, builder) {
        var to = sexp[1],
            params = sexp[2];

        builder.yield(to, params);
    });
    STATEMENTS.add(Ops$$1.AttrSplat, function (sexp, builder) {
        var to = sexp[1];

        builder.yield(to, []);
        builder.didCreateElement(Register.s0);
        builder.setComponentAttrs(false);
    });
    STATEMENTS.add(Ops$$1.Debugger, function (sexp, builder) {
        var evalInfo = sexp[1];

        builder.debugger(builder.evalSymbols(), evalInfo);
    });
    STATEMENTS.add(Ops$$1.ClientSideStatement, function (sexp, builder) {
        CLIENT_SIDE.compile(sexp, builder);
    });
    STATEMENTS.add(Ops$$1.Append, function (sexp, builder) {
        var value = sexp[1],
            trusting = sexp[2];
        var inlines = builder.macros.inlines;

        var returned = inlines.compile(sexp, builder) || value;
        if (returned === true) return;
        var isGet$$1 = isGet(value);
        var isMaybeLocal$$1 = isMaybeLocal(value);
        if (trusting) {
            builder.guardedAppend(value, true);
        } else {
            if (isGet$$1 || isMaybeLocal$$1) {
                builder.guardedAppend(value, false);
            } else {
                builder.expr(value);
                builder.dynamicContent(false);
            }
        }
    });
    STATEMENTS.add(Ops$$1.Block, function (sexp, builder) {
        var name = sexp[1],
            params = sexp[2],
            hash = sexp[3],
            _template = sexp[4],
            _inverse = sexp[5];

        var template = builder.template(_template);
        var inverse = builder.template(_inverse);
        var templateBlock = template && template;
        var inverseBlock = inverse && inverse;
        var blocks = builder.macros.blocks;

        blocks.compile(name, params, hash, templateBlock, inverseBlock, builder);
    });
    var CLIENT_SIDE = new Compilers(1);
    CLIENT_SIDE.add(Ops$1.OpenComponentElement, function (sexp, builder) {
        builder.putComponentOperations();
        builder.openElementWithOperations(sexp[2]);
    });
    CLIENT_SIDE.add(Ops$1.DidCreateElement, function (_sexp, builder) {
        builder.didCreateElement(Register.s0);
    });
    CLIENT_SIDE.add(Ops$1.SetComponentAttrs, function (sexp, builder) {
        builder.setComponentAttrs(sexp[2]);
    });
    CLIENT_SIDE.add(Ops$1.Debugger, function () {
        // tslint:disable-next-line:no-debugger
        debugger;
    });
    CLIENT_SIDE.add(Ops$1.DidRenderLayout, function (_sexp, builder) {
        builder.didRenderLayout(Register.s0);
    });
    return STATEMENTS;
}
function dynamicAttr(sexp, trusting, builder) {
    var name = sexp[1],
        value = sexp[2],
        namespace = sexp[3];

    builder.expr(value);
    if (namespace) {
        builder.dynamicAttr(name, namespace, trusting);
    } else {
        builder.dynamicAttr(name, null, trusting);
    }
}
var _expressionCompiler = void 0;
function expressionCompiler() {
    if (_expressionCompiler) {
        return _expressionCompiler;
    }
    var EXPRESSIONS = _expressionCompiler = new Compilers();
    EXPRESSIONS.add(Ops$$1.Unknown, function (sexp, builder) {
        var lookup = builder.lookup,
            asPartial = builder.asPartial,
            referrer = builder.referrer;

        var name = sexp[1];
        var specifier = lookup.lookupHelper(name, referrer);
        if (specifier !== null) {
            builder.helper(specifier, null, null);
        } else if (asPartial) {
            builder.resolveMaybeLocal(name);
        } else {
            builder.getVariable(0);
            builder.getProperty(name);
        }
    });
    EXPRESSIONS.add(Ops$$1.Concat, function (sexp, builder) {
        var parts = sexp[1];
        for (var i = 0; i < parts.length; i++) {
            builder.expr(parts[i]);
        }
        builder.concat(parts.length);
    });
    EXPRESSIONS.add(Ops$$1.Helper, function (sexp, builder) {
        var lookup = builder.lookup,
            referrer = builder.referrer;
        var name = sexp[1],
            params = sexp[2],
            hash = sexp[3];
        // TODO: triage this in the WF compiler

        if (name === 'component') {
            false && debugAssert(params.length, 'SYNTAX ERROR: component helper requires at least one argument');

            var definition = params[0],
                restArgs = params.slice(1);

            builder.curryComponent(definition, restArgs, hash, true);
            return;
        }
        var specifier = lookup.lookupHelper(name, referrer);
        if (specifier !== null) {
            builder.helper(specifier, params, hash);
        } else {
            throw new Error('Compile Error: ' + name + ' is not a helper');
        }
    });
    EXPRESSIONS.add(Ops$$1.Get, function (sexp, builder) {
        var head = sexp[1],
            path = sexp[2];

        builder.getVariable(head);
        for (var i = 0; i < path.length; i++) {
            builder.getProperty(path[i]);
        }
    });
    EXPRESSIONS.add(Ops$$1.MaybeLocal, function (sexp, builder) {
        var path = sexp[1];

        if (builder.asPartial) {
            var head = path[0];
            path = path.slice(1);
            builder.resolveMaybeLocal(head);
        } else {
            builder.getVariable(0);
        }
        for (var i = 0; i < path.length; i++) {
            builder.getProperty(path[i]);
        }
    });
    EXPRESSIONS.add(Ops$$1.Undefined, function (_sexp, builder) {
        return builder.pushPrimitiveReference(undefined);
    });
    EXPRESSIONS.add(Ops$$1.HasBlock, function (sexp, builder) {
        builder.hasBlock(sexp[1]);
    });
    EXPRESSIONS.add(Ops$$1.HasBlockParams, function (sexp, builder) {
        builder.hasBlockParams(sexp[1]);
    });
    return EXPRESSIONS;
}
var Macros = function Macros() {
    classCallCheck(this, Macros);

    var _populateBuiltins = populateBuiltins(),
        blocks = _populateBuiltins.blocks,
        inlines = _populateBuiltins.inlines;

    this.blocks = blocks;
    this.inlines = inlines;
};
var Blocks = function () {
    function Blocks() {
        classCallCheck(this, Blocks);

        this.names = dict();
        this.funcs = [];
    }

    Blocks.prototype.add = function add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    };

    Blocks.prototype.addMissing = function addMissing(func) {
        this.missing = func;
    };

    Blocks.prototype.compile = function compile(name, params, hash, template, inverse, builder) {
        var index = this.names[name];
        if (index === undefined) {
            false && debugAssert(!!this.missing, name + ' not found, and no catch-all block handler was registered');

            var func = this.missing;
            var handled = func(name, params, hash, template, inverse, builder);
            false && debugAssert(!!handled, name + ' not found, and the catch-all block handler didn\'t handle it');
        } else {
            var _func = this.funcs[index];
            _func(params, hash, template, inverse, builder);
        }
    };

    return Blocks;
}();
var Inlines = function () {
    function Inlines() {
        classCallCheck(this, Inlines);

        this.names = dict();
        this.funcs = [];
    }

    Inlines.prototype.add = function add(name, func) {
        this.funcs.push(func);
        this.names[name] = this.funcs.length - 1;
    };

    Inlines.prototype.addMissing = function addMissing(func) {
        this.missing = func;
    };

    Inlines.prototype.compile = function compile(sexp, builder) {
        var value = sexp[1];
        // TODO: Fix this so that expression macros can return
        // things like components, so that {{component foo}}
        // is the same as {{(component foo)}}
        if (!Array.isArray(value)) return ['expr', value];
        var name = void 0;
        var params = void 0;
        var hash = void 0;
        if (value[0] === Ops$$1.Helper) {
            name = value[1];
            params = value[2];
            hash = value[3];
        } else if (value[0] === Ops$$1.Unknown) {
            name = value[1];
            params = hash = null;
        } else {
            return ['expr', value];
        }
        var index = this.names[name];
        if (index === undefined && this.missing) {
            var func = this.missing;
            var returned = func(name, params, hash, builder);
            return returned === false ? ['expr', value] : returned;
        } else if (index !== undefined) {
            var _func2 = this.funcs[index];
            var _returned = _func2(name, params, hash, builder);
            return _returned === false ? ['expr', value] : _returned;
        } else {
            return ['expr', value];
        }
    };

    return Inlines;
}();
function populateBuiltins() {
    var blocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Blocks();
    var inlines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Inlines();

    blocks.add('if', function (params, _hash, template, inverse, builder) {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error('SYNTAX ERROR: #if requires a single argument');
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        builder.expr(params[0]);
        builder.toBoolean();
        builder.enter(1);
        builder.jumpUnless('ELSE');
        builder.invokeStaticBlock(template);
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStaticBlock(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('unless', function (params, _hash, template, inverse, builder) {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error('SYNTAX ERROR: #unless requires a single argument');
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        builder.expr(params[0]);
        builder.toBoolean();
        builder.enter(1);
        builder.jumpIf('ELSE');
        builder.invokeStaticBlock(template);
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStaticBlock(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('with', function (params, _hash, template, inverse, builder) {
        //        PutArgs
        //        Test(Environment)
        //        Enter(BEGIN, END)
        // BEGIN: Noop
        //        JumpUnless(ELSE)
        //        Evaluate(default)
        //        Jump(END)
        // ELSE:  Noop
        //        Evalulate(inverse)
        // END:   Noop
        //        Exit
        if (!params || params.length !== 1) {
            throw new Error('SYNTAX ERROR: #with requires a single argument');
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        builder.expr(params[0]);
        builder.dup();
        builder.toBoolean();
        builder.enter(2);
        builder.jumpUnless('ELSE');
        builder.invokeStaticBlock(template, 1);
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStaticBlock(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('each', function (params, hash, template, inverse, builder) {
        //         Enter(BEGIN, END)
        // BEGIN:  Noop
        //         PutArgs
        //         PutIterable
        //         JumpUnless(ELSE)
        //         EnterList(BEGIN2, END2)
        // ITER:   Noop
        //         NextIter(BREAK)
        // BEGIN2: Noop
        //         PushChildScope
        //         Evaluate(default)
        //         PopScope
        // END2:   Noop
        //         Exit
        //         Jump(ITER)
        // BREAK:  Noop
        //         ExitList
        //         Jump(END)
        // ELSE:   Noop
        //         Evalulate(inverse)
        // END:    Noop
        //         Exit
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        if (hash && hash[0][0] === 'key') {
            builder.expr(hash[1][0]);
        } else {
            builder.pushPrimitiveReference(null);
        }
        builder.expr(params[0]);
        builder.enter(2);
        builder.putIterator();
        builder.jumpUnless('ELSE');
        builder.pushFrame();
        builder.returnTo('ITER');
        builder.dup(Register.fp, 1);
        builder.enterList('BODY');
        builder.label('ITER');
        builder.iterate('BREAK');
        builder.label('BODY');
        builder.invokeStaticBlock(template, 2);
        builder.pop(2);
        builder.exit();
        builder.return();
        builder.label('BREAK');
        builder.exitList();
        builder.popFrame();
        if (inverse) {
            builder.jump('EXIT');
            builder.label('ELSE');
            builder.invokeStaticBlock(inverse);
            builder.label('EXIT');
            builder.exit();
            builder.return();
        } else {
            builder.label('ELSE');
            builder.exit();
            builder.return();
        }
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('in-element', function (params, hash, template, _inverse, builder) {
        if (!params || params.length !== 1) {
            throw new Error('SYNTAX ERROR: #in-element requires a single argument');
        }
        builder.startLabels();
        builder.pushFrame();
        builder.returnTo('END');
        var keys = hash[0],
            values = hash[1];

        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key === 'nextSibling' || key === 'guid') {
                builder.expr(values[i]);
            } else {
                throw new Error('SYNTAX ERROR: #in-element does not take a `' + keys[0] + '` option');
            }
        }
        builder.expr(params[0]);
        builder.dup();
        builder.enter(4);
        builder.jumpUnless('ELSE');
        builder.pushRemoteElement();
        builder.invokeStaticBlock(template);
        builder.popRemoteElement();
        builder.label('ELSE');
        builder.exit();
        builder.return();
        builder.label('END');
        builder.popFrame();
        builder.stopLabels();
    });
    blocks.add('-with-dynamic-vars', function (_params, hash, template, _inverse, builder) {
        if (hash) {
            var names = hash[0],
                expressions = hash[1];

            builder.compileParams(expressions);
            builder.pushDynamicScope();
            builder.bindDynamicScope(names);
            builder.invokeStaticBlock(template);
            builder.popDynamicScope();
        } else {
            builder.invokeStaticBlock(template);
        }
    });
    blocks.add('component', function (_params, hash, template, inverse, builder) {
        false && debugAssert(_params && _params.length, 'SYNTAX ERROR: #component requires at least one argument');

        var definition = _params[0],
            params = _params.slice(1);

        builder.dynamicComponent(definition, params, hash, true, template, inverse);
    });
    inlines.add('component', function (_name, _params, hash, builder) {
        false && debugAssert(_params && _params.length, 'SYNTAX ERROR: component helper requires at least one argument');

        var definition = _params[0],
            params = _params.slice(1);

        builder.dynamicComponent(definition, params, hash, true, null, null);
        return true;
    });
    return { blocks: blocks, inlines: inlines };
}

var CompilableTemplate = function () {
    function CompilableTemplate(statements, containingLayout, options, symbolTable) {
        classCallCheck(this, CompilableTemplate);

        this.statements = statements;
        this.containingLayout = containingLayout;
        this.options = options;
        this.symbolTable = symbolTable;
        this.compiled = null;
        this.statementCompiler = statementCompiler();
    }

    CompilableTemplate.topLevel = function topLevel(block, options) {
        return new CompilableTemplate(block.statements, { block: block, referrer: options.referrer }, options, { referrer: options.referrer, hasEval: block.hasEval, symbols: block.symbols });
    };

    CompilableTemplate.prototype.compile = function compile() {
        var compiled = this.compiled;

        if (compiled !== null) return compiled;
        var options = this.options,
            statements = this.statements,
            containingLayout = this.containingLayout;
        var referrer = containingLayout.referrer;
        var program = options.program,
            lookup = options.lookup,
            macros = options.macros,
            asPartial = options.asPartial,
            Builder = options.Builder;

        var builder = new Builder(program, lookup, referrer, macros, containingLayout, asPartial);
        for (var i = 0; i < statements.length; i++) {
            this.statementCompiler.compile(statements[i], builder);
        }
        var handle = builder.commit(program.heap);
        return this.compiled = handle;
    };

    return CompilableTemplate;
}();

var ComponentBuilder = function () {
    function ComponentBuilder(builder) {
        classCallCheck(this, ComponentBuilder);

        this.builder = builder;
    }

    ComponentBuilder.prototype.static = function _static(handle, args) {
        var params = args[0],
            hash = args[1],
            _default = args[2],
            inverse = args[3];
        var builder = this.builder;
        var lookup = builder.lookup;

        if (handle !== null) {
            var capabilities = lookup.getCapabilities(handle);
            if (capabilities.dynamicLayout === false) {
                var layout = lookup.getLayout(handle);
                builder.pushComponentDefinition(handle);
                builder.invokeStaticComponent(capabilities, layout, null, params, hash, false, _default, inverse);
            } else {
                builder.pushComponentDefinition(handle);
                builder.invokeComponent(null, params, hash, false, _default, inverse);
            }
        }
    };

    return ComponentBuilder;
}();

var ARG_SHIFT = 8;
var MAX_SIZE = 65535;
var TYPE_SIZE = 255;
var TYPE_MASK = 255;
var OPERAND_LEN_MASK = 768;
var InstructionEncoder = function () {
    function InstructionEncoder(buffer) {
        classCallCheck(this, InstructionEncoder);

        this.buffer = buffer;
        this.typePos = 0;
        this.size = 0;
    }

    InstructionEncoder.prototype.encode = function encode(type) {
        var _this = this;

        if (type > TYPE_SIZE) {
            throw new Error('Opcode type over 8-bits. Got ' + type + '.');
        }

        for (var _len = arguments.length, operands = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            operands[_key - 1] = arguments[_key];
        }

        this.buffer.push(type | operands.length << ARG_SHIFT);
        this.typePos = this.buffer.length - 1;
        operands.forEach(function (op) {
            if (op > MAX_SIZE) {
                throw new Error('Operand over 16-bits. Got ' + op + '.');
            }
            _this.buffer.push(op);
        });
        this.size = this.buffer.length;
    };

    InstructionEncoder.prototype.compact = function compact(program) {
        return String.fromCharCode.apply(String, program);
    };

    InstructionEncoder.prototype.patch = function patch(position, operand) {
        if (this.buffer[position + 1] === -1) {
            this.buffer[position + 1] = operand;
        } else {
            throw new Error('Trying to patch operand in populated slot instead of a reserved slot.');
        }
    };

    return InstructionEncoder;
}();

var Labels = function () {
    function Labels() {
        classCallCheck(this, Labels);

        this.labels = dict();
        this.targets = [];
    }

    Labels.prototype.label = function label(name, index) {
        this.labels[name] = index;
    };

    Labels.prototype.target = function target(at, Target, _target) {
        this.targets.push({ at: at, Target: Target, target: _target });
    };

    Labels.prototype.patch = function patch(encoder) {
        var targets = this.targets,
            labels = this.labels;

        for (var i = 0; i < targets.length; i++) {
            var _targets$i = targets[i],
                at = _targets$i.at,
                target = _targets$i.target;

            var address = labels[target] - at;
            encoder.patch(at, address);
        }
    };

    return Labels;
}();

var OpcodeBuilder = function () {
    function OpcodeBuilder(program, lookup, referrer, macros, containingLayout, asPartial) {
        classCallCheck(this, OpcodeBuilder);

        this.program = program;
        this.lookup = lookup;
        this.referrer = referrer;
        this.macros = macros;
        this.containingLayout = containingLayout;
        this.asPartial = asPartial;
        this.encoder = new InstructionEncoder([]);
        this.labelsStack = new Stack();
        this.isComponentAttrs = false;
        this.component = new ComponentBuilder(this);
        this.constants = program.constants;
        this.expressionCompiler = expressionCompiler();
    }

    OpcodeBuilder.prototype.expr = function expr(expression) {
        if (Array.isArray(expression)) {
            this.expressionCompiler.compile(expression, this);
        } else {
            this.pushPrimitiveReference(expression);
        }
    };

    OpcodeBuilder.prototype.upvars = function upvars(count) {
        return fillNulls(count);
    };

    OpcodeBuilder.prototype.reserve = function reserve(name) {
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

        var reservedOperands = [];
        for (var i = 0; i < size; i++) {
            reservedOperands[i] = -1;
        }
        this.push.apply(this, [name].concat(reservedOperands));
    };

    OpcodeBuilder.prototype.push = function push(name) {
        var encoder = this.encoder;

        for (var _len = arguments.length, ops = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            ops[_key - 1] = arguments[_key];
        }

        encoder.encode.apply(encoder, [name].concat(ops));
    };

    OpcodeBuilder.prototype.commit = function commit(heap) {
        this.push(20 /* Return */);
        var buffer = this.encoder.buffer;
        // TODO: change the whole malloc API and do something more efficient

        var handle = heap.malloc();
        for (var i = 0; i < buffer.length; i++) {
            heap.push(buffer[i]);
        }
        heap.finishMalloc(handle, this.containingLayout.block.symbols.length);
        return handle;
    };

    OpcodeBuilder.prototype.setComponentAttrs = function setComponentAttrs(enabled) {
        this.isComponentAttrs = enabled;
    };
    // args


    OpcodeBuilder.prototype.pushArgs = function pushArgs(names, flags) {
        var serialized = this.constants.stringArray(names);
        this.push(61 /* PushArgs */, serialized, flags);
    };
    // helpers


    OpcodeBuilder.prototype.startLabels = function startLabels() {
        this.labelsStack.push(new Labels());
    };

    OpcodeBuilder.prototype.stopLabels = function stopLabels() {
        var label = this.labelsStack.pop();
        label.patch(this.encoder);
    };
    // components


    OpcodeBuilder.prototype.pushComponentDefinition = function pushComponentDefinition(handle) {
        this.push(59 /* PushComponentDefinition */, this.constants.handle(handle));
    };

    OpcodeBuilder.prototype.pushDynamicComponentManager = function pushDynamicComponentManager(referrer) {
        this.push(60 /* PushDynamicComponentManager */, this.constants.serializable(referrer));
    };

    OpcodeBuilder.prototype.prepareArgs = function prepareArgs(state) {
        this.push(63 /* PrepareArgs */, state);
    };

    OpcodeBuilder.prototype.createComponent = function createComponent(state, hasDefault, hasInverse) {
        var flag = (hasDefault === true ? 1 : 0) | (hasInverse === true ? 1 : 0) << 1;
        this.push(64 /* CreateComponent */, flag, state);
    };

    OpcodeBuilder.prototype.registerComponentDestructor = function registerComponentDestructor(state) {
        this.push(65 /* RegisterComponentDestructor */, state);
    };

    OpcodeBuilder.prototype.beginComponentTransaction = function beginComponentTransaction() {
        this.push(71 /* BeginComponentTransaction */);
    };

    OpcodeBuilder.prototype.commitComponentTransaction = function commitComponentTransaction() {
        this.push(72 /* CommitComponentTransaction */);
    };

    OpcodeBuilder.prototype.putComponentOperations = function putComponentOperations() {
        this.push(66 /* PutComponentOperations */);
    };

    OpcodeBuilder.prototype.getComponentSelf = function getComponentSelf(state) {
        this.push(67 /* GetComponentSelf */, state);
    };

    OpcodeBuilder.prototype.getComponentTagName = function getComponentTagName(state) {
        this.push(68 /* GetComponentTagName */, state);
    };

    OpcodeBuilder.prototype.getComponentLayout = function getComponentLayout(state) {
        this.push(69 /* GetComponentLayout */, state);
    };

    OpcodeBuilder.prototype.invokeComponentLayout = function invokeComponentLayout() {
        this.push(70 /* InvokeComponentLayout */);
    };

    OpcodeBuilder.prototype.didCreateElement = function didCreateElement(state) {
        this.push(73 /* DidCreateElement */, state);
    };

    OpcodeBuilder.prototype.didRenderLayout = function didRenderLayout(state) {
        this.push(74 /* DidRenderLayout */, state);
    };
    // partial


    OpcodeBuilder.prototype.invokePartial = function invokePartial(referrer, symbols, evalInfo) {
        var _meta = this.constants.serializable(referrer);
        var _symbols = this.constants.stringArray(symbols);
        var _evalInfo = this.constants.array(evalInfo);
        this.push(75 /* InvokePartial */, _meta, _symbols, _evalInfo);
    };

    OpcodeBuilder.prototype.resolveMaybeLocal = function resolveMaybeLocal(name) {
        this.push(76 /* ResolveMaybeLocal */, this.string(name));
    };
    // debugger


    OpcodeBuilder.prototype.debugger = function _debugger(symbols, evalInfo) {
        this.push(77 /* Debugger */, this.constants.stringArray(symbols), this.constants.array(evalInfo));
    };
    // content


    OpcodeBuilder.prototype.dynamicContent = function dynamicContent(isTrusting) {
        this.push(24 /* DynamicContent */, isTrusting ? 1 : 0);
    };
    // dom


    OpcodeBuilder.prototype.text = function text(_text) {
        this.push(22 /* Text */, this.constants.string(_text));
    };

    OpcodeBuilder.prototype.openPrimitiveElement = function openPrimitiveElement(tag) {
        this.push(25 /* OpenElement */, this.constants.string(tag));
    };

    OpcodeBuilder.prototype.openElementWithOperations = function openElementWithOperations(tag) {
        this.push(26 /* OpenElementWithOperations */, this.constants.string(tag));
    };

    OpcodeBuilder.prototype.openDynamicElement = function openDynamicElement() {
        this.push(27 /* OpenDynamicElement */);
    };

    OpcodeBuilder.prototype.flushElement = function flushElement() {
        this.push(31 /* FlushElement */);
    };

    OpcodeBuilder.prototype.closeElement = function closeElement() {
        this.push(32 /* CloseElement */);
    };

    OpcodeBuilder.prototype.staticAttr = function staticAttr(_name, _namespace, _value) {
        var name = this.constants.string(_name);
        var namespace = _namespace ? this.constants.string(_namespace) : 0;
        if (this.isComponentAttrs) {
            this.pushPrimitiveReference(_value);
            this.push(30 /* ComponentAttr */, name, 1, namespace);
        } else {
            var value = this.constants.string(_value);
            this.push(28 /* StaticAttr */, name, value, namespace);
        }
    };

    OpcodeBuilder.prototype.dynamicAttr = function dynamicAttr(_name, _namespace, trusting) {
        var name = this.constants.string(_name);
        var namespace = _namespace ? this.constants.string(_namespace) : 0;
        if (this.isComponentAttrs) {
            this.push(30 /* ComponentAttr */, name, trusting === true ? 1 : 0, namespace);
        } else {
            this.push(29 /* DynamicAttr */, name, trusting === true ? 1 : 0, namespace);
        }
    };

    OpcodeBuilder.prototype.comment = function comment(_comment) {
        var comment = this.constants.string(_comment);
        this.push(23 /* Comment */, comment);
    };

    OpcodeBuilder.prototype.modifier = function modifier(specifier, params, hash) {
        this.pushFrame();
        this.compileArgs(params, hash, null, true);
        this.push(33 /* Modifier */, this.constants.handle(specifier));
        this.popFrame();
    };
    // lists


    OpcodeBuilder.prototype.putIterator = function putIterator() {
        this.push(55 /* PutIterator */);
    };

    OpcodeBuilder.prototype.enterList = function enterList(start) {
        this.reserve(53 /* EnterList */);
        this.labels.target(this.pos, 53 /* EnterList */, start);
    };

    OpcodeBuilder.prototype.exitList = function exitList() {
        this.push(54 /* ExitList */);
    };

    OpcodeBuilder.prototype.iterate = function iterate(breaks) {
        this.reserve(56 /* Iterate */);
        this.labels.target(this.pos, 56 /* Iterate */, breaks);
    };
    // expressions


    OpcodeBuilder.prototype.setVariable = function setVariable(symbol) {
        this.push(2 /* SetVariable */, symbol);
    };

    OpcodeBuilder.prototype.setBlock = function setBlock(symbol) {
        this.push(3 /* SetBlock */, symbol);
    };

    OpcodeBuilder.prototype.getVariable = function getVariable(symbol) {
        this.push(4 /* GetVariable */, symbol);
    };

    OpcodeBuilder.prototype.getProperty = function getProperty(key) {
        this.push(5 /* GetProperty */, this.string(key));
    };

    OpcodeBuilder.prototype.getBlock = function getBlock(symbol) {
        this.push(6 /* GetBlock */, symbol);
    };

    OpcodeBuilder.prototype.hasBlock = function hasBlock(symbol) {
        this.push(7 /* HasBlock */, symbol);
    };

    OpcodeBuilder.prototype.hasBlockParams = function hasBlockParams(to) {
        this.getBlock(to);
        this.resolveBlock();
        this.push(8 /* HasBlockParams */);
    };

    OpcodeBuilder.prototype.concat = function concat(size) {
        this.push(9 /* Concat */, size);
    };

    OpcodeBuilder.prototype.load = function load(register) {
        this.push(15 /* Load */, register);
    };

    OpcodeBuilder.prototype.fetch = function fetch(register) {
        this.push(16 /* Fetch */, register);
    };

    OpcodeBuilder.prototype.dup = function dup() {
        var register = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Register.sp;
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        return this.push(13 /* Dup */, register, offset);
    };

    OpcodeBuilder.prototype.pop = function pop() {
        var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        return this.push(14 /* Pop */, count);
    };
    // vm


    OpcodeBuilder.prototype.pushRemoteElement = function pushRemoteElement() {
        this.push(34 /* PushRemoteElement */);
    };

    OpcodeBuilder.prototype.popRemoteElement = function popRemoteElement() {
        this.push(35 /* PopRemoteElement */);
    };

    OpcodeBuilder.prototype.label = function label(name) {
        this.labels.label(name, this.nextPos);
    };

    OpcodeBuilder.prototype.pushRootScope = function pushRootScope(symbols, bindCallerScope) {
        this.push(17 /* RootScope */, symbols, bindCallerScope ? 1 : 0);
    };

    OpcodeBuilder.prototype.pushChildScope = function pushChildScope() {
        this.push(18 /* ChildScope */);
    };

    OpcodeBuilder.prototype.popScope = function popScope() {
        this.push(19 /* PopScope */);
    };

    OpcodeBuilder.prototype.returnTo = function returnTo(label) {
        this.reserve(21 /* ReturnTo */);
        this.labels.target(this.pos, 21 /* ReturnTo */, label);
    };

    OpcodeBuilder.prototype.pushDynamicScope = function pushDynamicScope() {
        this.push(37 /* PushDynamicScope */);
    };

    OpcodeBuilder.prototype.popDynamicScope = function popDynamicScope() {
        this.push(38 /* PopDynamicScope */);
    };

    OpcodeBuilder.prototype.primitive = function primitive(_primitive) {
        var type = 0;
        var primitive = void 0;
        switch (typeof _primitive === 'undefined' ? 'undefined' : _typeof(_primitive)) {
            case 'number':
                if (_primitive % 1 === 0) {
                    if (_primitive > -1) {
                        primitive = _primitive;
                    } else {
                        primitive = this.negative(_primitive);
                        type = 4 /* NEGATIVE */;
                    }
                } else {
                    primitive = this.float(_primitive);
                    type = 1 /* FLOAT */;
                }
                break;
            case 'string':
                primitive = this.string(_primitive);
                type = 2 /* STRING */;
                break;
            case 'boolean':
                primitive = _primitive | 0;
                type = 3 /* BOOLEAN_OR_VOID */;
                break;
            case 'object':
                // assume null
                primitive = 2;
                type = 3 /* BOOLEAN_OR_VOID */;
                break;
            case 'undefined':
                primitive = 3;
                type = 3 /* BOOLEAN_OR_VOID */;
                break;
            default:
                throw new Error('Invalid primitive passed to pushPrimitive');
        }
        this.push(11 /* Primitive */, primitive << 3 | type);
    };

    OpcodeBuilder.prototype.float = function float(num) {
        return this.constants.float(num);
    };

    OpcodeBuilder.prototype.negative = function negative(num) {
        return this.constants.negative(num);
    };

    OpcodeBuilder.prototype.pushPrimitiveReference = function pushPrimitiveReference(primitive) {
        this.primitive(primitive);
        this.primitiveReference();
    };

    OpcodeBuilder.prototype.primitiveReference = function primitiveReference() {
        this.push(12 /* PrimitiveReference */);
    };

    OpcodeBuilder.prototype.helper = function helper(_helper, params, hash) {
        this.pushFrame();
        this.compileArgs(params, hash, null, true);
        this.push(1 /* Helper */, this.constants.handle(_helper));
        this.popFrame();
        this.fetch(Register.v0);
    };

    OpcodeBuilder.prototype.bindDynamicScope = function bindDynamicScope(_names) {
        this.push(36 /* BindDynamicScope */, this.names(_names));
    };

    OpcodeBuilder.prototype.enter = function enter(args) {
        this.push(50 /* Enter */, args);
    };

    OpcodeBuilder.prototype.exit = function exit() {
        this.push(51 /* Exit */);
    };

    OpcodeBuilder.prototype.return = function _return() {
        this.push(20 /* Return */);
    };

    OpcodeBuilder.prototype.pushFrame = function pushFrame() {
        this.push(48 /* PushFrame */);
    };

    OpcodeBuilder.prototype.popFrame = function popFrame() {
        this.push(49 /* PopFrame */);
    };

    OpcodeBuilder.prototype.invokeVirtual = function invokeVirtual() {
        this.push(42 /* InvokeVirtual */);
    };

    OpcodeBuilder.prototype.invokeYield = function invokeYield() {
        this.push(44 /* InvokeYield */);
    };

    OpcodeBuilder.prototype.toBoolean = function toBoolean() {
        this.push(52 /* ToBoolean */);
    };

    OpcodeBuilder.prototype.jump = function jump(target) {
        this.reserve(45 /* Jump */);
        this.labels.target(this.pos, 45 /* Jump */, target);
    };

    OpcodeBuilder.prototype.jumpIf = function jumpIf(target) {
        this.reserve(46 /* JumpIf */);
        this.labels.target(this.pos, 46 /* JumpIf */, target);
    };

    OpcodeBuilder.prototype.jumpUnless = function jumpUnless(target) {
        this.reserve(47 /* JumpUnless */);
        this.labels.target(this.pos, 47 /* JumpUnless */, target);
    };
    // internal helpers


    OpcodeBuilder.prototype.string = function string(_string) {
        return this.constants.string(_string);
    };

    OpcodeBuilder.prototype.names = function names(_names) {
        var names = [];
        for (var i = 0; i < _names.length; i++) {
            var n = _names[i];
            names[i] = this.constants.string(n);
        }
        return this.constants.array(names);
    };

    OpcodeBuilder.prototype.symbols = function symbols(_symbols2) {
        return this.constants.array(_symbols2);
    };
    // convenience methods


    OpcodeBuilder.prototype.inlineBlock = function inlineBlock(block) {
        var parameters = block.parameters,
            statements = block.statements;

        var symbolTable = { parameters: parameters, referrer: this.containingLayout.referrer };
        var options = {
            program: this.program,
            macros: this.macros,
            Builder: this.constructor,
            lookup: this.lookup,
            asPartial: this.asPartial,
            referrer: this.referrer
        };
        return new CompilableTemplate(statements, this.containingLayout, options, symbolTable);
    };

    OpcodeBuilder.prototype.evalSymbols = function evalSymbols() {
        var block = this.containingLayout.block;

        return block.hasEval ? block.symbols : null;
    };

    OpcodeBuilder.prototype.compileParams = function compileParams(params) {
        if (!params) return 0;
        for (var i = 0; i < params.length; i++) {
            this.expr(params[i]);
        }
        return params.length;
    };

    OpcodeBuilder.prototype.compileArgs = function compileArgs(params, hash, blocks, synthetic) {
        if (blocks) {
            this.pushYieldableBlock(blocks.main);
            this.pushYieldableBlock(blocks.else);
            this.pushYieldableBlock(blocks.attrs);
        }
        var count = this.compileParams(params);
        var flags = count << 4;
        if (synthetic) flags |= 8;
        if (blocks) {
            flags |= 7;
        }
        var names = EMPTY_ARRAY;
        if (hash) {
            names = hash[0];
            var val = hash[1];
            for (var i = 0; i < val.length; i++) {
                this.expr(val[i]);
            }
        }
        this.pushArgs(names, flags);
    };

    OpcodeBuilder.prototype.invokeStaticBlock = function invokeStaticBlock(block) {
        var callerCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var parameters = block.symbolTable.parameters;

        var calleeCount = parameters.length;
        var count = Math.min(callerCount, calleeCount);
        this.pushFrame();
        if (count) {
            this.pushChildScope();
            for (var i = 0; i < count; i++) {
                this.dup(Register.fp, callerCount - i);
                this.setVariable(parameters[i]);
            }
        }
        this.pushBlock(block);
        this.resolveBlock();
        this.invokeVirtual();
        if (count) {
            this.popScope();
        }
        this.popFrame();
    };

    OpcodeBuilder.prototype.guardedAppend = function guardedAppend(expression, trusting) {
        this.startLabels();
        this.pushFrame();
        this.returnTo('END');
        this.expr(expression);
        this.dup();
        this.isComponent();
        this.enter(2);
        this.jumpUnless('ELSE');
        this.pushDynamicComponentManager(this.referrer);
        this.invokeComponent(null, null, null, false, null, null);
        this.exit();
        this.return();
        this.label('ELSE');
        this.dynamicContent(trusting);
        this.exit();
        this.return();
        this.label('END');
        this.popFrame();
        this.stopLabels();
    };

    OpcodeBuilder.prototype.yield = function _yield(to, params) {
        this.compileArgs(params, null, null, false);
        this.getBlock(to);
        this.resolveBlock();
        this.invokeYield();
        this.popScope();
        this.popFrame();
    };

    OpcodeBuilder.prototype.invokeComponent = function invokeComponent(attrs, params, hash, synthetic, block) {
        var inverse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
        var layout = arguments[6];

        this.fetch(Register.s0);
        this.dup(Register.sp, 1);
        this.load(Register.s0);
        this.pushFrame();
        var blocks = { main: block, else: inverse, attrs: attrs };
        this.compileArgs(params, hash, blocks, synthetic);
        this.prepareArgs(Register.s0);
        this.beginComponentTransaction();
        this.pushDynamicScope();
        this.createComponent(Register.s0, block !== null, inverse !== null);
        this.registerComponentDestructor(Register.s0);
        this.getComponentSelf(Register.s0);
        if (layout) {
            this.pushSymbolTable(layout.symbolTable);
            this.pushLayout(layout);
            this.resolveLayout();
        } else {
            this.getComponentLayout(Register.s0);
        }
        this.invokeComponentLayout();
        this.didRenderLayout(Register.s0);
        this.popFrame();
        this.popScope();
        this.popDynamicScope();
        this.commitComponentTransaction();
        this.load(Register.s0);
    };

    OpcodeBuilder.prototype.invokeStaticComponent = function invokeStaticComponent(capabilities, layout, attrs, params, hash, synthetic, block) {
        var inverse = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
        var symbolTable = layout.symbolTable;

        var bailOut = symbolTable.hasEval || capabilities.prepareArgs;
        if (bailOut) {
            this.invokeComponent(attrs, params, hash, synthetic, block, inverse, layout);
            return;
        }
        this.fetch(Register.s0);
        this.dup(Register.sp, 1);
        this.load(Register.s0);
        var symbols = symbolTable.symbols;

        if (capabilities.createArgs) {
            this.pushFrame();
            this.compileArgs(null, hash, null, synthetic);
        }
        this.beginComponentTransaction();
        this.pushDynamicScope();
        this.createComponent(Register.s0, block !== null, inverse !== null);
        if (capabilities.createArgs) {
            this.popFrame();
        }
        this.registerComponentDestructor(Register.s0);
        var bindings = [];
        this.getComponentSelf(Register.s0);
        bindings.push({ symbol: 0, isBlock: false });
        for (var i = 0; i < symbols.length; i++) {
            var symbol = symbols[i];
            switch (symbol.charAt(0)) {
                case '&':
                    var callerBlock = null;
                    if (symbol === '&default') {
                        callerBlock = block;
                    } else if (symbol === '&inverse') {
                        callerBlock = inverse;
                    } else if (symbol === ATTRS_BLOCK) {
                        callerBlock = attrs;
                    } else {
                        throw unreachable();
                    }
                    if (callerBlock) {
                        this.pushYieldableBlock(callerBlock);
                        bindings.push({ symbol: i + 1, isBlock: true });
                    } else {
                        this.pushYieldableBlock(null);
                        bindings.push({ symbol: i + 1, isBlock: true });
                    }
                    break;
                case '@':
                    if (!hash) {
                        break;
                    }
                    var keys = hash[0],
                        values = hash[1];

                    var lookupName = symbol;
                    if (synthetic) {
                        lookupName = symbol.slice(1);
                    }
                    var index = keys.indexOf(lookupName);
                    if (index !== -1) {
                        this.expr(values[index]);
                        bindings.push({ symbol: i + 1, isBlock: false });
                    }
                    break;
            }
        }
        this.pushRootScope(symbols.length + 1, !!(block || inverse || attrs));
        for (var _i = bindings.length - 1; _i >= 0; _i--) {
            var _bindings$_i = bindings[_i],
                _symbol = _bindings$_i.symbol,
                isBlock = _bindings$_i.isBlock;

            if (isBlock) {
                this.setBlock(_symbol);
            } else {
                this.setVariable(_symbol);
            }
        }
        this.pushFrame();
        this.invokeStatic(layout);
        this.didRenderLayout(Register.s0);
        this.popFrame();
        this.popScope();
        this.popDynamicScope();
        this.commitComponentTransaction();
        this.load(Register.s0);
    };

    OpcodeBuilder.prototype.dynamicComponent = function dynamicComponent(definition, /* TODO: attrs: Option<RawInlineBlock>, */params, hash, synthetic, block) {
        var inverse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

        this.startLabels();
        this.pushFrame();
        this.returnTo('END');
        this.expr(definition);
        this.dup();
        this.enter(2);
        this.jumpUnless('ELSE');
        this.pushDynamicComponentManager(this.referrer);
        this.invokeComponent(null, params, hash, synthetic, block, inverse);
        this.label('ELSE');
        this.exit();
        this.return();
        this.label('END');
        this.popFrame();
        this.stopLabels();
    };

    OpcodeBuilder.prototype.isComponent = function isComponent() {
        this.push(57 /* IsComponent */);
    };

    OpcodeBuilder.prototype.curryComponent = function curryComponent(definition, /* TODO: attrs: Option<RawInlineBlock>, */params, hash, synthetic) {
        var referrer = this.referrer;
        this.pushFrame();
        this.compileArgs(params, hash, null, synthetic);
        this.expr(definition);
        this.push(58 /* CurryComponent */, this.constants.serializable(referrer));
        this.popFrame();
        this.fetch(Register.v0);
    };

    OpcodeBuilder.prototype.pushSymbolTable = function pushSymbolTable(table) {
        if (table) {
            var constant = this.constants.table(table);
            this.push(41 /* PushSymbolTable */, constant);
        } else {
            this.primitive(null);
        }
    };

    OpcodeBuilder.prototype.pushBlockScope = function pushBlockScope() {
        this.push(40 /* PushBlockScope */);
    };

    OpcodeBuilder.prototype.pushYieldableBlock = function pushYieldableBlock(block) {
        this.pushSymbolTable(block && block.symbolTable);
        this.pushBlockScope();
        this.pushBlock(block);
    };

    OpcodeBuilder.prototype.template = function template(block) {
        if (!block) return null;
        return this.inlineBlock(block);
    };

    createClass(OpcodeBuilder, [{
        key: 'pos',
        get: function get$$1() {
            return this.encoder.typePos;
        }
    }, {
        key: 'nextPos',
        get: function get$$1() {
            return this.encoder.size;
        }
    }, {
        key: 'labels',
        get: function get$$1() {
            return this.labelsStack.current;
        }
    }]);
    return OpcodeBuilder;
}();

var LazyOpcodeBuilder = function (_OpcodeBuilder) {
    inherits(LazyOpcodeBuilder, _OpcodeBuilder);

    function LazyOpcodeBuilder() {
        classCallCheck(this, LazyOpcodeBuilder);
        return possibleConstructorReturn(this, _OpcodeBuilder.apply(this, arguments));
    }

    LazyOpcodeBuilder.prototype.pushBlock = function pushBlock(block) {
        if (block) {
            this.pushOther(block);
        } else {
            this.primitive(null);
        }
    };

    LazyOpcodeBuilder.prototype.resolveBlock = function resolveBlock() {
        this.push(39 /* CompileBlock */);
    };

    LazyOpcodeBuilder.prototype.pushLayout = function pushLayout(layout) {
        if (layout) {
            this.pushOther(layout);
        } else {
            this.primitive(null);
        }
    };

    LazyOpcodeBuilder.prototype.resolveLayout = function resolveLayout() {
        this.push(39 /* CompileBlock */);
    };

    LazyOpcodeBuilder.prototype.invokeStatic = function invokeStatic(compilable) {
        this.pushOther(compilable);
        this.push(39 /* CompileBlock */);
        this.push(42 /* InvokeVirtual */);
    };

    LazyOpcodeBuilder.prototype.pushOther = function pushOther(value) {
        this.push(10 /* Constant */, this.other(value));
    };

    LazyOpcodeBuilder.prototype.other = function other(value) {
        return this.constants.other(value);
    };

    return LazyOpcodeBuilder;
}(OpcodeBuilder);
var EagerOpcodeBuilder = function (_OpcodeBuilder2) {
    inherits(EagerOpcodeBuilder, _OpcodeBuilder2);

    function EagerOpcodeBuilder() {
        classCallCheck(this, EagerOpcodeBuilder);
        return possibleConstructorReturn(this, _OpcodeBuilder2.apply(this, arguments));
    }

    EagerOpcodeBuilder.prototype.pushBlock = function pushBlock(block) {
        var handle = block ? block.compile() : null;
        this.primitive(handle);
    };

    EagerOpcodeBuilder.prototype.resolveBlock = function resolveBlock() {
        return;
    };

    EagerOpcodeBuilder.prototype.pushLayout = function pushLayout(layout) {
        if (layout) {
            this.primitive(layout.compile());
        } else {
            this.primitive(null);
        }
    };

    EagerOpcodeBuilder.prototype.resolveLayout = function resolveLayout() {};

    EagerOpcodeBuilder.prototype.invokeStatic = function invokeStatic(compilable) {
        var handle = compilable.compile();
        this.push(43 /* InvokeStatic */, handle);
    };

    return EagerOpcodeBuilder;
}(OpcodeBuilder);

var Arguments = function () {
    function Arguments() {
        classCallCheck(this, Arguments);

        this.stack = null;
        this.positional = new PositionalArguments();
        this.named = new NamedArguments();
        this.blocks = new BlockArguments();
    }

    Arguments.prototype.setup = function setup(stack, names, blockNames, positionalCount, synthetic) {
        this.stack = stack;
        /*
               | ... | blocks      | positional  | named |
               | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |
         index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |
                       ^             ^             ^  ^
                     bbase         pbase       nbase  sp
        */
        var named = this.named;
        var namedCount = names.length;
        var namedBase = stack.sp - namedCount + 1;
        named.setup(stack, namedBase, namedCount, names, synthetic);
        var positional = this.positional;
        var positionalBase = namedBase - positionalCount;
        positional.setup(stack, positionalBase, positionalCount);
        var blocks = this.blocks;
        var blocksCount = blockNames.length;
        var blocksBase = positionalBase - blocksCount * 3;
        blocks.setup(stack, blocksBase, blocksCount, blockNames);
    };

    Arguments.prototype.at = function at(pos) {
        return this.positional.at(pos);
    };

    Arguments.prototype.realloc = function realloc(offset) {
        if (offset > 0) {
            var positional = this.positional,
                named = this.named,
                stack = this.stack;

            var newBase = positional.base + offset;
            var length = positional.length + named.length;
            for (var i = length - 1; i >= 0; i--) {
                stack.set(stack.get(i, positional.base), i, newBase);
            }
            positional.base += offset;
            named.base += offset;
            stack.sp += offset;
        }
    };

    Arguments.prototype.capture = function capture() {
        var positional = this.positional.length === 0 ? EMPTY_POSITIONAL : this.positional.capture();
        var named = this.named.length === 0 ? EMPTY_NAMED : this.named.capture();
        return {
            tag: this.tag,
            length: this.length,
            positional: positional,
            named: named
        };
    };

    Arguments.prototype.clear = function clear() {
        var stack = this.stack,
            length = this.length;

        stack.pop(length);
    };

    createClass(Arguments, [{
        key: 'tag',
        get: function get$$1() {
            return combineTagged([this.positional, this.named]);
        }
    }, {
        key: 'base',
        get: function get$$1() {
            return this.blocks.base;
        }
    }, {
        key: 'length',
        get: function get$$1() {
            return this.positional.length + this.named.length + this.blocks.length * 3;
        }
    }]);
    return Arguments;
}();
var PositionalArguments = function () {
    function PositionalArguments() {
        classCallCheck(this, PositionalArguments);

        this.base = 0;
        this.length = 0;
        this.stack = null;
        this._tag = null;
        this._references = null;
    }

    PositionalArguments.prototype.setup = function setup(stack, base, length) {
        this.stack = stack;
        this.base = base;
        this.length = length;
        if (length === 0) {
            this._tag = CONSTANT_TAG;
            this._references = EMPTY_ARRAY;
        } else {
            this._tag = null;
            this._references = null;
        }
    };

    PositionalArguments.prototype.at = function at(position) {
        var base = this.base,
            length = this.length,
            stack = this.stack;

        if (position < 0 || position >= length) {
            return UNDEFINED_REFERENCE;
        }
        return stack.get(position, base);
    };

    PositionalArguments.prototype.capture = function capture() {
        return new CapturedPositionalArguments(this.tag, this.references);
    };

    PositionalArguments.prototype.prepend = function prepend(other) {
        var additions = other.length;
        if (additions > 0) {
            var base = this.base,
                length = this.length,
                stack = this.stack;

            this.base = base = base - additions;
            this.length = length + additions;
            for (var i = 0; i < additions; i++) {
                stack.set(other.at(i), i, base);
            }
            this._tag = null;
            this._references = null;
        }
    };

    createClass(PositionalArguments, [{
        key: 'tag',
        get: function get$$1() {
            var tag = this._tag;
            if (!tag) {
                tag = this._tag = combineTagged(this.references);
            }
            return tag;
        }
    }, {
        key: 'references',
        get: function get$$1() {
            var references = this._references;
            if (!references) {
                var stack = this.stack,
                    base = this.base,
                    length = this.length;

                references = this._references = stack.slice(base, base + length);
            }
            return references;
        }
    }]);
    return PositionalArguments;
}();

var CapturedPositionalArguments = function () {
    function CapturedPositionalArguments(tag, references) {
        var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : references.length;
        classCallCheck(this, CapturedPositionalArguments);

        this.tag = tag;
        this.references = references;
        this.length = length;
    }

    CapturedPositionalArguments.empty = function empty() {
        return new CapturedPositionalArguments(CONSTANT_TAG, EMPTY_ARRAY, 0);
    };

    CapturedPositionalArguments.prototype.at = function at(position) {
        return this.references[position];
    };

    CapturedPositionalArguments.prototype.value = function value() {
        return this.references.map(this.valueOf);
    };

    CapturedPositionalArguments.prototype.get = function get$$1(name) {
        var references = this.references,
            length = this.length;

        if (name === 'length') {
            return PrimitiveReference.create(length);
        } else {
            var idx = parseInt(name, 10);
            if (idx < 0 || idx >= length) {
                return UNDEFINED_REFERENCE;
            } else {
                return references[idx];
            }
        }
    };

    CapturedPositionalArguments.prototype.valueOf = function valueOf(reference) {
        return reference.value();
    };

    return CapturedPositionalArguments;
}();

var NamedArguments = function () {
    function NamedArguments() {
        classCallCheck(this, NamedArguments);

        this.base = 0;
        this.length = 0;
        this._tag = null;
        this._references = null;
        this._names = EMPTY_ARRAY;
        this._atNames = EMPTY_ARRAY;
    }

    NamedArguments.prototype.setup = function setup(stack, base, length, names, synthetic) {
        this.stack = stack;
        this.base = base;
        this.length = length;
        if (length === 0) {
            this._tag = CONSTANT_TAG;
            this._references = EMPTY_ARRAY;
            this._names = EMPTY_ARRAY;
            this._atNames = EMPTY_ARRAY;
        } else {
            this._tag = null;
            this._references = null;
            if (synthetic) {
                this._names = names;
                this._atNames = null;
            } else {
                this._names = null;
                this._atNames = names;
            }
        }
    };

    NamedArguments.prototype.has = function has(name) {
        return this.names.indexOf(name) !== -1;
    };

    NamedArguments.prototype.get = function get$$1(name) {
        var synthetic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var base = this.base,
            stack = this.stack;

        var names = synthetic ? this.names : this.atNames;
        var idx = names.indexOf(name);
        if (idx === -1) {
            return UNDEFINED_REFERENCE;
        }
        return stack.get(idx, base);
    };

    NamedArguments.prototype.capture = function capture() {
        return new CapturedNamedArguments(this.tag, this.names, this.references);
    };

    NamedArguments.prototype.merge = function merge(other) {
        var extras = other.length;

        if (extras > 0) {
            var names = this.names,
                length = this.length,
                stack = this.stack;
            var extraNames = other.names;

            if (Object.isFrozen(names) && names.length === 0) {
                names = [];
            }
            for (var i = 0; i < extras; i++) {
                var name = extraNames[i];
                var idx = names.indexOf(name);
                if (idx === -1) {
                    length = names.push(name);
                    stack.push(other.references[i]);
                }
            }
            this.length = length;
            this._tag = null;
            this._references = null;
            this._names = names;
            this._atNames = null;
        }
    };

    NamedArguments.prototype.toSyntheticName = function toSyntheticName(name) {
        return name.slice(1);
    };

    NamedArguments.prototype.toAtName = function toAtName(name) {
        return '@' + name;
    };

    createClass(NamedArguments, [{
        key: 'tag',
        get: function get$$1() {
            return combineTagged(this.references);
        }
    }, {
        key: 'names',
        get: function get$$1() {
            var names = this._names;
            if (!names) {
                names = this._names = this._atNames.map(this.toSyntheticName);
            }
            return names;
        }
    }, {
        key: 'atNames',
        get: function get$$1() {
            var atNames = this._atNames;
            if (!atNames) {
                atNames = this._atNames = this._names.map(this.toAtName);
            }
            return atNames;
        }
    }, {
        key: 'references',
        get: function get$$1() {
            var references = this._references;
            if (!references) {
                var base = this.base,
                    length = this.length,
                    stack = this.stack;

                references = this._references = stack.slice(base, base + length);
            }
            return references;
        }
    }]);
    return NamedArguments;
}();

var CapturedNamedArguments = function () {
    function CapturedNamedArguments(tag, names, references) {
        classCallCheck(this, CapturedNamedArguments);

        this.tag = tag;
        this.names = names;
        this.references = references;
        this.length = names.length;
        this._map = null;
    }

    CapturedNamedArguments.prototype.has = function has(name) {
        return this.names.indexOf(name) !== -1;
    };

    CapturedNamedArguments.prototype.get = function get$$1(name) {
        var names = this.names,
            references = this.references;

        var idx = names.indexOf(name);
        if (idx === -1) {
            return UNDEFINED_REFERENCE;
        } else {
            return references[idx];
        }
    };

    CapturedNamedArguments.prototype.value = function value() {
        var names = this.names,
            references = this.references;

        var out = dict();
        for (var i = 0; i < names.length; i++) {
            var name = names[i];
            out[name] = references[i].value();
        }
        return out;
    };

    createClass(CapturedNamedArguments, [{
        key: 'map',
        get: function get$$1() {
            var map$$1 = this._map;
            if (!map$$1) {
                var names = this.names,
                    references = this.references;

                map$$1 = this._map = dict();
                for (var i = 0; i < names.length; i++) {
                    var name = names[i];
                    map$$1[name] = references[i];
                }
            }
            return map$$1;
        }
    }]);
    return CapturedNamedArguments;
}();

var BlockArguments = function () {
    function BlockArguments() {
        classCallCheck(this, BlockArguments);

        this.internalValues = null;
        this.internalTag = null;
        this.names = EMPTY_ARRAY;
        this.length = 0;
        this.base = 0;
    }

    BlockArguments.prototype.setup = function setup(stack, base, length, names) {
        this.stack = stack;
        this.names = names;
        this.base = base;
        this.length = length;
        if (length === 0) {
            this.internalTag = CONSTANT_TAG;
            this.internalValues = EMPTY_ARRAY;
        } else {
            this.internalTag = null;
            this.internalValues = null;
        }
    };

    BlockArguments.prototype.has = function has(name) {
        return this.names.indexOf(name) !== -1;
    };

    BlockArguments.prototype.get = function get$$1(name) {
        var base = this.base,
            stack = this.stack,
            names = this.names;

        var idx = names.indexOf(name);
        if (names.indexOf(name) === -1) {
            return null;
        }
        var table = stack.get(idx * 3, base);
        var scope = stack.get(idx * 3 + 1, base); // FIXME(mmun): shouldn't need to cast this
        var handle = stack.get(idx * 3 + 2, base);
        return handle === null ? null : [handle, scope, table];
    };

    BlockArguments.prototype.capture = function capture() {
        return new CapturedBlockArguments(this.names, this.values);
    };

    createClass(BlockArguments, [{
        key: 'values',
        get: function get$$1() {
            var values = this.internalValues;
            if (!values) {
                var base = this.base,
                    length = this.length,
                    stack = this.stack;

                values = this.internalValues = stack.slice(base, base + length * 3);
            }
            return values;
        }
    }]);
    return BlockArguments;
}();

var CapturedBlockArguments = function () {
    function CapturedBlockArguments(names, values) {
        classCallCheck(this, CapturedBlockArguments);

        this.names = names;
        this.values = values;
        this.length = names.length;
    }

    CapturedBlockArguments.prototype.has = function has(name) {
        return this.names.indexOf(name) !== -1;
    };

    CapturedBlockArguments.prototype.get = function get$$1(name) {
        var idx = this.names.indexOf(name);
        if (idx === -1) return null;
        return [this.values[idx * 3 + 2], this.values[idx * 3 + 1], this.values[idx * 3]];
    };

    return CapturedBlockArguments;
}();

var EMPTY_NAMED = new CapturedNamedArguments(CONSTANT_TAG, EMPTY_ARRAY, EMPTY_ARRAY);
var EMPTY_POSITIONAL = new CapturedPositionalArguments(CONSTANT_TAG, EMPTY_ARRAY);
var EMPTY_ARGS = { tag: CONSTANT_TAG, length: 0, positional: EMPTY_POSITIONAL, named: EMPTY_NAMED };

var CURRIED_COMPONENT_DEFINITION_BRAND = 'CURRIED COMPONENT DEFINITION [id=6f00feb9-a0ef-4547-99ea-ac328f80acea]';
function isCurriedComponentDefinition(definition) {
    return !!(definition && definition[CURRIED_COMPONENT_DEFINITION_BRAND]);
}

var CurriedComponentDefinition = function () {
    /** @internal */
    function CurriedComponentDefinition(inner, args) {
        classCallCheck(this, CurriedComponentDefinition);

        this.inner = inner;
        this.args = args;
        this[CURRIED_COMPONENT_DEFINITION_BRAND] = true;
    }

    CurriedComponentDefinition.prototype.unwrap = function unwrap(args) {
        args.realloc(this.offset);
        var definition = this;
        while (true) {
            var _definition = definition,
                curriedArgs = _definition.args,
                inner = _definition.inner;

            if (curriedArgs) {
                args.positional.prepend(curriedArgs.positional);
                args.named.merge(curriedArgs.named);
            }
            if (!isCurriedComponentDefinition(inner)) {
                return inner;
            }
            definition = inner;
        }
    };
    /** @internal */


    createClass(CurriedComponentDefinition, [{
        key: 'offset',
        get: function get$$1() {
            var inner = this.inner,
                args = this.args;

            var length = args ? args.positional.length : 0;
            return isCurriedComponentDefinition(inner) ? length + inner.offset : length;
        }
    }]);
    return CurriedComponentDefinition;
}();

var IsCurriedComponentDefinitionReference = function (_ConditionalReference) {
    inherits(IsCurriedComponentDefinitionReference, _ConditionalReference);

    function IsCurriedComponentDefinitionReference() {
        classCallCheck(this, IsCurriedComponentDefinitionReference);
        return possibleConstructorReturn(this, _ConditionalReference.apply(this, arguments));
    }

    IsCurriedComponentDefinitionReference.create = function create(inner) {
        return new IsCurriedComponentDefinitionReference(inner);
    };

    IsCurriedComponentDefinitionReference.prototype.toBool = function toBool(value) {
        return isCurriedComponentDefinition(value);
    };

    return IsCurriedComponentDefinitionReference;
}(ConditionalReference$1);
APPEND_OPCODES.add(24 /* DynamicContent */, function (vm, _ref) {
    var isTrusting = _ref.op1;

    var reference = vm.stack.pop();
    var value = reference.value();
    var content = void 0;
    if (isTrusting) {
        content = vm.elements().appendTrustingDynamicContent(value);
    } else {
        content = vm.elements().appendCautiousDynamicContent(value);
    }
    if (!isConst(reference)) {
        vm.updateWith(new UpdateDynamicContentOpcode(reference, content));
    }
});

var UpdateDynamicContentOpcode = function (_UpdatingOpcode) {
    inherits(UpdateDynamicContentOpcode, _UpdatingOpcode);

    function UpdateDynamicContentOpcode(reference, content) {
        classCallCheck(this, UpdateDynamicContentOpcode);

        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this2.reference = reference;
        _this2.content = content;
        _this2.tag = reference.tag;
        return _this2;
    }

    UpdateDynamicContentOpcode.prototype.evaluate = function evaluate(vm) {
        var content = this.content,
            reference = this.reference;

        content.update(vm.env, reference.value());
    };

    return UpdateDynamicContentOpcode;
}(UpdatingOpcode);

APPEND_OPCODES.add(18 /* ChildScope */, function (vm) {
    return vm.pushChildScope();
});
APPEND_OPCODES.add(19 /* PopScope */, function (vm) {
    return vm.popScope();
});
APPEND_OPCODES.add(37 /* PushDynamicScope */, function (vm) {
    return vm.pushDynamicScope();
});
APPEND_OPCODES.add(38 /* PopDynamicScope */, function (vm) {
    return vm.popDynamicScope();
});
APPEND_OPCODES.add(10 /* Constant */, function (vm, _ref) {
    var other = _ref.op1;

    vm.stack.push(vm.constants.getOther(other));
});
APPEND_OPCODES.add(11 /* Primitive */, function (vm, _ref2) {
    var primitive = _ref2.op1;

    var stack = vm.stack;
    var flag = primitive & 7; // 111
    var value = primitive >> 3;
    switch (flag) {
        case 0 /* NUMBER */:
            stack.push(value);
            break;
        case 1 /* FLOAT */:
            stack.push(vm.constants.getFloat(value));
            break;
        case 2 /* STRING */:
            stack.push(vm.constants.getString(value));
            break;
        case 3 /* BOOLEAN_OR_VOID */:
            switch (value) {
                case 0:
                    stack.push(false);
                    break;
                case 1:
                    stack.push(true);
                    break;
                case 2:
                    stack.push(null);
                    break;
                case 3:
                    stack.push(undefined);
                    break;
            }
            break;
        case 4 /* NEGATIVE */:
            stack.push(vm.constants.getNegative(value));
            break;
    }
});
APPEND_OPCODES.add(12 /* PrimitiveReference */, function (vm) {
    var stack = vm.stack;
    stack.push(PrimitiveReference.create(stack.pop()));
});
APPEND_OPCODES.add(13 /* Dup */, function (vm, _ref3) {
    var register = _ref3.op1,
        offset = _ref3.op2;

    var position = vm.fetchValue(register) - offset;
    vm.stack.dup(position);
});
APPEND_OPCODES.add(14 /* Pop */, function (vm, _ref4) {
    var count = _ref4.op1;

    vm.stack.pop(count);
});
APPEND_OPCODES.add(15 /* Load */, function (vm, _ref5) {
    var register = _ref5.op1;

    vm.load(register);
});
APPEND_OPCODES.add(16 /* Fetch */, function (vm, _ref6) {
    var register = _ref6.op1;

    vm.fetch(register);
});
APPEND_OPCODES.add(36 /* BindDynamicScope */, function (vm, _ref7) {
    var _names = _ref7.op1;

    var names = vm.constants.getArray(_names);
    vm.bindDynamicScope(names);
});
APPEND_OPCODES.add(48 /* PushFrame */, function (vm) {
    vm.pushFrame();
});
APPEND_OPCODES.add(49 /* PopFrame */, function (vm) {
    vm.popFrame();
});
APPEND_OPCODES.add(50 /* Enter */, function (vm, _ref8) {
    var args = _ref8.op1;

    vm.enter(args);
});
APPEND_OPCODES.add(51 /* Exit */, function (vm) {
    vm.exit();
});
APPEND_OPCODES.add(41 /* PushSymbolTable */, function (vm, _ref9) {
    var _table = _ref9.op1;

    var stack = vm.stack;
    stack.push(vm.constants.getSymbolTable(_table));
});
APPEND_OPCODES.add(40 /* PushBlockScope */, function (vm) {
    var stack = vm.stack;
    stack.push(vm.scope());
});
APPEND_OPCODES.add(39 /* CompileBlock */, function (vm) {
    var stack = vm.stack;
    var block = stack.pop();
    stack.push(block ? block.compile() : null);
});
APPEND_OPCODES.add(42 /* InvokeVirtual */, function (vm) {
    vm.call(vm.stack.pop());
});
APPEND_OPCODES.add(43 /* InvokeStatic */, function (vm, _ref10) {
    var handle = _ref10.op1;

    vm.call(handle);
});
APPEND_OPCODES.add(44 /* InvokeYield */, function (vm) {
    var stack = vm.stack;

    var handle = stack.pop();
    var scope = stack.pop(); // FIXME(mmun): shouldn't need to cast this
    var table = stack.pop();
    false && debugAssert(table === null || table && (typeof table === 'undefined' ? 'undefined' : _typeof(table)) === 'object' && Array.isArray(table.parameters), stackAssert('Option<BlockSymbolTable>', table));

    var args = stack.pop();
    if (table === null) {
        // To balance the pop{Frame,Scope}
        vm.pushFrame();
        vm.pushScope(scope); // Could be null but it doesnt matter as it is immediatelly popped.
        return;
    }
    var invokingScope = scope;
    // If necessary, create a child scope
    {
        var locals = table.parameters;
        var localsCount = locals.length;
        if (localsCount > 0) {
            invokingScope = invokingScope.child();
            for (var i = 0; i < localsCount; i++) {
                invokingScope.bindSymbol(locals[i], args.at(i));
            }
        }
    }
    vm.pushFrame();
    vm.pushScope(invokingScope);
    vm.call(handle);
});
APPEND_OPCODES.add(45 /* Jump */, function (vm, _ref11) {
    var target = _ref11.op1;

    vm.goto(target);
});
APPEND_OPCODES.add(46 /* JumpIf */, function (vm, _ref12) {
    var target = _ref12.op1;

    var reference = vm.stack.pop();
    if (isConst(reference)) {
        if (reference.value()) {
            vm.goto(target);
        }
    } else {
        var cache = new ReferenceCache(reference);
        if (cache.peek()) {
            vm.goto(target);
        }
        vm.updateWith(new Assert(cache));
    }
});
APPEND_OPCODES.add(47 /* JumpUnless */, function (vm, _ref13) {
    var target = _ref13.op1;

    var reference = vm.stack.pop();
    if (isConst(reference)) {
        if (!reference.value()) {
            vm.goto(target);
        }
    } else {
        var cache = new ReferenceCache(reference);
        if (!cache.peek()) {
            vm.goto(target);
        }
        vm.updateWith(new Assert(cache));
    }
});
APPEND_OPCODES.add(20 /* Return */, function (vm) {
    vm.return();
});
APPEND_OPCODES.add(21 /* ReturnTo */, function (vm, _ref14) {
    var relative = _ref14.op1;

    vm.returnTo(relative);
});
APPEND_OPCODES.add(52 /* ToBoolean */, function (vm) {
    var env = vm.env,
        stack = vm.stack;

    stack.push(env.toConditionalReference(stack.pop()));
});
var Assert = function (_UpdatingOpcode) {
    inherits(Assert, _UpdatingOpcode);

    function Assert(cache) {
        classCallCheck(this, Assert);

        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.type = 'assert';
        _this.tag = cache.tag;
        _this.cache = cache;
        return _this;
    }

    Assert.prototype.evaluate = function evaluate(vm) {
        var cache = this.cache;

        if (isModified(cache.revalidate())) {
            vm.throw();
        }
    };

    return Assert;
}(UpdatingOpcode);
var JumpIfNotModifiedOpcode = function (_UpdatingOpcode2) {
    inherits(JumpIfNotModifiedOpcode, _UpdatingOpcode2);

    function JumpIfNotModifiedOpcode(tag, target) {
        classCallCheck(this, JumpIfNotModifiedOpcode);

        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));

        _this2.target = target;
        _this2.type = 'jump-if-not-modified';
        _this2.tag = tag;
        _this2.lastRevision = tag.value();
        return _this2;
    }

    JumpIfNotModifiedOpcode.prototype.evaluate = function evaluate(vm) {
        var tag = this.tag,
            target = this.target,
            lastRevision = this.lastRevision;

        if (!vm.alwaysRevalidate && tag.validate(lastRevision)) {
            vm.goto(target);
        }
    };

    JumpIfNotModifiedOpcode.prototype.didModify = function didModify() {
        this.lastRevision = this.tag.value();
    };

    return JumpIfNotModifiedOpcode;
}(UpdatingOpcode);
var DidModifyOpcode = function (_UpdatingOpcode3) {
    inherits(DidModifyOpcode, _UpdatingOpcode3);

    function DidModifyOpcode(target) {
        classCallCheck(this, DidModifyOpcode);

        var _this3 = possibleConstructorReturn(this, _UpdatingOpcode3.call(this));

        _this3.target = target;
        _this3.type = 'did-modify';
        _this3.tag = CONSTANT_TAG;
        return _this3;
    }

    DidModifyOpcode.prototype.evaluate = function evaluate() {
        this.target.didModify();
    };

    return DidModifyOpcode;
}(UpdatingOpcode);
var LabelOpcode = function () {
    function LabelOpcode(label) {
        classCallCheck(this, LabelOpcode);

        this.tag = CONSTANT_TAG;
        this.type = 'label';
        this.label = null;
        this.prev = null;
        this.next = null;
        initializeGuid(this);
        this.label = label;
    }

    LabelOpcode.prototype.evaluate = function evaluate() {};

    LabelOpcode.prototype.inspect = function inspect() {
        return this.label + ' [' + this._guid + ']';
    };

    return LabelOpcode;
}();

APPEND_OPCODES.add(22 /* Text */, function (vm, _ref) {
    var text = _ref.op1;

    vm.elements().appendText(vm.constants.getString(text));
});
APPEND_OPCODES.add(26 /* OpenElementWithOperations */, function (vm, _ref2) {
    var tag = _ref2.op1;

    var tagName = vm.constants.getString(tag);
    vm.elements().openElement(tagName);
});
APPEND_OPCODES.add(23 /* Comment */, function (vm, _ref3) {
    var text = _ref3.op1;

    vm.elements().appendComment(vm.constants.getString(text));
});
APPEND_OPCODES.add(25 /* OpenElement */, function (vm, _ref4) {
    var tag = _ref4.op1;

    vm.elements().openElement(vm.constants.getString(tag));
});
APPEND_OPCODES.add(27 /* OpenDynamicElement */, function (vm) {
    var tagName = vm.stack.pop().value();
    vm.elements().openElement(tagName);
});
APPEND_OPCODES.add(34 /* PushRemoteElement */, function (vm) {
    var elementRef = vm.stack.pop();
    var nextSiblingRef = vm.stack.pop();
    var guidRef = vm.stack.pop();
    var element = void 0;
    var nextSibling = void 0;
    var guid = guidRef.value();
    if (isConst(elementRef)) {
        element = elementRef.value();
    } else {
        var cache = new ReferenceCache(elementRef);
        element = cache.peek();
        vm.updateWith(new Assert(cache));
    }
    if (isConst(nextSiblingRef)) {
        nextSibling = nextSiblingRef.value();
    } else {
        var _cache = new ReferenceCache(nextSiblingRef);
        nextSibling = _cache.peek();
        vm.updateWith(new Assert(_cache));
    }
    vm.elements().pushRemoteElement(element, guid, nextSibling);
});
APPEND_OPCODES.add(35 /* PopRemoteElement */, function (vm) {
    vm.elements().popRemoteElement();
});
APPEND_OPCODES.add(31 /* FlushElement */, function (vm) {
    var operations = vm.fetchValue(Register.t0);
    if (operations) {
        operations.flush(vm);
        vm.loadValue(Register.t0, null);
    }
    vm.elements().flushElement();
});
APPEND_OPCODES.add(32 /* CloseElement */, function (vm) {
    vm.elements().closeElement();
});
APPEND_OPCODES.add(33 /* Modifier */, function (vm, _ref5) {
    var handle = _ref5.op1;

    var manager = vm.constants.resolveHandle(handle);
    var stack = vm.stack;
    var args = stack.pop();

    var _vm$elements = vm.elements(),
        element = _vm$elements.constructing,
        updateOperations = _vm$elements.updateOperations;

    var dynamicScope = vm.dynamicScope();
    var modifier = manager.create(element, args, dynamicScope, updateOperations);
    vm.env.scheduleInstallModifier(modifier, manager);
    var destructor = manager.getDestructor(modifier);
    if (destructor) {
        vm.newDestroyable(destructor);
    }
    var tag = manager.getTag(modifier);
    if (!isConstTag(tag)) {
        vm.updateWith(new UpdateModifierOpcode(tag, manager, modifier));
    }
});
var UpdateModifierOpcode = function (_UpdatingOpcode) {
    inherits(UpdateModifierOpcode, _UpdatingOpcode);

    function UpdateModifierOpcode(tag, manager, modifier) {
        classCallCheck(this, UpdateModifierOpcode);

        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.tag = tag;
        _this.manager = manager;
        _this.modifier = modifier;
        _this.type = 'update-modifier';
        _this.lastUpdated = tag.value();
        return _this;
    }

    UpdateModifierOpcode.prototype.evaluate = function evaluate(vm) {
        var manager = this.manager,
            modifier = this.modifier,
            tag = this.tag,
            lastUpdated = this.lastUpdated;

        if (!tag.validate(lastUpdated)) {
            vm.env.scheduleUpdateModifier(modifier, manager);
            this.lastUpdated = tag.value();
        }
    };

    return UpdateModifierOpcode;
}(UpdatingOpcode);
APPEND_OPCODES.add(28 /* StaticAttr */, function (vm, _ref6) {
    var _name = _ref6.op1,
        _value = _ref6.op2,
        _namespace = _ref6.op3;

    var name = vm.constants.getString(_name);
    var value = vm.constants.getString(_value);
    var namespace = _namespace ? vm.constants.getString(_namespace) : null;
    vm.elements().setStaticAttribute(name, value, namespace);
});
APPEND_OPCODES.add(29 /* DynamicAttr */, function (vm, _ref7) {
    var _name = _ref7.op1,
        trusting = _ref7.op2,
        _namespace = _ref7.op3;

    var name = vm.constants.getString(_name);
    var reference = vm.stack.pop();
    var value = reference.value();
    var namespace = _namespace ? vm.constants.getString(_namespace) : null;
    var attribute = vm.elements().setDynamicAttribute(name, value, !!trusting, namespace);
    if (!isConst(reference)) {
        vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));
    }
});
var UpdateDynamicAttributeOpcode = function (_UpdatingOpcode2) {
    inherits(UpdateDynamicAttributeOpcode, _UpdatingOpcode2);

    function UpdateDynamicAttributeOpcode(reference, attribute) {
        classCallCheck(this, UpdateDynamicAttributeOpcode);

        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));

        _this2.reference = reference;
        _this2.attribute = attribute;
        _this2.type = 'patch-element';
        _this2.tag = reference.tag;
        _this2.lastRevision = _this2.tag.value();
        return _this2;
    }

    UpdateDynamicAttributeOpcode.prototype.evaluate = function evaluate(vm) {
        var attribute = this.attribute,
            reference = this.reference,
            tag = this.tag;

        if (!tag.validate(this.lastRevision)) {
            this.lastRevision = tag.value();
            attribute.update(reference.value(), vm.env);
        }
    };

    return UpdateDynamicAttributeOpcode;
}(UpdatingOpcode);

function resolveComponent(resolver, name, meta) {
    var definition = resolver.lookupComponent(name, meta);
    false && debugAssert(definition, 'Could not find a component named "' + name + '"');

    return definition;
}

/** @internal */
function hasStaticLayout(state, manager) {
    return manager.getCapabilities(state).dynamicLayout === false;
}
/** @internal */
function hasDynamicLayout(state, manager) {
    return manager.getCapabilities(state).dynamicLayout === true;
}

var CurryComponentReference = function () {
    function CurryComponentReference(inner, resolver, meta, args) {
        classCallCheck(this, CurryComponentReference);

        this.inner = inner;
        this.resolver = resolver;
        this.meta = meta;
        this.args = args;
        this.tag = inner.tag;
        this.lastValue = null;
        this.lastDefinition = null;
    }

    CurryComponentReference.prototype.value = function value() {
        var inner = this.inner,
            lastValue = this.lastValue;

        var value = inner.value();
        if (value === lastValue) {
            return this.lastDefinition;
        }
        var definition = null;
        if (isCurriedComponentDefinition(value)) {
            definition = value;
        } else if (typeof value === 'string' && value) {
            var resolver = this.resolver,
                meta = this.meta;

            definition = resolveComponent(resolver, value, meta);
        }
        definition = this.curry(definition);
        this.lastValue = value;
        this.lastDefinition = definition;
        return definition;
    };

    CurryComponentReference.prototype.get = function get$$1() {
        return UNDEFINED_REFERENCE;
    };

    CurryComponentReference.prototype.curry = function curry$$1(definition) {
        var args = this.args;

        if (!args && isCurriedComponentDefinition(definition)) {
            return definition;
        } else if (!definition) {
            return null;
        } else {
            return new CurriedComponentDefinition(definition, args);
        }
    };

    return CurryComponentReference;
}();

function normalizeStringValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    return String(value);
}
function normalizeTrustedValue(value) {
    if (isEmpty(value)) {
        return '';
    }
    if (isString(value)) {
        return value;
    }
    if (isSafeString(value)) {
        return value.toHTML();
    }
    if (isNode(value)) {
        return value;
    }
    return String(value);
}
function isEmpty(value) {
    return value === null || value === undefined || typeof value.toString !== 'function';
}
function isSafeString(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && typeof value.toHTML === 'function';
}
function isNode(value) {
    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && typeof value.nodeType === 'number';
}
function isFragment(value) {
    return isNode(value) && value.nodeType === 11;
}
function isString(value) {
    return typeof value === 'string';
}

var ClassListReference = function () {
    function ClassListReference(list) {
        classCallCheck(this, ClassListReference);

        this.list = list;
        this.tag = combineTagged(list);
        this.list = list;
    }

    ClassListReference.prototype.value = function value() {
        var ret = [];
        var list = this.list;

        for (var i = 0; i < list.length; i++) {
            var value = normalizeStringValue(list[i].value());
            if (value) ret.push(value);
        }
        return ret.length === 0 ? null : ret.join(' ');
    };

    return ClassListReference;
}();

var ARGS = new Arguments();
APPEND_OPCODES.add(57 /* IsComponent */, function (vm) {
    var stack = vm.stack;
    var ref = stack.pop();
    stack.push(IsCurriedComponentDefinitionReference.create(ref));
});
APPEND_OPCODES.add(58 /* CurryComponent */, function (vm, _ref) {
    var _meta = _ref.op1;

    var stack = vm.stack;
    var definition = stack.pop();
    var args = stack.pop();
    var captured = null;
    if (args.length) {
        captured = args.capture();
    }
    var meta = vm.constants.getSerializable(_meta);
    var resolver = vm.constants.resolver;
    vm.loadValue(Register.v0, new CurryComponentReference(definition, resolver, meta, captured));
    // expectStackChange(vm.stack, -args.length - 1, 'CurryComponent');
});
APPEND_OPCODES.add(59 /* PushComponentDefinition */, function (vm, _ref2) {
    var handle = _ref2.op1;

    var definition = vm.constants.resolveHandle(handle);
    false && debugAssert(!!definition, 'Missing component for ' + handle + ' (TODO: env.specifierForHandle)');

    var manager = definition.manager;

    vm.stack.push({ definition: definition, manager: manager, state: null });
});
APPEND_OPCODES.add(60 /* PushDynamicComponentManager */, function (vm, _ref3) {
    var _meta = _ref3.op1;

    var stack = vm.stack;
    var component = stack.pop().value();
    var definition = void 0;
    if (typeof component === 'string') {
        var constants = vm.constants,
            resolver = vm.constants.resolver;

        var meta = constants.getSerializable(_meta);
        var resolvedDefinition = resolveComponent(resolver, component, meta);
        definition = resolvedDefinition;
    } else if (isCurriedComponentDefinition(component)) {
        definition = component;
    } else {
        throw unreachable();
    }
    stack.push({ definition: definition, manager: null, state: null });
});
APPEND_OPCODES.add(61 /* PushArgs */, function (vm, _ref4) {
    var _names = _ref4.op1,
        flags = _ref4.op2;

    var stack = vm.stack;
    var names = vm.constants.getStringArray(_names);
    var positionalCount = flags >> 4;
    var synthetic = flags & 8;
    var blockNames = [];
    if (flags & 4) blockNames.push('main');
    if (flags & 2) blockNames.push('else');
    if (flags & 1) blockNames.push('attrs');
    ARGS.setup(stack, names, blockNames, positionalCount, !!synthetic);
    stack.push(ARGS);
});
APPEND_OPCODES.add(63 /* PrepareArgs */, function (vm, _ref5) {
    var _state = _ref5.op1;

    var stack = vm.stack;
    var instance = vm.fetchValue(_state);
    var definition = instance.definition;

    var args = void 0;
    if (isCurriedComponentDefinition(definition)) {
        false && debugAssert(!definition.manager, "If the component definition was curried, we don't yet have a manager");

        args = stack.pop();
        definition = instance.definition = definition.unwrap(args);
    } else {
        args = stack.pop();
    }
    var _definition = definition,
        manager = _definition.manager,
        state = _definition.state;

    instance.manager = definition.manager;
    if (manager.getCapabilities(state).prepareArgs !== true) {
        stack.push(args);
        return;
    }
    var blocks = args.blocks.values;
    var blockNames = args.blocks.names;
    var preparedArgs = manager.prepareArgs(state, args);
    if (preparedArgs) {
        args.clear();
        for (var i = 0; i < blocks.length; i++) {
            stack.push(blocks[i]);
        }
        var positional = preparedArgs.positional,
            named = preparedArgs.named;

        var positionalCount = positional.length;
        for (var _i = 0; _i < positionalCount; _i++) {
            stack.push(positional[_i]);
        }
        var names = Object.keys(named);
        for (var _i2 = 0; _i2 < names.length; _i2++) {
            stack.push(named[names[_i2]]);
        }
        args.setup(stack, names, blockNames, positionalCount, true);
    }
    stack.push(args);
});
APPEND_OPCODES.add(64 /* CreateComponent */, function (vm, _ref6) {
    var flags = _ref6.op1,
        _state = _ref6.op2;

    var dynamicScope = vm.dynamicScope();
    var instance = vm.fetchValue(_state);
    var definition = instance.definition,
        manager = instance.manager;

    var hasDefaultBlock = flags & 1;
    var args = null;
    if (manager.getCapabilities(definition.state).createArgs) {
        args = vm.stack.peek();
    }
    var state = manager.create(vm.env, definition.state, args, dynamicScope, vm.getSelf(), !!hasDefaultBlock);
    // We want to reuse the `state` POJO here, because we know that the opcodes
    // only transition at exactly one place.
    instance.state = state;
    var tag = manager.getTag(state);
    if (!isConstTag(tag)) {
        vm.updateWith(new UpdateComponentOpcode(tag, state, manager, dynamicScope));
    }
});
APPEND_OPCODES.add(65 /* RegisterComponentDestructor */, function (vm, _ref7) {
    var _state = _ref7.op1;

    var _vm$fetchValue = vm.fetchValue(_state),
        manager = _vm$fetchValue.manager,
        state = _vm$fetchValue.state;

    var destructor = manager.getDestructor(state);
    if (destructor) vm.newDestroyable(destructor);
});
APPEND_OPCODES.add(71 /* BeginComponentTransaction */, function (vm) {
    vm.beginCacheGroup();
    vm.elements().pushSimpleBlock();
});
APPEND_OPCODES.add(66 /* PutComponentOperations */, function (vm) {
    vm.loadValue(Register.t0, new ComponentElementOperations());
});
APPEND_OPCODES.add(30 /* ComponentAttr */, function (vm, _ref8) {
    var _name = _ref8.op1,
        trusting = _ref8.op2,
        _namespace = _ref8.op3;

    var name = vm.constants.getString(_name);
    var reference = vm.stack.pop();
    var namespace = _namespace ? vm.constants.getString(_namespace) : null;
    vm.fetchValue(Register.t0).setAttribute(name, reference, !!trusting, namespace);
});
var ComponentElementOperations = function () {
    function ComponentElementOperations() {
        classCallCheck(this, ComponentElementOperations);

        this.attributes = dict();
        this.classes = [];
    }

    ComponentElementOperations.prototype.setAttribute = function setAttribute(name, value, trusting, namespace) {
        var deferred = { value: value, namespace: namespace, trusting: trusting };
        if (name === 'class') {
            this.classes.push(value);
        }
        this.attributes[name] = deferred;
    };

    ComponentElementOperations.prototype.flush = function flush(vm) {
        for (var name in this.attributes) {
            var attr = this.attributes[name];
            var reference = attr.value,
                namespace = attr.namespace,
                trusting = attr.trusting;

            if (name === 'class') {
                reference = new ClassListReference(this.classes);
            }
            var attribute = vm.elements().setDynamicAttribute(name, reference.value(), trusting, namespace);
            if (!isConst(reference)) {
                vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));
            }
        }
    };

    return ComponentElementOperations;
}();
APPEND_OPCODES.add(73 /* DidCreateElement */, function (vm, _ref9) {
    var _state = _ref9.op1;

    var _vm$fetchValue2 = vm.fetchValue(_state),
        definition = _vm$fetchValue2.definition,
        state = _vm$fetchValue2.state;

    var manager = definition.manager;

    var operations = vm.fetchValue(Register.t0);
    var action = 'DidCreateElementOpcode#evaluate';
    manager.didCreateElement(state, vm.elements().expectConstructing(action), operations);
});
APPEND_OPCODES.add(67 /* GetComponentSelf */, function (vm, _ref10) {
    var _state = _ref10.op1;

    var _vm$fetchValue3 = vm.fetchValue(_state),
        definition = _vm$fetchValue3.definition,
        state = _vm$fetchValue3.state;

    var manager = definition.manager;

    vm.stack.push(manager.getSelf(state));
});
APPEND_OPCODES.add(68 /* GetComponentTagName */, function (vm, _ref11) {
    var _state = _ref11.op1;

    var _vm$fetchValue4 = vm.fetchValue(_state),
        definition = _vm$fetchValue4.definition,
        state = _vm$fetchValue4.state;

    var manager = definition.manager;

    vm.stack.push(manager.getTagName(state));
});
// Dynamic Invocation Only
APPEND_OPCODES.add(69 /* GetComponentLayout */, function (vm, _ref12) {
    var _state = _ref12.op1;

    var instance = vm.fetchValue(_state);
    var manager = instance.manager,
        definition = instance.definition;
    var resolver = vm.constants.resolver,
        stack = vm.stack;
    var instanceState = instance.state;
    var definitionState = definition.state;

    var invoke = void 0;
    if (hasStaticLayout(definitionState, manager)) {
        invoke = manager.getLayout(definitionState, resolver);
    } else if (hasDynamicLayout(definitionState, manager)) {
        invoke = manager.getDynamicLayout(instanceState, resolver);
    } else {
        throw unreachable();
    }
    stack.push(invoke.symbolTable);
    stack.push(invoke.handle);
});
// Dynamic Invocation Only
APPEND_OPCODES.add(70 /* InvokeComponentLayout */, function (vm) {
    var stack = vm.stack;

    var handle = stack.pop();

    var _stack$pop = stack.pop(),
        symbols = _stack$pop.symbols,
        hasEval = _stack$pop.hasEval;

    {
        var scope = vm.pushRootScope(symbols.length + 1, true);
        scope.bindSelf(stack.pop());
        var args = vm.stack.pop();
        var lookup = null;
        var $eval = -1;
        if (hasEval) {
            $eval = symbols.indexOf('$eval') + 1;
            lookup = dict();
        }
        var callerNames = args.named.atNames;
        for (var i = callerNames.length - 1; i >= 0; i--) {
            var atName = callerNames[i];
            var symbol = symbols.indexOf(callerNames[i]);
            var value = args.named.get(atName, false);
            if (symbol !== -1) scope.bindSymbol(symbol + 1, value);
            if (hasEval) lookup[atName] = value;
        }
        var bindBlock = function bindBlock(symbolName, blockName) {
            var symbol = symbols.indexOf(symbolName);
            var block = blocks.get(blockName);
            if (symbol !== -1) {
                scope.bindBlock(symbol + 1, block);
            }
            if (lookup) lookup[symbolName] = block;
        };
        var blocks = args.blocks;
        bindBlock(ATTRS_BLOCK, 'attrs');
        bindBlock('&inverse', 'else');
        bindBlock('&default', 'main');
        if (lookup) scope.bindEvalScope(lookup);
        vm.call(handle);
    }
});
APPEND_OPCODES.add(74 /* DidRenderLayout */, function (vm, _ref13) {
    var _state = _ref13.op1;

    var _vm$fetchValue5 = vm.fetchValue(_state),
        manager = _vm$fetchValue5.manager,
        state = _vm$fetchValue5.state;

    var bounds = vm.elements().popBlock();
    var mgr = manager;
    mgr.didRenderLayout(state, bounds);
    vm.env.didCreate(state, manager);
    vm.updateWith(new DidUpdateLayoutOpcode(manager, state, bounds));
});
APPEND_OPCODES.add(72 /* CommitComponentTransaction */, function (vm) {
    vm.commitCacheGroup();
});
var UpdateComponentOpcode = function (_UpdatingOpcode) {
    inherits(UpdateComponentOpcode, _UpdatingOpcode);

    function UpdateComponentOpcode(tag, component, manager, dynamicScope) {
        classCallCheck(this, UpdateComponentOpcode);

        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.tag = tag;
        _this.component = component;
        _this.manager = manager;
        _this.dynamicScope = dynamicScope;
        _this.type = 'update-component';
        return _this;
    }

    UpdateComponentOpcode.prototype.evaluate = function evaluate(_vm) {
        var component = this.component,
            manager = this.manager,
            dynamicScope = this.dynamicScope;

        manager.update(component, dynamicScope);
    };

    return UpdateComponentOpcode;
}(UpdatingOpcode);
var DidUpdateLayoutOpcode = function (_UpdatingOpcode2) {
    inherits(DidUpdateLayoutOpcode, _UpdatingOpcode2);

    function DidUpdateLayoutOpcode(manager, component, bounds) {
        classCallCheck(this, DidUpdateLayoutOpcode);

        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));

        _this2.manager = manager;
        _this2.component = component;
        _this2.bounds = bounds;
        _this2.type = 'did-update-layout';
        _this2.tag = CONSTANT_TAG;
        return _this2;
    }

    DidUpdateLayoutOpcode.prototype.evaluate = function evaluate(vm) {
        var manager = this.manager,
            component = this.component,
            bounds = this.bounds;

        manager.didUpdateLayout(component, bounds);
        vm.env.didUpdate(component, manager);
    };

    return DidUpdateLayoutOpcode;
}(UpdatingOpcode);

/* tslint:disable */
function debugCallback(context, get$$1) {
    console.info('Use `context`, and `get(<path>)` to debug this template.');
    // for example...
    context === get$$1('this');
    debugger;
}
/* tslint:enable */
var callback = debugCallback;
// For testing purposes



var ScopeInspector = function () {
    function ScopeInspector(scope, symbols, evalInfo) {
        classCallCheck(this, ScopeInspector);

        this.scope = scope;
        this.locals = dict();
        for (var i = 0; i < evalInfo.length; i++) {
            var slot = evalInfo[i];
            var name = symbols[slot - 1];
            var ref = scope.getSymbol(slot);
            this.locals[name] = ref;
        }
    }

    ScopeInspector.prototype.get = function get$$1(path) {
        var scope = this.scope,
            locals = this.locals;

        var parts = path.split('.');

        var _path$split = path.split('.'),
            head = _path$split[0],
            tail = _path$split.slice(1);

        var evalScope = scope.getEvalScope();
        var ref = void 0;
        if (head === 'this') {
            ref = scope.getSelf();
        } else if (locals[head]) {
            ref = locals[head];
        } else if (head.indexOf('@') === 0 && evalScope[head]) {
            ref = evalScope[head];
        } else {
            ref = this.scope.getSelf();
            tail = parts;
        }
        return tail.reduce(function (r, part) {
            return r.get(part);
        }, ref);
    };

    return ScopeInspector;
}();

APPEND_OPCODES.add(77 /* Debugger */, function (vm, _ref) {
    var _symbols = _ref.op1,
        _evalInfo = _ref.op2;

    var symbols = vm.constants.getStringArray(_symbols);
    var evalInfo = vm.constants.getArray(_evalInfo);
    var inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);
    callback(vm.getSelf().value(), function (path) {
        return inspector.get(path).value();
    });
});

APPEND_OPCODES.add(75 /* InvokePartial */, function (vm, _ref) {
    var _meta = _ref.op1,
        _symbols = _ref.op2,
        _evalInfo = _ref.op3;
    var constants = vm.constants,
        resolver = vm.constants.resolver,
        stack = vm.stack;

    var name = stack.pop().value();
    false && debugAssert(typeof name === 'string', 'Could not find a partial named "' + String(name) + '"');

    var meta = constants.getSerializable(_meta);
    var outerSymbols = constants.getStringArray(_symbols);
    var evalInfo = constants.getArray(_evalInfo);
    var specifier = resolver.lookupPartial(name, meta);
    false && debugAssert(specifier, 'Could not find a partial named "' + name + '"');

    var definition = resolver.resolve(specifier);

    var _definition$getPartia = definition.getPartial(),
        symbolTable = _definition$getPartia.symbolTable,
        handle = _definition$getPartia.handle;

    {
        var partialSymbols = symbolTable.symbols;
        var outerScope = vm.scope();
        var partialScope = vm.pushRootScope(partialSymbols.length, false);
        partialScope.bindCallerScope(outerScope.getCallerScope());
        partialScope.bindEvalScope(outerScope.getEvalScope());
        partialScope.bindSelf(outerScope.getSelf());
        var locals = dict();
        for (var i = 0; i < evalInfo.length; i++) {
            var slot = evalInfo[i];
            var _name = outerSymbols[slot - 1];
            var ref = outerScope.getSymbol(slot);
            locals[_name] = ref;
        }
        var evalScope = outerScope.getEvalScope();
        for (var _i = 0; _i < partialSymbols.length; _i++) {
            var _name2 = partialSymbols[_i];
            var symbol = _i + 1;
            var value = evalScope[_name2];
            if (value !== undefined) partialScope.bind(symbol, value);
        }
        partialScope.bindPartialMap(locals);
        vm.pushFrame(); // sp += 2
        vm.call(handle);
    }
});

var IterablePresenceReference = function () {
    function IterablePresenceReference(artifacts) {
        classCallCheck(this, IterablePresenceReference);

        this.tag = artifacts.tag;
        this.artifacts = artifacts;
    }

    IterablePresenceReference.prototype.value = function value() {
        return !this.artifacts.isEmpty();
    };

    return IterablePresenceReference;
}();

APPEND_OPCODES.add(55 /* PutIterator */, function (vm) {
    var stack = vm.stack;
    var listRef = stack.pop();
    var key = stack.pop();
    var iterable = vm.env.iterableFor(listRef, key.value());
    var iterator = new ReferenceIterator(iterable);
    stack.push(iterator);
    stack.push(new IterablePresenceReference(iterator.artifacts));
});
APPEND_OPCODES.add(53 /* EnterList */, function (vm, _ref) {
    var relativeStart = _ref.op1;

    vm.enterList(relativeStart);
});
APPEND_OPCODES.add(54 /* ExitList */, function (vm) {
    vm.exitList();
});
APPEND_OPCODES.add(56 /* Iterate */, function (vm, _ref2) {
    var breaks = _ref2.op1;

    var stack = vm.stack;
    var item = stack.peek().next();
    if (item) {
        var tryOpcode = vm.iterate(item.memo, item.value);
        vm.enterItem(item.key, tryOpcode);
    } else {
        vm.goto(breaks);
    }
});

var Cursor = function Cursor(element, nextSibling) {
    classCallCheck(this, Cursor);

    this.element = element;
    this.nextSibling = nextSibling;
};
var ConcreteBounds = function () {
    function ConcreteBounds(parentNode, first, last) {
        classCallCheck(this, ConcreteBounds);

        this.parentNode = parentNode;
        this.first = first;
        this.last = last;
    }

    ConcreteBounds.prototype.parentElement = function parentElement() {
        return this.parentNode;
    };

    ConcreteBounds.prototype.firstNode = function firstNode() {
        return this.first;
    };

    ConcreteBounds.prototype.lastNode = function lastNode() {
        return this.last;
    };

    return ConcreteBounds;
}();
var SingleNodeBounds = function () {
    function SingleNodeBounds(parentNode, node) {
        classCallCheck(this, SingleNodeBounds);

        this.parentNode = parentNode;
        this.node = node;
    }

    SingleNodeBounds.prototype.parentElement = function parentElement() {
        return this.parentNode;
    };

    SingleNodeBounds.prototype.firstNode = function firstNode() {
        return this.node;
    };

    SingleNodeBounds.prototype.lastNode = function lastNode() {
        return this.node;
    };

    return SingleNodeBounds;
}();
function bounds(parent, first, last) {
    return new ConcreteBounds(parent, first, last);
}
function single(parent, node) {
    return new SingleNodeBounds(parent, node);
}
function move(bounds, reference) {
    var parent = bounds.parentElement();
    var first = bounds.firstNode();
    var last = bounds.lastNode();
    var node = first;
    while (node) {
        var next = node.nextSibling;
        parent.insertBefore(node, reference);
        if (node === last) return next;
        node = next;
    }
    return null;
}
function clear(bounds) {
    var parent = bounds.parentElement();
    var first = bounds.firstNode();
    var last = bounds.lastNode();
    var node = first;
    while (node) {
        var next = node.nextSibling;
        parent.removeChild(node);
        if (node === last) return next;
        node = next;
    }
    return null;
}

var SVG_NAMESPACE$1 = 'http://www.w3.org/2000/svg';
// Patch:    insertAdjacentHTML on SVG Fix
// Browsers: Safari, IE, Edge, Firefox ~33-34
// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is
//           present but throws an exception on IE and Edge. Old versions of
//           Firefox create nodes in the incorrect namespace.
// Fix:      Since IE and Edge silently fail to create SVG nodes using
//           innerHTML, and because Firefox may create nodes in the incorrect
//           namespace using innerHTML on SVG elements, an HTML-string wrapping
//           approach is used. A pre/post SVG tag is added to the string, then
//           that whole string is added to a div. The created nodes are plucked
//           out and applied to the target location on DOM.
function applySVGInnerHTMLFix(document, DOMClass, svgNamespace) {
    if (!document) return DOMClass;
    if (!shouldApplyFix(document, svgNamespace)) {
        return DOMClass;
    }
    var div = document.createElement('div');
    return function (_DOMClass) {
        inherits(DOMChangesWithSVGInnerHTMLFix, _DOMClass);

        function DOMChangesWithSVGInnerHTMLFix() {
            classCallCheck(this, DOMChangesWithSVGInnerHTMLFix);
            return possibleConstructorReturn(this, _DOMClass.apply(this, arguments));
        }

        DOMChangesWithSVGInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore$$1(parent, nextSibling, html) {
            if (html === null || html === '') {
                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            if (parent.namespaceURI !== svgNamespace) {
                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            return fixSVG(parent, div, html, nextSibling);
        };

        return DOMChangesWithSVGInnerHTMLFix;
    }(DOMClass);
}
function fixSVG(parent, div, html, reference) {
    // IE, Edge: also do not correctly support using `innerHTML` on SVG
    // namespaced elements. So here a wrapper is used.
    var wrappedHtml = '<svg>' + html + '</svg>';
    div.innerHTML = wrappedHtml;

    var _moveNodesBefore = moveNodesBefore(div.firstChild, parent, reference),
        first = _moveNodesBefore[0],
        last = _moveNodesBefore[1];

    return new ConcreteBounds(parent, first, last);
}
function shouldApplyFix(document, svgNamespace) {
    var svg = document.createElementNS(svgNamespace, 'svg');
    try {
        svg['insertAdjacentHTML']('beforeend', '<circle></circle>');
    } catch (e) {
        // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG
        // Safari: Will throw, insertAdjacentHTML is not present on SVG
    } finally {
        // FF: Old versions will create a node in the wrong namespace
        if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE$1) {
            // The test worked as expected, no fix required
            return false;
        }
        return true;
    }
}

// Patch:    Adjacent text node merging fix
// Browsers: IE, Edge, Firefox w/o inspector open
// Reason:   These browsers will merge adjacent text nodes. For exmaple given
//           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers
//           with proper behavior will populate div.childNodes with two items.
//           These browsers will populate it with one merged node instead.
// Fix:      Add these nodes to a wrapper element, then iterate the childNodes
//           of that wrapper and move the nodes to their target location. Note
//           that potential SVG bugs will have been handled before this fix.
//           Note that this fix must only apply to the previous text node, as
//           the base implementation of `insertHTMLBefore` already handles
//           following text nodes correctly.
function applyTextNodeMergingFix(document, DOMClass) {
    if (!document) return DOMClass;
    if (!shouldApplyFix$1(document)) {
        return DOMClass;
    }
    return function (_DOMClass) {
        inherits(DOMChangesWithTextNodeMergingFix, _DOMClass);

        function DOMChangesWithTextNodeMergingFix(document) {
            classCallCheck(this, DOMChangesWithTextNodeMergingFix);

            var _this = possibleConstructorReturn(this, _DOMClass.call(this, document));

            _this.uselessComment = document.createComment('');
            return _this;
        }

        DOMChangesWithTextNodeMergingFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {
            if (html === null) {
                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            }
            var didSetUselessComment = false;
            var nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;
            if (nextPrevious && nextPrevious instanceof Text) {
                didSetUselessComment = true;
                parent.insertBefore(this.uselessComment, nextSibling);
            }
            var bounds = _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);
            if (didSetUselessComment) {
                parent.removeChild(this.uselessComment);
            }
            return bounds;
        };

        return DOMChangesWithTextNodeMergingFix;
    }(DOMClass);
}
function shouldApplyFix$1(document) {
    var mergingTextDiv = document.createElement('div');
    mergingTextDiv.innerHTML = 'first';
    mergingTextDiv.insertAdjacentHTML('beforeend', 'second');
    if (mergingTextDiv.childNodes.length === 2) {
        // It worked as expected, no fix required
        return false;
    }
    return true;
}

var SVG_NAMESPACE$$1 = 'http://www.w3.org/2000/svg';
// http://www.w3.org/TR/html/syntax.html#html-integration-point
var SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };
// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes
// TODO: Adjust SVG attributes
// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
// TODO: Adjust SVG elements
// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign
var BLACKLIST_TABLE = Object.create(null);
["b", "big", "blockquote", "body", "br", "center", "code", "dd", "div", "dl", "dt", "em", "embed", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "i", "img", "li", "listing", "main", "meta", "nobr", "ol", "p", "pre", "ruby", "s", "small", "span", "strong", "strike", "sub", "sup", "table", "tt", "u", "ul", "var"].forEach(function (tag) {
    return BLACKLIST_TABLE[tag] = 1;
});
var doc = typeof document === 'undefined' ? null : document;

function moveNodesBefore(source, target, nextSibling) {
    var first = source.firstChild;
    var last = null;
    var current = first;
    while (current) {
        last = current;
        current = current.nextSibling;
        target.insertBefore(last, nextSibling);
    }
    return [first, last];
}
var DOMOperations = function () {
    function DOMOperations(document) {
        classCallCheck(this, DOMOperations);

        this.document = document;
        this.setupUselessElement();
    }
    // split into seperate method so that NodeDOMTreeConstruction
    // can override it.


    DOMOperations.prototype.setupUselessElement = function setupUselessElement() {
        this.uselessElement = this.document.createElement('div');
    };

    DOMOperations.prototype.createElement = function createElement(tag, context) {
        var isElementInSVGNamespace = void 0,
            isHTMLIntegrationPoint = void 0;
        if (context) {
            isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE$$1 || tag === 'svg';
            isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];
        } else {
            isElementInSVGNamespace = tag === 'svg';
            isHTMLIntegrationPoint = false;
        }
        if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {
            // FIXME: This does not properly handle <font> with color, face, or
            // size attributes, which is also disallowed by the spec. We should fix
            // this.
            if (BLACKLIST_TABLE[tag]) {
                throw new Error('Cannot create a ' + tag + ' inside an SVG context');
            }
            return this.document.createElementNS(SVG_NAMESPACE$$1, tag);
        } else {
            return this.document.createElement(tag);
        }
    };

    DOMOperations.prototype.insertBefore = function insertBefore(parent, node, reference) {
        parent.insertBefore(node, reference);
    };

    DOMOperations.prototype.insertHTMLBefore = function insertHTMLBefore(_parent, nextSibling, html) {
        return _insertHTMLBefore(this.uselessElement, _parent, nextSibling, html);
    };

    DOMOperations.prototype.createTextNode = function createTextNode(text) {
        return this.document.createTextNode(text);
    };

    DOMOperations.prototype.createComment = function createComment(data) {
        return this.document.createComment(data);
    };

    return DOMOperations;
}();
var DOM;
(function (DOM) {
    var TreeConstruction = function (_DOMOperations) {
        inherits(TreeConstruction, _DOMOperations);

        function TreeConstruction() {
            classCallCheck(this, TreeConstruction);
            return possibleConstructorReturn(this, _DOMOperations.apply(this, arguments));
        }

        TreeConstruction.prototype.createElementNS = function createElementNS(namespace, tag) {
            return this.document.createElementNS(namespace, tag);
        };

        TreeConstruction.prototype.setAttribute = function setAttribute(element, name, value) {
            var namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

            if (namespace) {
                element.setAttributeNS(namespace, name, value);
            } else {
                element.setAttribute(name, value);
            }
        };

        return TreeConstruction;
    }(DOMOperations);

    DOM.TreeConstruction = TreeConstruction;
    var appliedTreeContruction = TreeConstruction;
    appliedTreeContruction = applyTextNodeMergingFix(doc, appliedTreeContruction);
    appliedTreeContruction = applySVGInnerHTMLFix(doc, appliedTreeContruction, SVG_NAMESPACE$$1);
    DOM.DOMTreeConstruction = appliedTreeContruction;
})(DOM || (DOM = {}));
var DOMChanges = function (_DOMOperations2) {
    inherits(DOMChanges, _DOMOperations2);

    function DOMChanges(document) {
        classCallCheck(this, DOMChanges);

        var _this2 = possibleConstructorReturn(this, _DOMOperations2.call(this, document));

        _this2.document = document;
        _this2.namespace = null;
        return _this2;
    }

    DOMChanges.prototype.setAttribute = function setAttribute(element, name, value) {
        element.setAttribute(name, value);
    };

    DOMChanges.prototype.removeAttribute = function removeAttribute(element, name) {
        element.removeAttribute(name);
    };

    DOMChanges.prototype.insertAfter = function insertAfter(element, node, reference) {
        this.insertBefore(element, node, reference.nextSibling);
    };

    return DOMChanges;
}(DOMOperations);
function _insertHTMLBefore(_useless, _parent, _nextSibling, html) {
    // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`
    // only exists on `HTMLElement` but not on `Element`. We actually work with the
    // newer version of the DOM API here (and monkey-patch this method in `./compat`
    // when we detect older browsers). This is a hack to work around this limitation.
    var parent = _parent;
    var useless = _useless;
    var nextSibling = _nextSibling;
    var prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;
    var last = void 0;
    if (html === null || html === '') {
        return new ConcreteBounds(parent, null, null);
    }
    if (nextSibling === null) {
        parent.insertAdjacentHTML('beforeend', html);
        last = parent.lastChild;
    } else if (nextSibling instanceof HTMLElement) {
        nextSibling.insertAdjacentHTML('beforebegin', html);
        last = nextSibling.previousSibling;
    } else {
        // Non-element nodes do not support insertAdjacentHTML, so add an
        // element and call it on that element. Then remove the element.
        //
        // This also protects Edge, IE and Firefox w/o the inspector open
        // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts
        parent.insertBefore(useless, nextSibling);
        useless.insertAdjacentHTML('beforebegin', html);
        last = useless.previousSibling;
        parent.removeChild(useless);
    }
    var first = prev ? prev.nextSibling : parent.firstChild;
    return new ConcreteBounds(parent, first, last);
}
var helper = DOMChanges;
helper = applyTextNodeMergingFix(doc, helper);
helper = applySVGInnerHTMLFix(doc, helper, SVG_NAMESPACE$$1);
var DOMChanges$1 = helper;
var DOMTreeConstruction = DOM.DOMTreeConstruction;

var badProtocols = ['javascript:', 'vbscript:'];
var badTags = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];
var badTagsForDataURI = ['EMBED'];
var badAttributes = ['href', 'src', 'background', 'action'];
var badAttributesForDataURI = ['src'];
function has(array, item) {
    return array.indexOf(item) !== -1;
}
function checkURI(tagName, attribute) {
    return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);
}
function checkDataURI(tagName, attribute) {
    if (tagName === null) return false;
    return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);
}
function requiresSanitization(tagName, attribute) {
    return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);
}
function sanitizeAttributeValue(env, element, attribute, value) {
    var tagName = null;
    if (value === null || value === undefined) {
        return value;
    }
    if (isSafeString(value)) {
        return value.toHTML();
    }
    if (!element) {
        tagName = null;
    } else {
        tagName = element.tagName.toUpperCase();
    }
    var str = normalizeStringValue(value);
    if (checkURI(tagName, attribute)) {
        var protocol = env.protocolForURL(str);
        if (has(badProtocols, protocol)) {
            return 'unsafe:' + str;
        }
    }
    if (checkDataURI(tagName, attribute)) {
        return 'unsafe:' + str;
    }
    return str;
}

/*
 * @method normalizeProperty
 * @param element {HTMLElement}
 * @param slotName {String}
 * @returns {Object} { name, type }
 */
function normalizeProperty(element, slotName) {
    var type = void 0,
        normalized = void 0;
    if (slotName in element) {
        normalized = slotName;
        type = 'prop';
    } else {
        var lower = slotName.toLowerCase();
        if (lower in element) {
            type = 'prop';
            normalized = lower;
        } else {
            type = 'attr';
            normalized = slotName;
        }
    }
    if (type === 'prop' && (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))) {
        type = 'attr';
    }
    return { normalized: normalized, type: type };
}

// properties that MUST be set as attributes, due to:
// * browser bug
// * strange spec outlier
var ATTR_OVERRIDES = {
    INPUT: {
        form: true,
        // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false
        // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false
        // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true
        autocorrect: true,
        // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true
        // Safari 9.1.3: 'list' in document.createElement('input') === false
        list: true
    },
    // element.form is actually a legitimate readOnly property, that is to be
    // mutated, but must be mutated by setAttribute...
    SELECT: { form: true },
    OPTION: { form: true },
    TEXTAREA: { form: true },
    LABEL: { form: true },
    FIELDSET: { form: true },
    LEGEND: { form: true },
    OBJECT: { form: true }
};
function preferAttr(tagName, propName) {
    var tag = ATTR_OVERRIDES[tagName.toUpperCase()];
    return tag && tag[propName.toLowerCase()] || false;
}

function defaultDynamicAttributes(element, attr) {
    var tagName = element.tagName,
        namespaceURI = element.namespaceURI;

    if (namespaceURI === SVG_NAMESPACE$$1) {
        return defaultDynamicAttribute(tagName, attr);
    }

    var _normalizeProperty = normalizeProperty(element, attr),
        type = _normalizeProperty.type,
        normalized = _normalizeProperty.normalized;

    if (type === 'attr') {
        return defaultDynamicAttribute(tagName, normalized);
    } else {
        return defaultDynamicProperty(tagName, normalized);
    }
}
function defaultDynamicAttribute(tagName, name) {
    if (requiresSanitization(tagName, name)) {
        return SafeDynamicAttribute;
    } else {
        return SimpleDynamicAttribute;
    }
}
function defaultDynamicProperty(tagName, name) {
    if (requiresSanitization(tagName, name)) {
        return SafeDynamicProperty;
    }
    if (isUserInputValue(tagName, name)) {
        return InputValueDynamicAttribute;
    }
    if (isOptionSelected(tagName, name)) {
        return OptionSelectedDynamicAttribute;
    }
    return DefaultDynamicProperty;
}
var DynamicAttribute = function DynamicAttribute(attribute) {
    classCallCheck(this, DynamicAttribute);

    this.attribute = attribute;
};
var SimpleDynamicAttribute = function (_DynamicAttribute) {
    inherits(SimpleDynamicAttribute, _DynamicAttribute);

    function SimpleDynamicAttribute() {
        classCallCheck(this, SimpleDynamicAttribute);
        return possibleConstructorReturn(this, _DynamicAttribute.apply(this, arguments));
    }

    SimpleDynamicAttribute.prototype.set = function set$$1(dom, value, _env) {
        var normalizedValue = normalizeValue(value);
        if (normalizedValue !== null) {
            var _attribute = this.attribute,
                name = _attribute.name,
                namespace = _attribute.namespace;

            dom.__setAttribute(name, normalizedValue, namespace);
        }
    };

    SimpleDynamicAttribute.prototype.update = function update(value, _env) {
        var normalizedValue = normalizeValue(value);
        var _attribute2 = this.attribute,
            element = _attribute2.element,
            name = _attribute2.name;

        if (normalizedValue === null) {
            element.removeAttribute(name);
        } else {
            element.setAttribute(name, normalizedValue);
        }
    };

    return SimpleDynamicAttribute;
}(DynamicAttribute);
var DefaultDynamicProperty = function (_DynamicAttribute2) {
    inherits(DefaultDynamicProperty, _DynamicAttribute2);

    function DefaultDynamicProperty() {
        classCallCheck(this, DefaultDynamicProperty);
        return possibleConstructorReturn(this, _DynamicAttribute2.apply(this, arguments));
    }

    DefaultDynamicProperty.prototype.set = function set$$1(dom, value, _env) {
        if (value !== null && value !== undefined) {
            var name = this.attribute.name;

            this.value = value;
            dom.__setProperty(name, value);
        }
    };

    DefaultDynamicProperty.prototype.update = function update(value, _env) {
        var _attribute3 = this.attribute,
            element = _attribute3.element,
            name = _attribute3.name;

        if (this.value !== value) {
            element[name] = this.value = value;
            if (value === null || value === undefined) {
                this.removeAttribute();
            }
        }
    };

    DefaultDynamicProperty.prototype.removeAttribute = function removeAttribute() {
        // TODO this sucks but to preserve properties first and to meet current
        // semantics we must do this.
        var _attribute4 = this.attribute,
            element = _attribute4.element,
            name = _attribute4.name,
            namespace = _attribute4.namespace;

        if (namespace) {
            element.removeAttributeNS(namespace, name);
        } else {
            element.removeAttribute(name);
        }
    };

    return DefaultDynamicProperty;
}(DynamicAttribute);
var SafeDynamicProperty = function (_DefaultDynamicProper) {
    inherits(SafeDynamicProperty, _DefaultDynamicProper);

    function SafeDynamicProperty() {
        classCallCheck(this, SafeDynamicProperty);
        return possibleConstructorReturn(this, _DefaultDynamicProper.apply(this, arguments));
    }

    SafeDynamicProperty.prototype.set = function set$$1(dom, value, env) {
        var _attribute5 = this.attribute,
            element = _attribute5.element,
            name = _attribute5.name;

        var sanitized = sanitizeAttributeValue(env, element, name, value);
        _DefaultDynamicProper.prototype.set.call(this, dom, sanitized, env);
    };

    SafeDynamicProperty.prototype.update = function update(value, env) {
        var _attribute6 = this.attribute,
            element = _attribute6.element,
            name = _attribute6.name;

        var sanitized = sanitizeAttributeValue(env, element, name, value);
        _DefaultDynamicProper.prototype.update.call(this, sanitized, env);
    };

    return SafeDynamicProperty;
}(DefaultDynamicProperty);
var SafeDynamicAttribute = function (_SimpleDynamicAttribu) {
    inherits(SafeDynamicAttribute, _SimpleDynamicAttribu);

    function SafeDynamicAttribute() {
        classCallCheck(this, SafeDynamicAttribute);
        return possibleConstructorReturn(this, _SimpleDynamicAttribu.apply(this, arguments));
    }

    SafeDynamicAttribute.prototype.set = function set$$1(dom, value, env) {
        var _attribute7 = this.attribute,
            element = _attribute7.element,
            name = _attribute7.name;

        var sanitized = sanitizeAttributeValue(env, element, name, value);
        _SimpleDynamicAttribu.prototype.set.call(this, dom, sanitized, env);
    };

    SafeDynamicAttribute.prototype.update = function update(value, env) {
        var _attribute8 = this.attribute,
            element = _attribute8.element,
            name = _attribute8.name;

        var sanitized = sanitizeAttributeValue(env, element, name, value);
        _SimpleDynamicAttribu.prototype.update.call(this, sanitized, env);
    };

    return SafeDynamicAttribute;
}(SimpleDynamicAttribute);
var InputValueDynamicAttribute = function (_DefaultDynamicProper2) {
    inherits(InputValueDynamicAttribute, _DefaultDynamicProper2);

    function InputValueDynamicAttribute() {
        classCallCheck(this, InputValueDynamicAttribute);
        return possibleConstructorReturn(this, _DefaultDynamicProper2.apply(this, arguments));
    }

    InputValueDynamicAttribute.prototype.set = function set$$1(dom, value) {
        dom.__setProperty('value', normalizeStringValue(value));
    };

    InputValueDynamicAttribute.prototype.update = function update(value) {
        var input = this.attribute.element;
        var currentValue = input.value;
        var normalizedValue = normalizeStringValue(value);
        if (currentValue !== normalizedValue) {
            input.value = normalizedValue;
        }
    };

    return InputValueDynamicAttribute;
}(DefaultDynamicProperty);
var OptionSelectedDynamicAttribute = function (_DefaultDynamicProper3) {
    inherits(OptionSelectedDynamicAttribute, _DefaultDynamicProper3);

    function OptionSelectedDynamicAttribute() {
        classCallCheck(this, OptionSelectedDynamicAttribute);
        return possibleConstructorReturn(this, _DefaultDynamicProper3.apply(this, arguments));
    }

    OptionSelectedDynamicAttribute.prototype.set = function set$$1(dom, value) {
        if (value !== null && value !== undefined && value !== false) {
            dom.__setProperty('selected', true);
        }
    };

    OptionSelectedDynamicAttribute.prototype.update = function update(value) {
        var option = this.attribute.element;
        if (value) {
            option.selected = true;
        } else {
            option.selected = false;
        }
    };

    return OptionSelectedDynamicAttribute;
}(DefaultDynamicProperty);
function isOptionSelected(tagName, attribute) {
    return tagName === 'OPTION' && attribute === 'selected';
}
function isUserInputValue(tagName, attribute) {
    return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';
}
function normalizeValue(value) {
    if (value === false || value === undefined || value === null || typeof value.toString === 'undefined') {
        return null;
    }
    if (value === true) {
        return '';
    }
    // onclick function etc in SSR
    if (typeof value === 'function') {
        return null;
    }
    return String(value);
}

var Scope = function () {
    function Scope(
    // the 0th slot is `self`
    slots, callerScope,
    // named arguments and blocks passed to a layout that uses eval
    evalScope,
    // locals in scope when the partial was invoked
    partialMap) {
        classCallCheck(this, Scope);

        this.slots = slots;
        this.callerScope = callerScope;
        this.evalScope = evalScope;
        this.partialMap = partialMap;
    }

    Scope.root = function root(self) {
        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        var refs = new Array(size + 1);
        for (var i = 0; i <= size; i++) {
            refs[i] = UNDEFINED_REFERENCE;
        }
        return new Scope(refs, null, null, null).init({ self: self });
    };

    Scope.sized = function sized() {
        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        var refs = new Array(size + 1);
        for (var i = 0; i <= size; i++) {
            refs[i] = UNDEFINED_REFERENCE;
        }
        return new Scope(refs, null, null, null);
    };

    Scope.prototype.init = function init(_ref) {
        var self = _ref.self;

        this.slots[0] = self;
        return this;
    };

    Scope.prototype.getSelf = function getSelf() {
        return this.get(0);
    };

    Scope.prototype.getSymbol = function getSymbol(symbol) {
        return this.get(symbol);
    };

    Scope.prototype.getBlock = function getBlock(symbol) {
        return this.get(symbol);
    };

    Scope.prototype.getEvalScope = function getEvalScope() {
        return this.evalScope;
    };

    Scope.prototype.getPartialMap = function getPartialMap() {
        return this.partialMap;
    };

    Scope.prototype.bind = function bind(symbol, value) {
        this.set(symbol, value);
    };

    Scope.prototype.bindSelf = function bindSelf(self) {
        this.set(0, self);
    };

    Scope.prototype.bindSymbol = function bindSymbol(symbol, value) {
        this.set(symbol, value);
    };

    Scope.prototype.bindBlock = function bindBlock(symbol, value) {
        this.set(symbol, value);
    };

    Scope.prototype.bindEvalScope = function bindEvalScope(map) {
        this.evalScope = map;
    };

    Scope.prototype.bindPartialMap = function bindPartialMap(map) {
        this.partialMap = map;
    };

    Scope.prototype.bindCallerScope = function bindCallerScope(scope) {
        this.callerScope = scope;
    };

    Scope.prototype.getCallerScope = function getCallerScope() {
        return this.callerScope;
    };

    Scope.prototype.child = function child() {
        return new Scope(this.slots.slice(), this.callerScope, this.evalScope, this.partialMap);
    };

    Scope.prototype.get = function get$$1(index) {
        if (index >= this.slots.length) {
            throw new RangeError('BUG: cannot get $' + index + ' from scope; length=' + this.slots.length);
        }
        return this.slots[index];
    };

    Scope.prototype.set = function set$$1(index, value) {
        if (index >= this.slots.length) {
            throw new RangeError('BUG: cannot get $' + index + ' from scope; length=' + this.slots.length);
        }
        this.slots[index] = value;
    };

    return Scope;
}();

var Transaction = function () {
    function Transaction() {
        classCallCheck(this, Transaction);

        this.scheduledInstallManagers = [];
        this.scheduledInstallModifiers = [];
        this.scheduledUpdateModifierManagers = [];
        this.scheduledUpdateModifiers = [];
        this.createdComponents = [];
        this.createdManagers = [];
        this.updatedComponents = [];
        this.updatedManagers = [];
        this.destructors = [];
    }

    Transaction.prototype.didCreate = function didCreate(component, manager) {
        this.createdComponents.push(component);
        this.createdManagers.push(manager);
    };

    Transaction.prototype.didUpdate = function didUpdate(component, manager) {
        this.updatedComponents.push(component);
        this.updatedManagers.push(manager);
    };

    Transaction.prototype.scheduleInstallModifier = function scheduleInstallModifier(modifier, manager) {
        this.scheduledInstallManagers.push(manager);
        this.scheduledInstallModifiers.push(modifier);
    };

    Transaction.prototype.scheduleUpdateModifier = function scheduleUpdateModifier(modifier, manager) {
        this.scheduledUpdateModifierManagers.push(manager);
        this.scheduledUpdateModifiers.push(modifier);
    };

    Transaction.prototype.didDestroy = function didDestroy(d) {
        this.destructors.push(d);
    };

    Transaction.prototype.commit = function commit() {
        var createdComponents = this.createdComponents,
            createdManagers = this.createdManagers;

        for (var i = 0; i < createdComponents.length; i++) {
            var component = createdComponents[i];
            var manager = createdManagers[i];
            manager.didCreate(component);
        }
        var updatedComponents = this.updatedComponents,
            updatedManagers = this.updatedManagers;

        for (var _i = 0; _i < updatedComponents.length; _i++) {
            var _component = updatedComponents[_i];
            var _manager = updatedManagers[_i];
            _manager.didUpdate(_component);
        }
        var destructors = this.destructors;

        for (var _i2 = 0; _i2 < destructors.length; _i2++) {
            destructors[_i2].destroy();
        }
        var scheduledInstallManagers = this.scheduledInstallManagers,
            scheduledInstallModifiers = this.scheduledInstallModifiers;

        for (var _i3 = 0; _i3 < scheduledInstallManagers.length; _i3++) {
            var _manager2 = scheduledInstallManagers[_i3];
            var modifier = scheduledInstallModifiers[_i3];
            _manager2.install(modifier);
        }
        var scheduledUpdateModifierManagers = this.scheduledUpdateModifierManagers,
            scheduledUpdateModifiers = this.scheduledUpdateModifiers;

        for (var _i4 = 0; _i4 < scheduledUpdateModifierManagers.length; _i4++) {
            var _manager3 = scheduledUpdateModifierManagers[_i4];
            var _modifier = scheduledUpdateModifiers[_i4];
            _manager3.update(_modifier);
        }
    };

    return Transaction;
}();

var Environment = function () {
    function Environment(_ref2) {
        var appendOperations = _ref2.appendOperations,
            updateOperations = _ref2.updateOperations;
        classCallCheck(this, Environment);

        this._transaction = null;
        this.appendOperations = appendOperations;
        this.updateOperations = updateOperations;
    }

    Environment.prototype.toConditionalReference = function toConditionalReference(reference) {
        return new ConditionalReference$1(reference);
    };

    Environment.prototype.getAppendOperations = function getAppendOperations() {
        return this.appendOperations;
    };

    Environment.prototype.getDOM = function getDOM() {
        return this.updateOperations;
    };

    Environment.prototype.getIdentity = function getIdentity(object) {
        return ensureGuid(object) + '';
    };

    Environment.prototype.begin = function begin() {
        false && debugAssert(!this._transaction, 'a glimmer transaction was begun, but one already exists. You may have a nested transaction');

        this._transaction = new Transaction();
    };

    Environment.prototype.didCreate = function didCreate(component, manager) {
        this.transaction.didCreate(component, manager);
    };

    Environment.prototype.didUpdate = function didUpdate(component, manager) {
        this.transaction.didUpdate(component, manager);
    };

    Environment.prototype.scheduleInstallModifier = function scheduleInstallModifier(modifier, manager) {
        this.transaction.scheduleInstallModifier(modifier, manager);
    };

    Environment.prototype.scheduleUpdateModifier = function scheduleUpdateModifier(modifier, manager) {
        this.transaction.scheduleUpdateModifier(modifier, manager);
    };

    Environment.prototype.didDestroy = function didDestroy(d) {
        this.transaction.didDestroy(d);
    };

    Environment.prototype.commit = function commit() {
        var transaction = this.transaction;
        this._transaction = null;
        transaction.commit();
    };

    Environment.prototype.attributeFor = function attributeFor(element, attr, _isTrusting) {
        var _namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

        return defaultDynamicAttributes(element, attr);
    };

    createClass(Environment, [{
        key: 'transaction',
        get: function get$$1() {
            return this._transaction;
        }
    }]);
    return Environment;
}();
var DefaultEnvironment = function (_Environment) {
    inherits(DefaultEnvironment, _Environment);

    function DefaultEnvironment(options) {
        classCallCheck(this, DefaultEnvironment);

        if (!options) {
            var document = window.document;
            var appendOperations = new DOMTreeConstruction(document);
            var updateOperations = new DOMChanges(document);
            options = { appendOperations: appendOperations, updateOperations: updateOperations };
        }
        return possibleConstructorReturn(this, _Environment.call(this, options));
    }

    return DefaultEnvironment;
}(Environment);

var DynamicContentBase = function () {
    function DynamicContentBase(trusting) {
        classCallCheck(this, DynamicContentBase);

        this.trusting = trusting;
    }

    DynamicContentBase.prototype.retry = function retry(env, value) {
        var bounds$$1 = this.bounds;

        var parentElement = bounds$$1.parentElement();
        var nextSibling = clear(bounds$$1);
        var stack = NewElementBuilder.forInitialRender(env, { element: parentElement, nextSibling: nextSibling });
        if (this.trusting) {
            return stack.__appendTrustingDynamicContent(value);
        } else {
            return stack.__appendCautiousDynamicContent(value);
        }
    };

    return DynamicContentBase;
}();

var DynamicContentWrapper = function () {
    function DynamicContentWrapper(inner) {
        classCallCheck(this, DynamicContentWrapper);

        this.inner = inner;
        this.bounds = inner.bounds;
    }

    DynamicContentWrapper.prototype.parentElement = function parentElement() {
        return this.bounds.parentElement();
    };

    DynamicContentWrapper.prototype.firstNode = function firstNode() {
        return this.bounds.firstNode();
    };

    DynamicContentWrapper.prototype.lastNode = function lastNode() {
        return this.bounds.lastNode();
    };

    DynamicContentWrapper.prototype.update = function update(env, value) {
        var inner = this.inner = this.inner.update(env, value);
        this.bounds = inner.bounds;
        return this;
    };

    return DynamicContentWrapper;
}();

var DynamicTextContent = function (_DynamicContentBase) {
    inherits(DynamicTextContent, _DynamicContentBase);

    function DynamicTextContent(bounds, lastValue, trusted) {
        classCallCheck(this, DynamicTextContent);

        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusted));

        _this.bounds = bounds;
        _this.lastValue = lastValue;
        return _this;
    }

    DynamicTextContent.prototype.update = function update(env, value) {
        var lastValue = this.lastValue;

        if (value === lastValue) return this;
        if (isNode(value) || isSafeString(value)) return this.retry(env, value);
        var normalized = void 0;
        if (isEmpty(value)) {
            normalized = '';
        } else if (isString(value)) {
            normalized = value;
        } else {
            normalized = String(value);
        }
        if (normalized !== lastValue) {
            var textNode = this.bounds.firstNode();
            textNode.nodeValue = this.lastValue = normalized;
        }
        return this;
    };

    return DynamicTextContent;
}(DynamicContentBase);

var DynamicNodeContent = function (_DynamicContentBase) {
    inherits(DynamicNodeContent, _DynamicContentBase);

    function DynamicNodeContent(bounds, lastValue, trusting) {
        classCallCheck(this, DynamicNodeContent);

        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusting));

        _this.bounds = bounds;
        _this.lastValue = lastValue;
        return _this;
    }

    DynamicNodeContent.prototype.update = function update(env, value) {
        var lastValue = this.lastValue;

        if (value === lastValue) return this;
        return this.retry(env, value);
    };

    return DynamicNodeContent;
}(DynamicContentBase);

var DynamicHTMLContent = function (_DynamicContentBase) {
    inherits(DynamicHTMLContent, _DynamicContentBase);

    function DynamicHTMLContent(bounds, lastValue, trusted) {
        classCallCheck(this, DynamicHTMLContent);

        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusted));

        _this.bounds = bounds;
        _this.lastValue = lastValue;
        return _this;
    }

    DynamicHTMLContent.prototype.update = function update(env, value) {
        var lastValue = this.lastValue;

        if (value === lastValue) return this;
        if (isSafeString(value) && value.toHTML() === lastValue.toHTML()) {
            this.lastValue = value;
            return this;
        }
        return this.retry(env, value);
    };

    return DynamicHTMLContent;
}(DynamicContentBase);

var DynamicTrustedHTMLContent = function (_DynamicContentBase2) {
    inherits(DynamicTrustedHTMLContent, _DynamicContentBase2);

    function DynamicTrustedHTMLContent(bounds, lastValue, trusted) {
        classCallCheck(this, DynamicTrustedHTMLContent);

        var _this2 = possibleConstructorReturn(this, _DynamicContentBase2.call(this, trusted));

        _this2.bounds = bounds;
        _this2.lastValue = lastValue;
        return _this2;
    }

    DynamicTrustedHTMLContent.prototype.update = function update(env, value) {
        var lastValue = this.lastValue;

        if (value === lastValue) return this;
        var newValue = normalizeTrustedValue(value);
        if (newValue === lastValue) return this;
        return this.retry(env, value);
    };

    return DynamicTrustedHTMLContent;
}(DynamicContentBase);

var First = function () {
    function First(node) {
        classCallCheck(this, First);

        this.node = node;
    }

    First.prototype.firstNode = function firstNode() {
        return this.node;
    };

    return First;
}();

var Last = function () {
    function Last(node) {
        classCallCheck(this, Last);

        this.node = node;
    }

    Last.prototype.lastNode = function lastNode() {
        return this.node;
    };

    return Last;
}();


var NewElementBuilder = function () {
    function NewElementBuilder(env, parentNode, nextSibling) {
        classCallCheck(this, NewElementBuilder);

        this.constructing = null;
        this.operations = null;
        this.cursorStack = new Stack();
        this.blockStack = new Stack();
        this.pushElement(parentNode, nextSibling);
        this.env = env;
        this.dom = env.getAppendOperations();
        this.updateOperations = env.getDOM();
    }

    NewElementBuilder.forInitialRender = function forInitialRender(env, cursor) {
        var builder = new this(env, cursor.element, cursor.nextSibling);
        builder.pushSimpleBlock();
        return builder;
    };

    NewElementBuilder.resume = function resume(env, tracker, nextSibling) {
        var parentNode = tracker.parentElement();
        var stack = new this(env, parentNode, nextSibling);
        stack.pushSimpleBlock();
        stack.pushBlockTracker(tracker);
        return stack;
    };

    NewElementBuilder.prototype.expectConstructing = function expectConstructing(method) {
        return this.constructing;
    };

    NewElementBuilder.prototype.block = function block() {
        return this.blockStack.current;
    };

    NewElementBuilder.prototype.popElement = function popElement() {
        this.cursorStack.pop();
        this.cursorStack.current;
    };

    NewElementBuilder.prototype.pushSimpleBlock = function pushSimpleBlock() {
        return this.pushBlockTracker(new SimpleBlockTracker(this.element));
    };

    NewElementBuilder.prototype.pushUpdatableBlock = function pushUpdatableBlock() {
        return this.pushBlockTracker(new UpdatableBlockTracker(this.element));
    };

    NewElementBuilder.prototype.pushBlockList = function pushBlockList(list) {
        return this.pushBlockTracker(new BlockListTracker(this.element, list));
    };

    NewElementBuilder.prototype.pushBlockTracker = function pushBlockTracker(tracker) {
        var isRemote = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var current = this.blockStack.current;
        if (current !== null) {
            current.newDestroyable(tracker);
            if (!isRemote) {
                current.didAppendBounds(tracker);
            }
        }
        this.__openBlock();
        this.blockStack.push(tracker);
        return tracker;
    };

    NewElementBuilder.prototype.popBlock = function popBlock() {
        this.block().finalize(this);
        this.__closeBlock();
        return this.blockStack.pop();
    };

    NewElementBuilder.prototype.__openBlock = function __openBlock() {};

    NewElementBuilder.prototype.__closeBlock = function __closeBlock() {};
    // todo return seems unused


    NewElementBuilder.prototype.openElement = function openElement(tag) {
        var element = this.__openElement(tag);
        this.constructing = element;
        return element;
    };

    NewElementBuilder.prototype.__openElement = function __openElement(tag) {
        return this.dom.createElement(tag, this.element);
    };

    NewElementBuilder.prototype.flushElement = function flushElement() {
        var parent = this.element;
        var element = this.constructing;
        this.__flushElement(parent, element);
        this.constructing = null;
        this.operations = null;
        this.pushElement(element, null);
        this.didOpenElement(element);
    };

    NewElementBuilder.prototype.__flushElement = function __flushElement(parent, constructing) {
        this.dom.insertBefore(parent, constructing, this.nextSibling);
    };

    NewElementBuilder.prototype.closeElement = function closeElement() {
        this.willCloseElement();
        this.popElement();
    };

    NewElementBuilder.prototype.pushRemoteElement = function pushRemoteElement(element, guid) {
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this.__pushRemoteElement(element, guid, nextSibling);
    };

    NewElementBuilder.prototype.__pushRemoteElement = function __pushRemoteElement(element, _guid, nextSibling) {
        this.pushElement(element, nextSibling);
        var tracker = new RemoteBlockTracker(element);
        this.pushBlockTracker(tracker, true);
    };

    NewElementBuilder.prototype.popRemoteElement = function popRemoteElement() {
        this.popBlock();
        this.popElement();
    };

    NewElementBuilder.prototype.pushElement = function pushElement(element, nextSibling) {
        this.cursorStack.push(new Cursor(element, nextSibling));
    };

    NewElementBuilder.prototype.didAddDestroyable = function didAddDestroyable(d) {
        this.block().newDestroyable(d);
    };

    NewElementBuilder.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {
        this.block().didAppendBounds(bounds$$1);
        return bounds$$1;
    };

    NewElementBuilder.prototype.didAppendNode = function didAppendNode(node) {
        this.block().didAppendNode(node);
        return node;
    };

    NewElementBuilder.prototype.didOpenElement = function didOpenElement(element) {
        this.block().openElement(element);
        return element;
    };

    NewElementBuilder.prototype.willCloseElement = function willCloseElement() {
        this.block().closeElement();
    };

    NewElementBuilder.prototype.appendText = function appendText(string) {
        return this.didAppendNode(this.__appendText(string));
    };

    NewElementBuilder.prototype.__appendText = function __appendText(text) {
        var dom = this.dom,
            element = this.element,
            nextSibling = this.nextSibling;

        var node = dom.createTextNode(text);
        dom.insertBefore(element, node, nextSibling);
        return node;
    };

    NewElementBuilder.prototype.__appendNode = function __appendNode(node) {
        this.dom.insertBefore(this.element, node, this.nextSibling);
        return node;
    };

    NewElementBuilder.prototype.__appendFragment = function __appendFragment(fragment) {
        var first = fragment.firstChild;
        if (first) {
            var ret = bounds(this.element, first, fragment.lastChild);
            this.dom.insertBefore(this.element, fragment, this.nextSibling);
            return ret;
        } else {
            return single(this.element, this.__appendComment(''));
        }
    };

    NewElementBuilder.prototype.__appendHTML = function __appendHTML(html) {
        return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);
    };

    NewElementBuilder.prototype.appendTrustingDynamicContent = function appendTrustingDynamicContent(value) {
        var wrapper = new DynamicContentWrapper(this.__appendTrustingDynamicContent(value));
        this.didAppendBounds(wrapper);
        return wrapper;
    };

    NewElementBuilder.prototype.__appendTrustingDynamicContent = function __appendTrustingDynamicContent(value) {
        if (isString(value)) {
            return this.trustedContent(value);
        } else if (isEmpty(value)) {
            return this.trustedContent('');
        } else if (isSafeString(value)) {
            return this.trustedContent(value.toHTML());
        }
        if (isFragment(value)) {
            var _bounds2 = this.__appendFragment(value);
            return new DynamicNodeContent(_bounds2, value, true);
        } else if (isNode(value)) {
            var node = this.__appendNode(value);
            return new DynamicNodeContent(single(this.element, node), node, true);
        }
        return this.trustedContent(String(value));
    };

    NewElementBuilder.prototype.appendCautiousDynamicContent = function appendCautiousDynamicContent(value) {
        var wrapper = new DynamicContentWrapper(this.__appendCautiousDynamicContent(value));
        this.didAppendBounds(wrapper.bounds);
        return wrapper;
    };

    NewElementBuilder.prototype.__appendCautiousDynamicContent = function __appendCautiousDynamicContent(value) {
        if (isString(value)) {
            return this.untrustedContent(value);
        } else if (isEmpty(value)) {
            return this.untrustedContent('');
        } else if (isFragment(value)) {
            var _bounds3 = this.__appendFragment(value);
            return new DynamicNodeContent(_bounds3, value, false);
        } else if (isNode(value)) {
            var node = this.__appendNode(value);
            return new DynamicNodeContent(single(this.element, node), node, false);
        } else if (isSafeString(value)) {
            var normalized = value.toHTML();
            var _bounds4 = this.__appendHTML(normalized);
            // let bounds = this.dom.insertHTMLBefore(this.element, this.nextSibling, normalized);
            return new DynamicHTMLContent(_bounds4, value, false);
        }
        return this.untrustedContent(String(value));
    };

    NewElementBuilder.prototype.trustedContent = function trustedContent(value) {
        var bounds$$1 = this.__appendHTML(value);
        return new DynamicTrustedHTMLContent(bounds$$1, value, true);
    };

    NewElementBuilder.prototype.untrustedContent = function untrustedContent(value) {
        var textNode = this.__appendText(value);
        var bounds$$1 = single(this.element, textNode);
        return new DynamicTextContent(bounds$$1, value, false);
    };

    NewElementBuilder.prototype.appendComment = function appendComment(string) {
        return this.didAppendNode(this.__appendComment(string));
    };

    NewElementBuilder.prototype.__appendComment = function __appendComment(string) {
        var dom = this.dom,
            element = this.element,
            nextSibling = this.nextSibling;

        var node = dom.createComment(string);
        dom.insertBefore(element, node, nextSibling);
        return node;
    };

    NewElementBuilder.prototype.__setAttribute = function __setAttribute(name, value, namespace) {
        this.dom.setAttribute(this.constructing, name, value, namespace);
    };

    NewElementBuilder.prototype.__setProperty = function __setProperty(name, value) {
        this.constructing[name] = value;
    };

    NewElementBuilder.prototype.setStaticAttribute = function setStaticAttribute(name, value, namespace) {
        this.__setAttribute(name, value, namespace);
    };

    NewElementBuilder.prototype.setDynamicAttribute = function setDynamicAttribute(name, value, trusting, namespace) {
        var element = this.constructing;
        var DynamicAttribute = this.env.attributeFor(element, name, trusting, namespace);
        var attribute = new DynamicAttribute({ element: element, name: name, namespace: namespace || null });
        attribute.set(this, value, this.env);
        return attribute;
    };

    createClass(NewElementBuilder, [{
        key: 'element',
        get: function get$$1() {
            return this.cursorStack.current.element;
        }
    }, {
        key: 'nextSibling',
        get: function get$$1() {
            return this.cursorStack.current.nextSibling;
        }
    }]);
    return NewElementBuilder;
}();
var SimpleBlockTracker = function () {
    function SimpleBlockTracker(parent) {
        classCallCheck(this, SimpleBlockTracker);

        this.parent = parent;
        this.first = null;
        this.last = null;
        this.destroyables = null;
        this.nesting = 0;
    }

    SimpleBlockTracker.prototype.destroy = function destroy() {
        var destroyables = this.destroyables;

        if (destroyables && destroyables.length) {
            for (var i = 0; i < destroyables.length; i++) {
                destroyables[i].destroy();
            }
        }
    };

    SimpleBlockTracker.prototype.parentElement = function parentElement() {
        return this.parent;
    };

    SimpleBlockTracker.prototype.firstNode = function firstNode() {
        return this.first && this.first.firstNode();
    };

    SimpleBlockTracker.prototype.lastNode = function lastNode() {
        return this.last && this.last.lastNode();
    };

    SimpleBlockTracker.prototype.openElement = function openElement(element) {
        this.didAppendNode(element);
        this.nesting++;
    };

    SimpleBlockTracker.prototype.closeElement = function closeElement() {
        this.nesting--;
    };

    SimpleBlockTracker.prototype.didAppendNode = function didAppendNode(node) {
        if (this.nesting !== 0) return;
        if (!this.first) {
            this.first = new First(node);
        }
        this.last = new Last(node);
    };

    SimpleBlockTracker.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {
        if (this.nesting !== 0) return;
        if (!this.first) {
            this.first = bounds$$1;
        }
        this.last = bounds$$1;
    };

    SimpleBlockTracker.prototype.newDestroyable = function newDestroyable(d) {
        this.destroyables = this.destroyables || [];
        this.destroyables.push(d);
    };

    SimpleBlockTracker.prototype.finalize = function finalize(stack) {
        if (!this.first) {
            stack.appendComment('');
        }
    };

    return SimpleBlockTracker;
}();
var RemoteBlockTracker = function (_SimpleBlockTracker) {
    inherits(RemoteBlockTracker, _SimpleBlockTracker);

    function RemoteBlockTracker() {
        classCallCheck(this, RemoteBlockTracker);
        return possibleConstructorReturn(this, _SimpleBlockTracker.apply(this, arguments));
    }

    RemoteBlockTracker.prototype.destroy = function destroy() {
        _SimpleBlockTracker.prototype.destroy.call(this);
        clear(this);
    };

    return RemoteBlockTracker;
}(SimpleBlockTracker);
var UpdatableBlockTracker = function (_SimpleBlockTracker2) {
    inherits(UpdatableBlockTracker, _SimpleBlockTracker2);

    function UpdatableBlockTracker() {
        classCallCheck(this, UpdatableBlockTracker);
        return possibleConstructorReturn(this, _SimpleBlockTracker2.apply(this, arguments));
    }

    UpdatableBlockTracker.prototype.reset = function reset(env) {
        var destroyables = this.destroyables;

        if (destroyables && destroyables.length) {
            for (var i = 0; i < destroyables.length; i++) {
                env.didDestroy(destroyables[i]);
            }
        }
        var nextSibling = clear(this);
        this.first = null;
        this.last = null;
        this.destroyables = null;
        this.nesting = 0;
        return nextSibling;
    };

    return UpdatableBlockTracker;
}(SimpleBlockTracker);

var BlockListTracker = function () {
    function BlockListTracker(parent, boundList) {
        classCallCheck(this, BlockListTracker);

        this.parent = parent;
        this.boundList = boundList;
        this.parent = parent;
        this.boundList = boundList;
    }

    BlockListTracker.prototype.destroy = function destroy() {
        this.boundList.forEachNode(function (node) {
            return node.destroy();
        });
    };

    BlockListTracker.prototype.parentElement = function parentElement() {
        return this.parent;
    };

    BlockListTracker.prototype.firstNode = function firstNode() {
        var head = this.boundList.head();
        return head && head.firstNode();
    };

    BlockListTracker.prototype.lastNode = function lastNode() {
        var tail = this.boundList.tail();
        return tail && tail.lastNode();
    };

    BlockListTracker.prototype.openElement = function openElement(_element) {
        false && debugAssert(false, 'Cannot openElement directly inside a block list');
    };

    BlockListTracker.prototype.closeElement = function closeElement() {
        false && debugAssert(false, 'Cannot closeElement directly inside a block list');
    };

    BlockListTracker.prototype.didAppendNode = function didAppendNode(_node) {
        false && debugAssert(false, 'Cannot create a new node directly inside a block list');
    };

    BlockListTracker.prototype.didAppendBounds = function didAppendBounds(_bounds) {};

    BlockListTracker.prototype.newDestroyable = function newDestroyable(_d) {};

    BlockListTracker.prototype.finalize = function finalize(_stack) {};

    return BlockListTracker;
}();

function clientBuilder(env, cursor) {
    return NewElementBuilder.forInitialRender(env, cursor);
}

var UpdatingVM = function () {
    function UpdatingVM(env, program, _ref) {
        var _ref$alwaysRevalidate = _ref.alwaysRevalidate,
            alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;
        classCallCheck(this, UpdatingVM);

        this.frameStack = new Stack();
        this.env = env;
        this.constants = program.constants;
        this.dom = env.getDOM();
        this.alwaysRevalidate = alwaysRevalidate;
    }

    UpdatingVM.prototype.execute = function execute(opcodes, handler) {
        var frameStack = this.frameStack;

        this.try(opcodes, handler);
        while (true) {
            if (frameStack.isEmpty()) break;
            var opcode = this.frame.nextStatement();
            if (opcode === null) {
                this.frameStack.pop();
                continue;
            }
            opcode.evaluate(this);
        }
    };

    UpdatingVM.prototype.goto = function goto(op) {
        this.frame.goto(op);
    };

    UpdatingVM.prototype.try = function _try(ops, handler) {
        this.frameStack.push(new UpdatingVMFrame(this, ops, handler));
    };

    UpdatingVM.prototype.throw = function _throw() {
        this.frame.handleException();
        this.frameStack.pop();
    };

    createClass(UpdatingVM, [{
        key: 'frame',
        get: function get$$1() {
            return this.frameStack.current;
        }
    }]);
    return UpdatingVM;
}();

var BlockOpcode = function (_UpdatingOpcode) {
    inherits(BlockOpcode, _UpdatingOpcode);

    function BlockOpcode(start, state, bounds$$1, children) {
        classCallCheck(this, BlockOpcode);

        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));

        _this.start = start;
        _this.state = state;
        _this.type = "block";
        _this.next = null;
        _this.prev = null;
        _this.children = children;
        _this.bounds = bounds$$1;
        return _this;
    }

    BlockOpcode.prototype.parentElement = function parentElement() {
        return this.bounds.parentElement();
    };

    BlockOpcode.prototype.firstNode = function firstNode() {
        return this.bounds.firstNode();
    };

    BlockOpcode.prototype.lastNode = function lastNode() {
        return this.bounds.lastNode();
    };

    BlockOpcode.prototype.evaluate = function evaluate(vm) {
        vm.try(this.children, null);
    };

    BlockOpcode.prototype.destroy = function destroy() {
        this.bounds.destroy();
    };

    BlockOpcode.prototype.didDestroy = function didDestroy() {
        this.state.env.didDestroy(this.bounds);
    };

    return BlockOpcode;
}(UpdatingOpcode);
var TryOpcode = function (_BlockOpcode) {
    inherits(TryOpcode, _BlockOpcode);

    function TryOpcode(start, state, bounds$$1, children) {
        classCallCheck(this, TryOpcode);

        var _this2 = possibleConstructorReturn(this, _BlockOpcode.call(this, start, state, bounds$$1, children));

        _this2.type = "try";
        _this2.tag = _this2._tag = UpdatableTag.create(CONSTANT_TAG);
        return _this2;
    }

    TryOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
        this._tag.inner.update(combineSlice(this.children));
    };

    TryOpcode.prototype.evaluate = function evaluate(vm) {
        vm.try(this.children, this);
    };

    TryOpcode.prototype.handleException = function handleException() {
        var _this3 = this;

        var state = this.state,
            bounds$$1 = this.bounds,
            children = this.children,
            start = this.start,
            prev = this.prev,
            next = this.next;

        children.clear();
        var elementStack = NewElementBuilder.resume(state.env, bounds$$1, bounds$$1.reset(state.env));
        var vm = VM.resume(state, elementStack);
        var updating = new LinkedList();
        vm.execute(start, function (vm) {
            vm.stack = EvaluationStack.restore(state.stack);
            vm.updatingOpcodeStack.push(updating);
            vm.updateWith(_this3);
            vm.updatingOpcodeStack.push(children);
        });
        this.prev = prev;
        this.next = next;
    };

    return TryOpcode;
}(BlockOpcode);

var ListRevalidationDelegate = function () {
    function ListRevalidationDelegate(opcode, marker) {
        classCallCheck(this, ListRevalidationDelegate);

        this.opcode = opcode;
        this.marker = marker;
        this.didInsert = false;
        this.didDelete = false;
        this.map = opcode.map;
        this.updating = opcode['children'];
    }

    ListRevalidationDelegate.prototype.insert = function insert(key, item, memo, before) {
        var map$$1 = this.map,
            opcode = this.opcode,
            updating = this.updating;

        var nextSibling = null;
        var reference = null;
        if (before) {
            reference = map$$1[before];
            nextSibling = reference['bounds'].firstNode();
        } else {
            nextSibling = this.marker;
        }
        var vm = opcode.vmForInsertion(nextSibling);
        var tryOpcode = null;
        var start = opcode.start;

        vm.execute(start, function (vm) {
            map$$1[key] = tryOpcode = vm.iterate(memo, item);
            vm.updatingOpcodeStack.push(new LinkedList());
            vm.updateWith(tryOpcode);
            vm.updatingOpcodeStack.push(tryOpcode.children);
        });
        updating.insertBefore(tryOpcode, reference);
        this.didInsert = true;
    };

    ListRevalidationDelegate.prototype.retain = function retain(_key, _item, _memo) {};

    ListRevalidationDelegate.prototype.move = function move$$1(key, _item, _memo, before) {
        var map$$1 = this.map,
            updating = this.updating;

        var entry = map$$1[key];
        var reference = map$$1[before] || null;
        if (before) {
            move(entry, reference.firstNode());
        } else {
            move(entry, this.marker);
        }
        updating.remove(entry);
        updating.insertBefore(entry, reference);
    };

    ListRevalidationDelegate.prototype.delete = function _delete(key) {
        var map$$1 = this.map;

        var opcode = map$$1[key];
        opcode.didDestroy();
        clear(opcode);
        this.updating.remove(opcode);
        delete map$$1[key];
        this.didDelete = true;
    };

    ListRevalidationDelegate.prototype.done = function done() {
        this.opcode.didInitializeChildren(this.didInsert || this.didDelete);
    };

    return ListRevalidationDelegate;
}();

var ListBlockOpcode = function (_BlockOpcode2) {
    inherits(ListBlockOpcode, _BlockOpcode2);

    function ListBlockOpcode(start, state, bounds$$1, children, artifacts) {
        classCallCheck(this, ListBlockOpcode);

        var _this4 = possibleConstructorReturn(this, _BlockOpcode2.call(this, start, state, bounds$$1, children));

        _this4.type = "list-block";
        _this4.map = dict();
        _this4.lastIterated = INITIAL;
        _this4.artifacts = artifacts;
        var _tag = _this4._tag = UpdatableTag.create(CONSTANT_TAG);
        _this4.tag = combine([artifacts.tag, _tag]);
        return _this4;
    }

    ListBlockOpcode.prototype.didInitializeChildren = function didInitializeChildren() {
        var listDidChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        this.lastIterated = this.artifacts.tag.value();
        if (listDidChange) {
            this._tag.inner.update(combineSlice(this.children));
        }
    };

    ListBlockOpcode.prototype.evaluate = function evaluate(vm) {
        var artifacts = this.artifacts,
            lastIterated = this.lastIterated;

        if (!artifacts.tag.validate(lastIterated)) {
            var bounds$$1 = this.bounds;
            var dom = vm.dom;

            var marker = dom.createComment('');
            dom.insertAfter(bounds$$1.parentElement(), marker, bounds$$1.lastNode());
            var target = new ListRevalidationDelegate(this, marker);
            var synchronizer = new IteratorSynchronizer({ target: target, artifacts: artifacts });
            synchronizer.sync();
            this.parentElement().removeChild(marker);
        }
        // Run now-updated updating opcodes
        _BlockOpcode2.prototype.evaluate.call(this, vm);
    };

    ListBlockOpcode.prototype.vmForInsertion = function vmForInsertion(nextSibling) {
        var bounds$$1 = this.bounds,
            state = this.state;

        var elementStack = NewElementBuilder.forInitialRender(state.env, { element: bounds$$1.parentElement(), nextSibling: nextSibling });
        return VM.resume(state, elementStack);
    };

    return ListBlockOpcode;
}(BlockOpcode);

var UpdatingVMFrame = function () {
    function UpdatingVMFrame(vm, ops, exceptionHandler) {
        classCallCheck(this, UpdatingVMFrame);

        this.vm = vm;
        this.ops = ops;
        this.exceptionHandler = exceptionHandler;
        this.vm = vm;
        this.ops = ops;
        this.current = ops.head();
    }

    UpdatingVMFrame.prototype.goto = function goto(op) {
        this.current = op;
    };

    UpdatingVMFrame.prototype.nextStatement = function nextStatement() {
        var current = this.current,
            ops = this.ops;

        if (current) this.current = ops.nextNode(current);
        return current;
    };

    UpdatingVMFrame.prototype.handleException = function handleException() {
        if (this.exceptionHandler) {
            this.exceptionHandler.handleException();
        }
    };

    return UpdatingVMFrame;
}();

var RenderResult = function () {
    function RenderResult(env, program, updating, bounds$$1) {
        classCallCheck(this, RenderResult);

        this.env = env;
        this.program = program;
        this.updating = updating;
        this.bounds = bounds$$1;
    }

    RenderResult.prototype.rerender = function rerender() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { alwaysRevalidate: false },
            _ref$alwaysRevalidate = _ref.alwaysRevalidate,
            alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;

        var env = this.env,
            program = this.program,
            updating = this.updating;

        var vm = new UpdatingVM(env, program, { alwaysRevalidate: alwaysRevalidate });
        vm.execute(updating, this);
    };

    RenderResult.prototype.parentElement = function parentElement() {
        return this.bounds.parentElement();
    };

    RenderResult.prototype.firstNode = function firstNode() {
        return this.bounds.firstNode();
    };

    RenderResult.prototype.lastNode = function lastNode() {
        return this.bounds.lastNode();
    };

    RenderResult.prototype.handleException = function handleException() {
        throw "this should never happen";
    };

    RenderResult.prototype.destroy = function destroy() {
        this.bounds.destroy();
        clear(this.bounds);
    };

    return RenderResult;
}();

var EvaluationStack = function () {
    function EvaluationStack(stack, fp, sp) {
        classCallCheck(this, EvaluationStack);

        this.stack = stack;
        this.fp = fp;
        this.sp = sp;
        
    }

    EvaluationStack.empty = function empty() {
        return new this([], 0, -1);
    };

    EvaluationStack.restore = function restore(snapshot) {
        return new this(snapshot.slice(), 0, snapshot.length - 1);
    };

    EvaluationStack.prototype.push = function push(value) {
        this.stack[++this.sp] = value;
    };

    EvaluationStack.prototype.dup = function dup() {
        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.sp;

        this.push(this.stack[position]);
    };

    EvaluationStack.prototype.pop = function pop() {
        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

        var top = this.stack[this.sp];
        this.sp -= n;
        return top;
    };

    EvaluationStack.prototype.peek = function peek() {
        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

        return this.stack[this.sp - offset];
    };

    EvaluationStack.prototype.get = function get$$1(offset) {
        var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.fp;

        return this.stack[base + offset];
    };

    EvaluationStack.prototype.set = function set$$1(value, offset) {
        var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.fp;

        this.stack[base + offset] = value;
    };

    EvaluationStack.prototype.slice = function slice(start, end) {
        return this.stack.slice(start, end);
    };

    EvaluationStack.prototype.capture = function capture(items) {
        var end = this.sp + 1;
        var start = end - items;
        return this.stack.slice(start, end);
    };

    EvaluationStack.prototype.reset = function reset() {
        this.stack.length = 0;
    };

    EvaluationStack.prototype.toArray = function toArray$$1() {
        return this.stack.slice(this.fp, this.sp + 1);
    };

    return EvaluationStack;
}();

var VM = function () {
    function VM(program, env, scope, dynamicScope, elementStack) {
        classCallCheck(this, VM);

        this.program = program;
        this.env = env;
        this.elementStack = elementStack;
        this.dynamicScopeStack = new Stack();
        this.scopeStack = new Stack();
        this.updatingOpcodeStack = new Stack();
        this.cacheGroups = new Stack();
        this.listBlockStack = new Stack();
        this.stack = EvaluationStack.empty();
        /* Registers */
        this._pc = -1;
        this.ra = -1;
        this.currentOpSize = 0;
        this.s0 = null;
        this.s1 = null;
        this.t0 = null;
        this.t1 = null;
        this.v0 = null;
        this.env = env;
        this.heap = program.heap;
        this.constants = program.constants;
        this.elementStack = elementStack;
        this.scopeStack.push(scope);
        this.dynamicScopeStack.push(dynamicScope);
    }

    // Fetch a value from a register onto the stack
    VM.prototype.fetch = function fetch(register) {
        this.stack.push(this[Register[register]]);
    };
    // Load a value from the stack into a register


    VM.prototype.load = function load(register) {
        this[Register[register]] = this.stack.pop();
    };
    // Fetch a value from a register


    VM.prototype.fetchValue = function fetchValue(register) {
        return this[Register[register]];
    };
    // Load a value into a register


    VM.prototype.loadValue = function loadValue(register, value) {
        this[Register[register]] = value;
    };
    // Start a new frame and save $ra and $fp on the stack


    VM.prototype.pushFrame = function pushFrame() {
        this.stack.push(this.ra);
        this.stack.push(this.fp);
        this.fp = this.sp - 1;
    };
    // Restore $ra, $sp and $fp


    VM.prototype.popFrame = function popFrame() {
        this.sp = this.fp - 1;
        this.ra = this.stack.get(0);
        this.fp = this.stack.get(1);
    };
    // Jump to an address in `program`


    VM.prototype.goto = function goto(offset) {
        var addr = this.pc + offset - this.currentOpSize;
        this.pc = addr;
    };
    // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)


    VM.prototype.call = function call(handle) {
        this.ra = this.pc;
        this.pc = this.heap.getaddr(handle);
    };
    // Put a specific `program` address in $ra


    VM.prototype.returnTo = function returnTo(offset) {
        var addr = this.pc + offset - this.currentOpSize;
        this.ra = addr;
    };
    // Return to the `program` address stored in $ra


    VM.prototype.return = function _return() {
        this.pc = this.ra;
    };

    VM.initial = function initial(program, env, self, args, dynamicScope, elementStack, handle) {
        var scopeSize = program.heap.scopesizeof(handle);
        var scope = Scope.root(self, scopeSize);
        if (args) {}
        var vm = new VM(program, env, scope, dynamicScope, elementStack);
        vm.pc = vm.heap.getaddr(handle);
        vm.updatingOpcodeStack.push(new LinkedList());
        return vm;
    };

    VM.resume = function resume(_ref, stack) {
        var program = _ref.program,
            env = _ref.env,
            scope = _ref.scope,
            dynamicScope = _ref.dynamicScope;

        return new VM(program, env, scope, dynamicScope, stack);
    };

    VM.prototype.capture = function capture(args) {
        return {
            env: this.env,
            program: this.program,
            dynamicScope: this.dynamicScope(),
            scope: this.scope(),
            stack: this.stack.capture(args)
        };
    };

    VM.prototype.beginCacheGroup = function beginCacheGroup() {
        this.cacheGroups.push(this.updating().tail());
    };

    VM.prototype.commitCacheGroup = function commitCacheGroup() {
        //        JumpIfNotModified(END)
        //        (head)
        //        (....)
        //        (tail)
        //        DidModify
        // END:   Noop
        var END = new LabelOpcode("END");
        var opcodes = this.updating();
        var marker = this.cacheGroups.pop();
        var head = marker ? opcodes.nextNode(marker) : opcodes.head();
        var tail = opcodes.tail();
        var tag = combineSlice(new ListSlice(head, tail));
        var guard = new JumpIfNotModifiedOpcode(tag, END);
        opcodes.insertBefore(guard, head);
        opcodes.append(new DidModifyOpcode(guard));
        opcodes.append(END);
    };

    VM.prototype.enter = function enter(args) {
        var updating = new LinkedList();
        var state = this.capture(args);
        var tracker = this.elements().pushUpdatableBlock();
        var tryOpcode = new TryOpcode(this.heap.gethandle(this.pc), state, tracker, updating);
        this.didEnter(tryOpcode);
    };

    VM.prototype.iterate = function iterate(memo, value) {
        var stack = this.stack;
        stack.push(value);
        stack.push(memo);
        var state = this.capture(2);
        var tracker = this.elements().pushUpdatableBlock();
        // let ip = this.ip;
        // this.ip = end + 4;
        // this.frames.push(ip);
        return new TryOpcode(this.heap.gethandle(this.pc), state, tracker, new LinkedList());
    };

    VM.prototype.enterItem = function enterItem(key, opcode) {
        this.listBlock().map[key] = opcode;
        this.didEnter(opcode);
    };

    VM.prototype.enterList = function enterList(relativeStart) {
        var updating = new LinkedList();
        var state = this.capture(0);
        var tracker = this.elements().pushBlockList(updating);
        var artifacts = this.stack.peek().artifacts;
        var addr = this.pc + relativeStart - this.currentOpSize;
        var start = this.heap.gethandle(addr);
        var opcode = new ListBlockOpcode(start, state, tracker, updating, artifacts);
        this.listBlockStack.push(opcode);
        this.didEnter(opcode);
    };

    VM.prototype.didEnter = function didEnter(opcode) {
        this.updateWith(opcode);
        this.updatingOpcodeStack.push(opcode.children);
    };

    VM.prototype.exit = function exit() {
        this.elements().popBlock();
        this.updatingOpcodeStack.pop();
        var parent = this.updating().tail();
        parent.didInitializeChildren();
    };

    VM.prototype.exitList = function exitList() {
        this.exit();
        this.listBlockStack.pop();
    };

    VM.prototype.updateWith = function updateWith(opcode) {
        this.updating().append(opcode);
    };

    VM.prototype.listBlock = function listBlock() {
        return this.listBlockStack.current;
    };

    VM.prototype.updating = function updating() {
        return this.updatingOpcodeStack.current;
    };

    VM.prototype.elements = function elements() {
        return this.elementStack;
    };

    VM.prototype.scope = function scope() {
        return this.scopeStack.current;
    };

    VM.prototype.dynamicScope = function dynamicScope() {
        return this.dynamicScopeStack.current;
    };

    VM.prototype.pushChildScope = function pushChildScope() {
        this.scopeStack.push(this.scope().child());
    };

    VM.prototype.pushDynamicScope = function pushDynamicScope() {
        var child = this.dynamicScope().child();
        this.dynamicScopeStack.push(child);
        return child;
    };

    VM.prototype.pushRootScope = function pushRootScope(size, bindCaller) {
        var scope = Scope.sized(size);
        if (bindCaller) scope.bindCallerScope(this.scope());
        this.scopeStack.push(scope);
        return scope;
    };

    VM.prototype.pushScope = function pushScope(scope) {
        this.scopeStack.push(scope);
    };

    VM.prototype.popScope = function popScope() {
        this.scopeStack.pop();
    };

    VM.prototype.popDynamicScope = function popDynamicScope() {
        this.dynamicScopeStack.pop();
    };

    VM.prototype.newDestroyable = function newDestroyable(d) {
        this.elements().didAddDestroyable(d);
    };
    /// SCOPE HELPERS


    VM.prototype.getSelf = function getSelf() {
        return this.scope().getSelf();
    };

    VM.prototype.referenceForSymbol = function referenceForSymbol(symbol) {
        return this.scope().getSymbol(symbol);
    };
    /// EXECUTION


    VM.prototype.execute = function execute(start, initialize) {
        this.pc = this.heap.getaddr(start);
        if (initialize) initialize(this);
        var result = void 0;
        while (true) {
            result = this.next();
            if (result.done) break;
        }
        return result.value;
    };

    VM.prototype.next = function next() {
        var env = this.env,
            program = this.program,
            updatingOpcodeStack = this.updatingOpcodeStack,
            elementStack = this.elementStack;

        var opcode = this.nextStatement();
        var result = void 0;
        if (opcode !== null) {
            APPEND_OPCODES.evaluate(this, opcode, opcode.type);
            result = { done: false, value: null };
        } else {
            // Unload the stack
            this.stack.reset();
            result = {
                done: true,
                value: new RenderResult(env, program, updatingOpcodeStack.pop(), elementStack.popBlock())
            };
        }
        return result;
    };

    VM.prototype.nextStatement = function nextStatement() {
        var pc = this.pc,
            program = this.program;

        if (pc === -1) {
            return null;
        }
        // We have to save off the current operations size so that
        // when we do a jump we can calculate the correct offset
        // to where we are going. We can't simply ask for the size
        // in a jump because we have have already incremented the
        // program counter to the next instruction prior to executing.

        var _program$opcode = this.program.opcode(pc),
            size = _program$opcode.size;

        var operationSize = this.currentOpSize = size;
        this.pc += operationSize;
        return program.opcode(pc);
    };

    VM.prototype.bindDynamicScope = function bindDynamicScope(names) {
        var scope = this.dynamicScope();
        for (var i = names.length - 1; i >= 0; i--) {
            var name = this.constants.getString(names[i]);
            scope.set(name, this.stack.pop());
        }
    };

    createClass(VM, [{
        key: 'pc',
        get: function get$$1() {
            return this._pc;
        },
        set: function set$$1(value) {
            false && debugAssert(typeof value === 'number' && value >= -1, 'invalid pc: ' + value);

            this._pc = value;
        }
    }, {
        key: 'fp',
        get: function get$$1() {
            return this.stack.fp;
        },
        set: function set$$1(fp) {
            this.stack.fp = fp;
        }
    }, {
        key: 'sp',
        get: function get$$1() {
            return this.stack.sp;
        },
        set: function set$$1(sp) {
            this.stack.sp = sp;
        }
    }]);
    return VM;
}();

var TemplateIterator = function () {
    function TemplateIterator(vm) {
        classCallCheck(this, TemplateIterator);

        this.vm = vm;
    }

    TemplateIterator.prototype.next = function next() {
        return this.vm.next();
    };

    return TemplateIterator;
}();
var clientId = 0;
function templateFactory(_ref) {
    var templateId = _ref.id,
        meta = _ref.meta,
        block = _ref.block;

    var parsedBlock = void 0;
    var id = templateId || 'client-' + clientId++;
    var create = function create(options, envMeta) {
        var newMeta = envMeta ? assign({}, envMeta, meta) : meta;
        if (!parsedBlock) {
            parsedBlock = JSON.parse(block);
        }
        return new ScannableTemplate(options, { id: id, block: parsedBlock, referrer: newMeta });
    };
    return { id: id, meta: meta, create: create };
}
var ScannableTemplate = function () {
    function ScannableTemplate(options, parsedLayout) {
        classCallCheck(this, ScannableTemplate);

        this.options = options;
        this.parsedLayout = parsedLayout;
        this.layout = null;
        this.partial = null;
        var block = parsedLayout.block;

        this.symbols = block.symbols;
        this.hasEval = block.hasEval;
        this.statements = block.statements;
        this.referrer = parsedLayout.referrer;
        this.id = parsedLayout.id || 'client-' + clientId++;
    }

    ScannableTemplate.prototype.renderLayout = function renderLayout(options) {
        var env = options.env,
            self = options.self,
            dynamicScope = options.dynamicScope,
            _options$args = options.args,
            args = _options$args === undefined ? EMPTY_ARGS : _options$args,
            builder = options.builder;

        var layout = this.asLayout();
        var handle = layout.compile();
        var vm = VM.initial(this.options.program, env, self, args, dynamicScope, builder, handle);
        return new TemplateIterator(vm);
    };

    ScannableTemplate.prototype.asLayout = function asLayout() {
        if (this.layout) return this.layout;
        return this.layout = compilable(this.parsedLayout, this.options, false);
    };

    ScannableTemplate.prototype.asPartial = function asPartial() {
        if (this.partial) return this.partial;
        return this.partial = compilable(this.parsedLayout, this.options, true);
    };

    return ScannableTemplate;
}();
function compilable(layout, options, asPartial) {
    var block = layout.block,
        referrer = layout.referrer;
    var hasEval = block.hasEval,
        symbols = block.symbols;

    var compileOptions = assign({}, options, { asPartial: asPartial, referrer: referrer });
    return new CompilableTemplate(block.statements, layout, compileOptions, { referrer: referrer, hasEval: hasEval, symbols: symbols });
}

var RehydratingCursor = function (_Cursor) {
    inherits(RehydratingCursor, _Cursor);

    function RehydratingCursor(element, nextSibling, startingBlockDepth) {
        classCallCheck(this, RehydratingCursor);

        var _this = possibleConstructorReturn(this, _Cursor.call(this, element, nextSibling));

        _this.startingBlockDepth = startingBlockDepth;
        _this.candidate = null;
        _this.injectedOmittedNode = false;
        _this.openBlockDepth = startingBlockDepth - 1;
        return _this;
    }

    return RehydratingCursor;
}(Cursor);
var RehydrateBuilder = function (_NewElementBuilder) {
    inherits(RehydrateBuilder, _NewElementBuilder);

    // private candidate: Option<Simple.Node> = null;
    function RehydrateBuilder(env, parentNode, nextSibling) {
        classCallCheck(this, RehydrateBuilder);

        var _this2 = possibleConstructorReturn(this, _NewElementBuilder.call(this, env, parentNode, nextSibling));

        _this2.unmatchedAttributes = null;
        _this2.blockDepth = 0;
        if (nextSibling) throw new Error("Rehydration with nextSibling not supported");
        _this2.candidate = _this2.currentCursor.element.firstChild;
        false && debugAssert(_this2.candidate && isComment(_this2.candidate) && _this2.candidate.nodeValue === '%+block:0%', 'Must have opening comment <!--%+block:0%--> for rehydration.');
        return _this2;
    }

    RehydrateBuilder.prototype.pushElement = function pushElement(element, nextSibling) {
        var _blockDepth = this.blockDepth,
            blockDepth = _blockDepth === undefined ? 0 : _blockDepth;

        var cursor = new RehydratingCursor(element, nextSibling, blockDepth);
        var currentCursor = this.currentCursor;
        if (currentCursor) {
            if (currentCursor.candidate) {
                /**
                 * <div>   <---------------  currentCursor.element
                 *   <!--%+block:1%-->
                 *   <div> <---------------  currentCursor.candidate -> cursor.element
                 *     <!--%+block:2%--> <-  currentCursor.candidate.firstChild -> cursor.candidate
                 *     Foo
                 *     <!--%-block:2%-->
                 *   </div>
                 *   <!--%-block:1%-->  <--  becomes currentCursor.candidate
                 */
                // where to rehydrate from if we are in rehydration mode
                cursor.candidate = element.firstChild;
                // where to continue when we pop
                currentCursor.candidate = element.nextSibling;
            }
        }
        this.cursorStack.push(cursor);
    };

    RehydrateBuilder.prototype.clearMismatch = function clearMismatch(candidate) {
        var current = candidate;
        var currentCursor = this.currentCursor;
        if (currentCursor !== null) {
            var openBlockDepth = currentCursor.openBlockDepth;
            if (openBlockDepth >= currentCursor.startingBlockDepth) {
                while (current && !(isComment(current) && getCloseBlockDepth(current) === openBlockDepth)) {
                    current = this.remove(current);
                }
                false && debugAssert(current !== null, 'should have found closing block');
            } else {
                while (current !== null) {
                    current = this.remove(current);
                }
            }
            // current cursor parentNode should be openCandidate if element
            // or openCandidate.parentNode if comment
            currentCursor.nextSibling = current;
            // disable rehydration until we popElement or closeBlock for openBlockDepth
            currentCursor.candidate = null;
        }
    };

    RehydrateBuilder.prototype.__openBlock = function __openBlock() {
        var currentCursor = this.currentCursor;

        if (currentCursor === null) return;
        var blockDepth = this.blockDepth;
        this.blockDepth++;
        var candidate = currentCursor.candidate;

        if (candidate === null) return;
        if (isComment(candidate) && getOpenBlockDepth(candidate) === blockDepth) {
            currentCursor.candidate = this.remove(candidate);
            currentCursor.openBlockDepth = blockDepth;
        } else {
            this.clearMismatch(candidate);
        }
    };

    RehydrateBuilder.prototype.__closeBlock = function __closeBlock() {
        var currentCursor = this.currentCursor;

        if (currentCursor === null) return;
        // openBlock is the last rehydrated open block
        var openBlockDepth = currentCursor.openBlockDepth;
        // this currently is the expected next open block depth
        this.blockDepth--;
        var candidate = currentCursor.candidate;
        // rehydrating

        if (candidate !== null) {
            false && debugAssert(openBlockDepth === this.blockDepth, 'when rehydrating, openBlockDepth should match this.blockDepth here');

            if (isComment(candidate) && getCloseBlockDepth(candidate) === openBlockDepth) {
                currentCursor.candidate = this.remove(candidate);
                currentCursor.openBlockDepth--;
            } else {
                this.clearMismatch(candidate);
            }
            // if the openBlockDepth matches the blockDepth we just closed to
            // then restore rehydration
        }
        if (currentCursor.openBlockDepth === this.blockDepth) {
            false && debugAssert(currentCursor.nextSibling !== null && isComment(currentCursor.nextSibling) && getCloseBlockDepth(currentCursor.nextSibling) === openBlockDepth, "expected close block to match rehydrated open block");

            currentCursor.candidate = this.remove(currentCursor.nextSibling);
            currentCursor.openBlockDepth--;
        }
    };

    RehydrateBuilder.prototype.__appendNode = function __appendNode(node) {
        var candidate = this.candidate;
        // This code path is only used when inserting precisely one node. It needs more
        // comparison logic, but we can probably lean on the cases where this code path
        // is actually used.

        if (candidate) {
            return candidate;
        } else {
            return _NewElementBuilder.prototype.__appendNode.call(this, node);
        }
    };

    RehydrateBuilder.prototype.__appendHTML = function __appendHTML(html) {
        var candidateBounds = this.markerBounds();
        if (candidateBounds) {
            var first = candidateBounds.firstNode();
            var last = candidateBounds.lastNode();
            var newBounds = bounds(this.element, first.nextSibling, last.previousSibling);
            this.remove(first);
            this.remove(last);
            return newBounds;
        } else {
            return _NewElementBuilder.prototype.__appendHTML.call(this, html);
        }
    };

    RehydrateBuilder.prototype.remove = function remove(node) {
        var element = node.parentNode;
        var next = node.nextSibling;
        element.removeChild(node);
        return next;
    };

    RehydrateBuilder.prototype.markerBounds = function markerBounds() {
        var _candidate = this.candidate;
        if (_candidate && isMarker(_candidate)) {
            var first = _candidate;
            var last = first.nextSibling;
            while (last && !isMarker(last)) {
                last = last.nextSibling;
            }
            return bounds(this.element, first, last);
        } else {
            return null;
        }
    };

    RehydrateBuilder.prototype.__appendText = function __appendText(string) {
        var candidate = this.candidate;

        if (candidate) {
            if (isTextNode(candidate)) {
                if (candidate.nodeValue !== string) {
                    candidate.nodeValue = string;
                }
                this.candidate = candidate.nextSibling;
                return candidate;
            } else if (candidate && (isSeparator(candidate) || isEmpty$1(candidate))) {
                this.candidate = candidate.nextSibling;
                this.remove(candidate);
                return this.__appendText(string);
            } else if (isEmpty$1(candidate)) {
                var next = this.remove(candidate);
                this.candidate = next;
                var text = this.dom.createTextNode(string);
                this.dom.insertBefore(this.element, text, next);
                return text;
            } else {
                this.clearMismatch(candidate);
                return _NewElementBuilder.prototype.__appendText.call(this, string);
            }
        } else {
            return _NewElementBuilder.prototype.__appendText.call(this, string);
        }
    };

    RehydrateBuilder.prototype.__appendComment = function __appendComment(string) {
        var _candidate = this.candidate;
        if (_candidate && isComment(_candidate)) {
            if (_candidate.nodeValue !== string) {
                _candidate.nodeValue = string;
            }
            this.candidate = _candidate.nextSibling;
            return _candidate;
        } else if (_candidate) {
            this.clearMismatch(_candidate);
        }
        return _NewElementBuilder.prototype.__appendComment.call(this, string);
    };

    RehydrateBuilder.prototype.__openElement = function __openElement(tag) {
        var _candidate = this.candidate;
        if (_candidate && isElement(_candidate) && isSameNodeType(_candidate, tag)) {
            this.unmatchedAttributes = [].slice.call(_candidate.attributes);
            return _candidate;
        } else if (_candidate) {
            if (isElement(_candidate) && _candidate.tagName === 'TBODY') {
                this.pushElement(_candidate, null);
                this.currentCursor.injectedOmittedNode = true;
                return this.__openElement(tag);
            }
            this.clearMismatch(_candidate);
        }
        return _NewElementBuilder.prototype.__openElement.call(this, tag);
    };

    RehydrateBuilder.prototype.__setAttribute = function __setAttribute(name, value, namespace) {
        var unmatched = this.unmatchedAttributes;
        if (unmatched) {
            var attr = findByName(unmatched, name);
            if (attr) {
                if (attr.value !== value) {
                    attr.value = value;
                }
                unmatched.splice(unmatched.indexOf(attr), 1);
                return;
            }
        }
        return _NewElementBuilder.prototype.__setAttribute.call(this, name, value, namespace);
    };

    RehydrateBuilder.prototype.__setProperty = function __setProperty(name, value) {
        var unmatched = this.unmatchedAttributes;
        if (unmatched) {
            var attr = findByName(unmatched, name);
            if (attr) {
                if (attr.value !== value) {
                    attr.value = value;
                }
                unmatched.splice(unmatched.indexOf(attr), 1);
                return;
            }
        }
        return _NewElementBuilder.prototype.__setProperty.call(this, name, value);
    };

    RehydrateBuilder.prototype.__flushElement = function __flushElement(parent, constructing) {
        var unmatched = this.unmatchedAttributes;

        if (unmatched) {
            for (var i = 0; i < unmatched.length; i++) {
                this.constructing.removeAttribute(unmatched[i].name);
            }
            this.unmatchedAttributes = null;
        } else {
            _NewElementBuilder.prototype.__flushElement.call(this, parent, constructing);
        }
    };

    RehydrateBuilder.prototype.appendCautiousDynamicContent = function appendCautiousDynamicContent(value) {
        var content = _NewElementBuilder.prototype.appendCautiousDynamicContent.call(this, value);
        content.update(this.env, value);
        return content;
    };

    RehydrateBuilder.prototype.willCloseElement = function willCloseElement() {
        var candidate = this.candidate,
            currentCursor = this.currentCursor;

        if (candidate !== null) {
            this.clearMismatch(candidate);
        }
        if (currentCursor && currentCursor.injectedOmittedNode) {
            this.popElement();
        }
        _NewElementBuilder.prototype.willCloseElement.call(this);
    };

    RehydrateBuilder.prototype.getMarker = function getMarker(element, guid) {
        var marker = element.querySelector("script[glmr=\"" + guid + "\"]");
        if (marker) {
            return marker;
        }
        throw new Error('Cannot find serialized cursor for `in-element`');
    };

    RehydrateBuilder.prototype.__pushRemoteElement = function __pushRemoteElement(element, cursorId) {
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var marker = this.getMarker(element, cursorId);
        if (marker.parentNode === element) {
            var currentCursor = this.currentCursor;
            var candidate = currentCursor.candidate;
            this.pushElement(element, nextSibling);
            currentCursor.candidate = candidate;
            this.candidate = this.remove(marker);
            var tracker = new RemoteBlockTracker(element);
            this.pushBlockTracker(tracker, true);
        }
    };

    RehydrateBuilder.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {
        _NewElementBuilder.prototype.didAppendBounds.call(this, bounds$$1);
        if (this.candidate) {
            var last = bounds$$1.lastNode();
            this.candidate = last && last.nextSibling;
        }
        return bounds$$1;
    };

    createClass(RehydrateBuilder, [{
        key: "currentCursor",
        get: function get$$1() {
            return this.cursorStack.current;
        }
    }, {
        key: "candidate",
        get: function get$$1() {
            if (this.currentCursor) {
                return this.currentCursor.candidate;
            }
            return null;
        },
        set: function set$$1(node) {
            this.currentCursor.candidate = node;
        }
    }]);
    return RehydrateBuilder;
}(NewElementBuilder);
function isTextNode(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeType === 8;
}
function getOpenBlockDepth(node) {
    var boundsDepth = node.nodeValue.match(/^%\+block:(\d+)%$/);
    if (boundsDepth && boundsDepth[1]) {
        return Number(boundsDepth[1]);
    } else {
        return null;
    }
}
function getCloseBlockDepth(node) {
    var boundsDepth = node.nodeValue.match(/^%\-block:(\d+)%$/);
    if (boundsDepth && boundsDepth[1]) {
        return Number(boundsDepth[1]);
    } else {
        return null;
    }
}
function isElement(node) {
    return node.nodeType === 1;
}
function isMarker(node) {
    return node.nodeType === 8 && node.nodeValue === '%glimmer%';
}
function isSeparator(node) {
    return node.nodeType === 8 && node.nodeValue === '%sep%';
}
function isEmpty$1(node) {
    return node.nodeType === 8 && node.nodeValue === '%empty%';
}
function isSameNodeType(candidate, tag) {
    if (candidate.namespaceURI === SVG_NAMESPACE$$1) {
        return candidate.tagName === tag;
    }
    return candidate.tagName === tag.toUpperCase();
}
function findByName(array, name) {
    for (var i = 0; i < array.length; i++) {
        var attr = array[i];
        if (attr.name === name) return attr;
    }
    return undefined;
}

/**
 * The base PathReference.
 */
var ComponentPathReference = function () {
    function ComponentPathReference() {
        classCallCheck(this, ComponentPathReference);
    }

    ComponentPathReference.prototype.get = function get$$1(key) {
        return PropertyReference.create(this, key);
    };

    return ComponentPathReference;
}();
var CachedReference$1 = function (_ComponentPathReferen) {
    inherits(CachedReference$$1, _ComponentPathReferen);

    function CachedReference$$1() {
        classCallCheck(this, CachedReference$$1);

        var _this = possibleConstructorReturn(this, _ComponentPathReferen.apply(this, arguments));

        _this._lastRevision = null;
        _this._lastValue = null;
        return _this;
    }

    CachedReference$$1.prototype.value = function value() {
        var tag = this.tag,
            _lastRevision = this._lastRevision,
            _lastValue = this._lastValue;

        if (!_lastRevision || !tag.validate(_lastRevision)) {
            _lastValue = this._lastValue = this.compute();
            this._lastRevision = tag.value();
        }
        return _lastValue;
    };

    return CachedReference$$1;
}(ComponentPathReference);
var RootReference = function (_ConstReference) {
    inherits(RootReference, _ConstReference);

    function RootReference() {
        classCallCheck(this, RootReference);

        var _this2 = possibleConstructorReturn(this, _ConstReference.apply(this, arguments));

        _this2.children = dict();
        return _this2;
    }

    RootReference.prototype.get = function get$$1(propertyKey) {
        var ref = this.children[propertyKey];
        if (!ref) {
            ref = this.children[propertyKey] = new RootPropertyReference(this.inner, propertyKey);
        }
        return ref;
    };

    return RootReference;
}(ConstReference);
var PropertyReference = function (_CachedReference) {
    inherits(PropertyReference, _CachedReference);

    function PropertyReference() {
        classCallCheck(this, PropertyReference);
        return possibleConstructorReturn(this, _CachedReference.apply(this, arguments));
    }

    PropertyReference.create = function create(parentReference, propertyKey) {
        if (isConst(parentReference)) {
            return new RootPropertyReference(parentReference.value(), propertyKey);
        } else {
            return new NestedPropertyReference(parentReference, propertyKey);
        }
    };

    PropertyReference.prototype.get = function get$$1(key) {
        return new NestedPropertyReference(this, key);
    };

    return PropertyReference;
}(CachedReference$1);
var RootPropertyReference = function (_PropertyReference) {
    inherits(RootPropertyReference, _PropertyReference);

    function RootPropertyReference(parentValue, propertyKey) {
        classCallCheck(this, RootPropertyReference);

        var _this4 = possibleConstructorReturn(this, _PropertyReference.call(this));

        _this4._parentValue = parentValue;
        _this4._propertyKey = propertyKey;
        _this4.tag = tagForProperty(parentValue, propertyKey);
        return _this4;
    }

    RootPropertyReference.prototype.compute = function compute() {
        return this._parentValue[this._propertyKey];
    };

    return RootPropertyReference;
}(PropertyReference);
var NestedPropertyReference = function (_PropertyReference2) {
    inherits(NestedPropertyReference, _PropertyReference2);

    function NestedPropertyReference(parentReference, propertyKey) {
        classCallCheck(this, NestedPropertyReference);

        var _this5 = possibleConstructorReturn(this, _PropertyReference2.call(this));

        var parentReferenceTag = parentReference.tag;
        var parentObjectTag = UpdatableTag.create(CONSTANT_TAG);
        _this5._parentReference = parentReference;
        _this5._parentObjectTag = parentObjectTag;
        _this5._propertyKey = propertyKey;
        _this5.tag = combine([parentReferenceTag, parentObjectTag]);
        return _this5;
    }

    NestedPropertyReference.prototype.compute = function compute() {
        var _parentReference = this._parentReference,
            _parentObjectTag = this._parentObjectTag,
            _propertyKey = this._propertyKey;

        var parentValue = _parentReference.value();
        _parentObjectTag.inner.update(tagForProperty(parentValue, _propertyKey));
        if (typeof parentValue === "string" && _propertyKey === "length") {
            return parentValue.length;
        }
        if ((typeof parentValue === "undefined" ? "undefined" : _typeof(parentValue)) === "object" && parentValue) {
            return parentValue[_propertyKey];
        } else {
            return undefined;
        }
    };

    return NestedPropertyReference;
}(PropertyReference);
var UpdatableReference = function (_ComponentPathReferen2) {
    inherits(UpdatableReference, _ComponentPathReferen2);

    function UpdatableReference(value) {
        classCallCheck(this, UpdatableReference);

        var _this6 = possibleConstructorReturn(this, _ComponentPathReferen2.call(this));

        _this6.tag = DirtyableTag.create();
        _this6._value = value;
        return _this6;
    }

    UpdatableReference.prototype.value = function value() {
        return this._value;
    };

    UpdatableReference.prototype.update = function update(value) {
        var _value = this._value;

        if (value !== _value) {
            this.tag.inner.dirty();
            this._value = value;
        }
    };

    return UpdatableReference;
}(ComponentPathReference);
var ConditionalReference$$1 = function (_GlimmerConditionalRe) {
    inherits(ConditionalReference$$1, _GlimmerConditionalRe);

    function ConditionalReference$$1() {
        classCallCheck(this, ConditionalReference$$1);
        return possibleConstructorReturn(this, _GlimmerConditionalRe.apply(this, arguments));
    }

    ConditionalReference$$1.create = function create(reference) {
        if (isConst(reference)) {
            var value = reference.value();
            return PrimitiveReference.create(value);
        }
        return new ConditionalReference$$1(reference);
    };

    return ConditionalReference$$1;
}(ConditionalReference$1);

var ComponentStateBucket = function () {
    function ComponentStateBucket(definition, args, owner) {
        classCallCheck(this, ComponentStateBucket);

        var componentFactory = definition.ComponentClass;
        var name = definition.name;
        this.args = args;
        var injections = {
            debugName: name,
            args: this.namedArgsSnapshot()
        };
        setOwner(injections, owner);
        this.component = componentFactory.create(injections);
    }

    ComponentStateBucket.prototype.namedArgsSnapshot = function namedArgsSnapshot() {
        return Object.freeze(this.args.named.value());
    };

    createClass(ComponentStateBucket, [{
        key: "tag",
        get: function get$$1() {
            return this.args.tag;
        }
    }]);
    return ComponentStateBucket;
}();

var ComponentManager = function () {
    ComponentManager.create = function create(options) {
        return new ComponentManager(options);
    };

    function ComponentManager(options) {
        classCallCheck(this, ComponentManager);

        this.env = options.env;
    }

    ComponentManager.prototype.prepareArgs = function prepareArgs(state, args) {
        return null;
    };

    ComponentManager.prototype.getCapabilities = function getCapabilities(state) {
        return state.capabilities;
    };

    ComponentManager.prototype.getLayout = function getLayout(_ref, resolver) {
        var name = _ref.name,
            layout = _ref.layout;

        return resolver.compileTemplate(name, layout);
    };

    ComponentManager.prototype.create = function create(_env, definition, args, _dynamicScope, _caller, _hasDefaultBlock) {
        var owner = getOwner(this.env);
        return new ComponentStateBucket(definition, args.capture(), owner);
    };

    ComponentManager.prototype.getSelf = function getSelf(bucket) {
        return new RootReference(bucket.component);
    };

    ComponentManager.prototype.didCreateElement = function didCreateElement(bucket, element) {};

    ComponentManager.prototype.didRenderLayout = function didRenderLayout(bucket, bounds) {
        bucket.component.bounds = new Bounds(bounds);
    };

    ComponentManager.prototype.didCreate = function didCreate(bucket) {
        if (bucket) {
            bucket.component.didInsertElement();
        }
    };

    ComponentManager.prototype.getTag = function getTag(_ref2) {
        var tag = _ref2.tag;

        return tag;
    };

    ComponentManager.prototype.update = function update(bucket, scope) {
        bucket.component.args = bucket.namedArgsSnapshot();
    };

    ComponentManager.prototype.didUpdateLayout = function didUpdateLayout() {};

    ComponentManager.prototype.didUpdate = function didUpdate(_ref3) {
        var component = _ref3.component;

        component.didUpdate();
    };

    ComponentManager.prototype.getDestructor = function getDestructor(bucket) {
        return bucket.component;
    };

    return ComponentManager;
}();

function EMPTY_CACHE() {}

var PathReference = function () {
    function PathReference(parent, property) {
        classCallCheck(this, PathReference);

        this.cache = EMPTY_CACHE;
        this.inner = null;
        this.chains = null;
        this.lastParentValue = EMPTY_CACHE;
        this._guid = 0;
        this.tag = VOLATILE_TAG;
        this.parent = parent;
        this.property = property;
    }

    PathReference.prototype.value = function value() {
        var lastParentValue = this.lastParentValue,
            property = this.property,
            inner = this.inner;

        var parentValue = this._parentValue();
        if (parentValue === null || parentValue === undefined) {
            return this.cache = undefined;
        }
        if (lastParentValue === parentValue) {
            inner = this.inner;
        } else {
            var ReferenceType = (typeof parentValue === 'undefined' ? 'undefined' : _typeof(parentValue)) === 'object' ? Meta$2.for(parentValue).referenceTypeFor(property) : PropertyReference$1;
            inner = this.inner = new ReferenceType(parentValue, property, this);
        }
        // if (typeof parentValue === 'object') {
        //   Meta.for(parentValue).addReference(property, this);
        // }
        return this.cache = inner.value();
    };

    PathReference.prototype.get = function get$$1(prop) {
        var chains = this._getChains();
        if (prop in chains) return chains[prop];
        return chains[prop] = new PathReference(this, prop);
    };

    PathReference.prototype.label = function label() {
        return '[reference Direct]';
    };

    PathReference.prototype._getChains = function _getChains() {
        if (this.chains) return this.chains;
        return this.chains = dict();
    };

    PathReference.prototype._parentValue = function _parentValue() {
        var parent = this.parent.value();
        this.lastParentValue = parent;
        return parent;
    };

    return PathReference;
}();

var RootReference$1 = function () {
    function RootReference(object) {
        classCallCheck(this, RootReference);

        this.chains = dict();
        this.tag = VOLATILE_TAG;
        this.object = object;
    }

    RootReference.prototype.value = function value() {
        return this.object;
    };

    RootReference.prototype.update = function update(object) {
        this.object = object;
        // this.notify();
    };

    RootReference.prototype.get = function get$$1(prop) {
        var chains = this.chains;
        if (prop in chains) return chains[prop];
        return chains[prop] = new PathReference(this, prop);
    };

    RootReference.prototype.chainFor = function chainFor(prop) {
        var chains = this.chains;
        if (prop in chains) return chains[prop];
        return null;
    };

    RootReference.prototype.path = function path(string) {
        return this.referenceFromParts(string.split('.'));
    };

    RootReference.prototype.referenceFromParts = function referenceFromParts(parts) {
        return parts.reduce(function (ref, part) {
            return ref.get(part);
        }, this);
    };

    RootReference.prototype.label = function label() {
        return '[reference Root]';
    };

    return RootReference;
}();

var NOOP_DESTROY = {
    destroy: function destroy() {}
};

var ConstPath = function () {
    function ConstPath(parent, _property) {
        classCallCheck(this, ConstPath);

        this.tag = VOLATILE_TAG;
        this.parent = parent;
    }

    ConstPath.prototype.chain = function chain() {
        return NOOP_DESTROY;
    };

    ConstPath.prototype.notify = function notify() {};

    ConstPath.prototype.value = function value() {
        return this.parent[this.property];
    };

    ConstPath.prototype.get = function get$$1(prop) {
        return new ConstPath(this.parent[this.property], prop);
    };

    return ConstPath;
}();

var ConstRoot = function () {
    function ConstRoot(value) {
        classCallCheck(this, ConstRoot);

        this.tag = VOLATILE_TAG;
        this.inner = value;
    }

    ConstRoot.prototype.update = function update(inner) {
        this.inner = inner;
    };

    ConstRoot.prototype.chain = function chain() {
        return NOOP_DESTROY;
    };

    ConstRoot.prototype.notify = function notify() {};

    ConstRoot.prototype.value = function value() {
        return this.inner;
    };

    ConstRoot.prototype.referenceFromParts = function referenceFromParts(_parts) {
        throw new Error("Not implemented");
    };

    ConstRoot.prototype.chainFor = function chainFor(_prop) {
        throw new Error("Not implemented");
    };

    ConstRoot.prototype.get = function get$$1(prop) {
        return new ConstPath(this.inner, prop);
    };

    return ConstRoot;
}();

var ConstMeta /*implements IMeta*/ = function () {
    function ConstMeta(object) {
        classCallCheck(this, ConstMeta);

        this.object = object;
    }

    ConstMeta.prototype.root = function root() {
        return new ConstRoot(this.object);
    };

    return ConstMeta;
}();

var CLASS_META = "df8be4c8-4e89-44e2-a8f9-550c8dacdca7";
var hasOwnProperty$1 = Object.hasOwnProperty;

var Meta$2 = function () {
    function Meta(object, _ref) {
        var RootReferenceFactory = _ref.RootReferenceFactory,
            DefaultPathReferenceFactory = _ref.DefaultPathReferenceFactory;
        classCallCheck(this, Meta);

        this.references = null;
        this.slots = null;
        this.referenceTypes = null;
        this.propertyMetadata = null;
        this.object = object;
        this.RootReferenceFactory = RootReferenceFactory || RootReference$1;
        this.DefaultPathReferenceFactory = DefaultPathReferenceFactory || PropertyReference$1;
    }

    Meta.for = function _for(obj) {
        if (obj === null || obj === undefined) return new Meta(obj, {});
        if (hasOwnProperty$1.call(obj, '_meta') && obj._meta) return obj._meta;
        if (!Object.isExtensible(obj)) return new ConstMeta(obj);
        var MetaToUse = Meta;
        if (obj.constructor && obj.constructor[CLASS_META]) {
            var classMeta = obj.constructor[CLASS_META];
            MetaToUse = classMeta.InstanceMetaConstructor;
        } else if (obj[CLASS_META]) {
            MetaToUse = obj[CLASS_META].InstanceMetaConstructor;
        }
        return obj._meta = new MetaToUse(obj, {});
    };

    Meta.exists = function exists(obj) {
        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj._meta;
    };

    Meta.metadataForProperty = function metadataForProperty(_key) {
        return null;
    };

    Meta.prototype.addReference = function addReference(property, reference) {
        var refs = this.references = this.references || dict();
        var set$$1 = refs[property] = refs[property] || new DictSet();
        set$$1.add(reference);
    };

    Meta.prototype.addReferenceTypeFor = function addReferenceTypeFor(property, type) {
        this.referenceTypes = this.referenceTypes || dict();
        this.referenceTypes[property] = type;
    };

    Meta.prototype.referenceTypeFor = function referenceTypeFor(property) {
        if (!this.referenceTypes) return PropertyReference$1;
        return this.referenceTypes[property] || PropertyReference$1;
    };

    Meta.prototype.removeReference = function removeReference(property, reference) {
        if (!this.references) return;
        var set$$1 = this.references[property];
        set$$1.delete(reference);
    };

    Meta.prototype.getReferenceTypes = function getReferenceTypes() {
        this.referenceTypes = this.referenceTypes || dict();
        return this.referenceTypes;
    };

    Meta.prototype.referencesFor = function referencesFor(property) {
        if (!this.references) return null;
        return this.references[property];
    };

    Meta.prototype.getSlots = function getSlots() {
        return this.slots = this.slots || dict();
    };

    Meta.prototype.root = function root() {
        return this.rootCache = this.rootCache || new this.RootReferenceFactory(this.object);
    };

    return Meta;
}();

var PropertyReference$1 = function () {
    function PropertyReference(object, property, _outer) {
        classCallCheck(this, PropertyReference);

        this.tag = VOLATILE_TAG;
        this.object = object;
        this.property = property;
    }

    PropertyReference.prototype.value = function value() {
        return this.object[this.property];
    };

    PropertyReference.prototype.label = function label() {
        return '[reference Property]';
    };

    return PropertyReference;
}();

// import { metaFor } from './meta';
// import { intern } from '@glimmer/util';

function isTypeSpecifier(specifier) {
    return specifier.indexOf(':') === -1;
}

var ApplicationRegistry = function () {
    function ApplicationRegistry(registry, resolver) {
        classCallCheck(this, ApplicationRegistry);

        this._registry = registry;
        this._resolver = resolver;
    }

    ApplicationRegistry.prototype.register = function register(specifier, factory, options) {
        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
        this._registry.register(normalizedSpecifier, factory, options);
    };

    ApplicationRegistry.prototype.registration = function registration(specifier) {
        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
        return this._registry.registration(normalizedSpecifier);
    };

    ApplicationRegistry.prototype.unregister = function unregister(specifier) {
        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);
        this._registry.unregister(normalizedSpecifier);
    };

    ApplicationRegistry.prototype.registerOption = function registerOption(specifier, option, value) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        this._registry.registerOption(normalizedSpecifier, option, value);
    };

    ApplicationRegistry.prototype.registeredOption = function registeredOption(specifier, option) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        return this._registry.registeredOption(normalizedSpecifier, option);
    };

    ApplicationRegistry.prototype.registeredOptions = function registeredOptions(specifier) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        return this._registry.registeredOptions(normalizedSpecifier);
    };

    ApplicationRegistry.prototype.unregisterOption = function unregisterOption(specifier, option) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        this._registry.unregisterOption(normalizedSpecifier, option);
    };

    ApplicationRegistry.prototype.registerInjection = function registerInjection(specifier, property, injection) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        var normalizedInjection = this._toAbsoluteSpecifier(injection);
        this._registry.registerInjection(normalizedSpecifier, property, normalizedInjection);
    };

    ApplicationRegistry.prototype.registeredInjections = function registeredInjections(specifier) {
        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);
        return this._registry.registeredInjections(normalizedSpecifier);
    };

    ApplicationRegistry.prototype._toAbsoluteSpecifier = function _toAbsoluteSpecifier(specifier, referrer) {
        return this._resolver.identify(specifier, referrer);
    };

    ApplicationRegistry.prototype._toAbsoluteOrTypeSpecifier = function _toAbsoluteOrTypeSpecifier(specifier) {
        if (isTypeSpecifier(specifier)) {
            return specifier;
        } else {
            return this._toAbsoluteSpecifier(specifier);
        }
    };

    return ApplicationRegistry;
}();

var DynamicScope = function () {
    function DynamicScope() {
        var bucket = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        classCallCheck(this, DynamicScope);

        if (bucket) {
            this.bucket = assign({}, bucket);
        } else {
            this.bucket = {};
        }
    }

    DynamicScope.prototype.get = function get$$1(key) {
        return this.bucket[key];
    };

    DynamicScope.prototype.set = function set$$1(key, reference) {
        return this.bucket[key] = reference;
    };

    DynamicScope.prototype.child = function child() {
        return new DynamicScope(this.bucket);
    };

    return DynamicScope;
}();

var ArrayIterator = function () {
    function ArrayIterator(array, keyFor) {
        classCallCheck(this, ArrayIterator);

        this.position = 0;
        this.array = array;
        this.keyFor = keyFor;
    }

    ArrayIterator.prototype.isEmpty = function isEmpty() {
        return this.array.length === 0;
    };

    ArrayIterator.prototype.next = function next() {
        var position = this.position,
            array = this.array,
            keyFor = this.keyFor;

        if (position >= array.length) return null;
        var value = array[position];
        var key = keyFor(value, position);
        var memo = position;
        this.position++;
        return { key: key, value: value, memo: memo };
    };

    return ArrayIterator;
}();

var ObjectKeysIterator = function () {
    function ObjectKeysIterator(keys, values, keyFor) {
        classCallCheck(this, ObjectKeysIterator);

        this.position = 0;
        this.keys = keys;
        this.values = values;
        this.keyFor = keyFor;
    }

    ObjectKeysIterator.prototype.isEmpty = function isEmpty() {
        return this.keys.length === 0;
    };

    ObjectKeysIterator.prototype.next = function next() {
        var position = this.position,
            keys = this.keys,
            values = this.values,
            keyFor = this.keyFor;

        if (position >= keys.length) return null;
        var value = values[position];
        var memo = keys[position];
        var key = keyFor(value, memo);
        this.position++;
        return { key: key, value: value, memo: memo };
    };

    return ObjectKeysIterator;
}();

var EmptyIterator = function () {
    function EmptyIterator() {
        classCallCheck(this, EmptyIterator);
    }

    EmptyIterator.prototype.isEmpty = function isEmpty() {
        return true;
    };

    EmptyIterator.prototype.next = function next() {
        throw new Error("Cannot call next() on an empty iterator");
    };

    return EmptyIterator;
}();

var EMPTY_ITERATOR = new EmptyIterator();

var Iterable = function () {
    function Iterable(ref, keyFor) {
        classCallCheck(this, Iterable);

        this.tag = ref.tag;
        this.ref = ref;
        this.keyFor = keyFor;
    }

    Iterable.prototype.iterate = function iterate() {
        var ref = this.ref,
            keyFor = this.keyFor;

        var iterable = ref.value();
        if (Array.isArray(iterable)) {
            return iterable.length > 0 ? new ArrayIterator(iterable, keyFor) : EMPTY_ITERATOR;
        } else if (iterable === undefined || iterable === null) {
            return EMPTY_ITERATOR;
        } else if (iterable.forEach !== undefined) {
            var array = [];
            iterable.forEach(function (item) {
                array.push(item);
            });
            return array.length > 0 ? new ArrayIterator(array, keyFor) : EMPTY_ITERATOR;
        } else if ((typeof iterable === "undefined" ? "undefined" : _typeof(iterable)) === 'object') {
            var keys = Object.keys(iterable);
            return keys.length > 0 ? new ObjectKeysIterator(keys, keys.map(function (key) {
                return iterable[key];
            }), keyFor) : EMPTY_ITERATOR;
        } else {
            throw new Error("Don't know how to {{#each " + iterable + "}}");
        }
    };

    Iterable.prototype.valueReferenceFor = function valueReferenceFor(item) {
        return new UpdatableReference(item.value);
    };

    Iterable.prototype.updateValueReference = function updateValueReference(reference, item) {
        reference.update(item.value);
    };

    Iterable.prototype.memoReferenceFor = function memoReferenceFor(item) {
        return new UpdatableReference(item.memo);
    };

    Iterable.prototype.updateMemoReference = function updateMemoReference(reference, item) {
        reference.update(item.memo);
    };

    return Iterable;
}();

var UNRESOLVED = {};
var WELL_KNOWN_EMPTY_ARRAY_POSITION = 0;
var WELL_KNOW_EMPTY_ARRAY = Object.freeze([]);

var WriteOnlyConstants = function () {
    function WriteOnlyConstants() {
        classCallCheck(this, WriteOnlyConstants);

        // `0` means NULL
        this.strings = [];
        this.arrays = [WELL_KNOW_EMPTY_ARRAY];
        this.tables = [];
        this.handles = [];
        this.serializables = [];
        this.resolved = [];
        this.floats = [];
        this.negatives = [];
    }

    WriteOnlyConstants.prototype.float = function float(_float) {
        var index = this.floats.indexOf(_float);
        if (index > -1) {
            return index;
        }
        return this.floats.push(_float) - 1;
    };

    WriteOnlyConstants.prototype.negative = function negative(_negative) {
        return this.negatives.push(_negative) - 1;
    };

    WriteOnlyConstants.prototype.string = function string(value) {
        var index = this.strings.indexOf(value);
        if (index > -1) {
            return index;
        }
        return this.strings.push(value) - 1;
    };

    WriteOnlyConstants.prototype.stringArray = function stringArray(strings) {
        var _strings = new Array(strings.length);
        for (var i = 0; i < strings.length; i++) {
            _strings[i] = this.string(strings[i]);
        }
        return this.array(_strings);
    };

    WriteOnlyConstants.prototype.array = function array(values) {
        if (values.length === 0) {
            return WELL_KNOWN_EMPTY_ARRAY_POSITION;
        }
        var index = this.arrays.indexOf(values);
        if (index > -1) {
            return index;
        }
        return this.arrays.push(values) - 1;
    };

    WriteOnlyConstants.prototype.table = function table(t) {
        var index = this.tables.indexOf(t);
        if (index > -1) {
            return index;
        }
        return this.tables.push(t) - 1;
    };

    WriteOnlyConstants.prototype.handle = function handle(_handle) {
        this.resolved.push(UNRESOLVED);
        return this.handles.push(_handle);
    };

    WriteOnlyConstants.prototype.serializable = function serializable(value) {
        var index = this.serializables.indexOf(value);
        if (index > -1) {
            return index;
        }
        return this.serializables.push(value) - 1;
    };

    WriteOnlyConstants.prototype.toPool = function toPool() {
        return {
            strings: this.strings,
            arrays: this.arrays,
            tables: this.tables,
            handles: this.handles,
            serializables: this.serializables,
            floats: this.floats,
            negatives: this.negatives
        };
    };

    return WriteOnlyConstants;
}();


var Constants = function (_WriteOnlyConstants) {
    inherits(Constants, _WriteOnlyConstants);

    function Constants(resolver, pool) {
        classCallCheck(this, Constants);

        var _this = possibleConstructorReturn(this, _WriteOnlyConstants.call(this));

        _this.resolver = resolver;
        if (pool) {
            _this.strings = pool.strings;
            _this.arrays = pool.arrays;
            _this.tables = pool.tables;
            _this.handles = pool.handles;
            _this.serializables = pool.serializables;
            _this.floats = pool.floats;
            _this.negatives = pool.negatives;
            _this.resolved = _this.handles.map(function () {
                return UNRESOLVED;
            });
        }
        return _this;
    }
    // `0` means NULL


    Constants.prototype.getFloat = function getFloat(value) {
        return this.floats[value];
    };

    Constants.prototype.getNegative = function getNegative(value) {
        return this.negatives[value];
    };

    Constants.prototype.getString = function getString(value) {
        return this.strings[value];
    };

    Constants.prototype.getStringArray = function getStringArray(value) {
        var names = this.getArray(value);
        var _names = new Array(names.length);
        for (var i = 0; i < names.length; i++) {
            var n = names[i];
            _names[i] = this.getString(n);
        }
        return _names;
    };

    Constants.prototype.getArray = function getArray(value) {
        return this.arrays[value];
    };

    Constants.prototype.getSymbolTable = function getSymbolTable(value) {
        return this.tables[value];
    };

    Constants.prototype.resolveHandle = function resolveHandle(s) {
        var index = s - 1;
        var resolved = this.resolved[index];
        if (resolved === UNRESOLVED) {
            var handle = this.handles[index];
            resolved = this.resolved[index] = this.resolver.resolve(handle);
        }
        return resolved;
    };

    Constants.prototype.getSerializable = function getSerializable(s) {
        return this.serializables[s];
    };

    return Constants;
}(WriteOnlyConstants);

var LazyConstants = function (_Constants) {
    inherits(LazyConstants, _Constants);

    function LazyConstants() {
        classCallCheck(this, LazyConstants);

        var _this2 = possibleConstructorReturn(this, _Constants.apply(this, arguments));

        _this2.others = [];
        return _this2;
    }

    LazyConstants.prototype.getOther = function getOther(value) {
        return this.others[value - 1];
    };

    LazyConstants.prototype.other = function other(_other) {
        return this.others.push(_other);
    };

    return LazyConstants;
}(Constants);

var Opcode = function () {
    function Opcode(heap) {
        classCallCheck(this, Opcode);

        this.heap = heap;
        this.offset = 0;
    }

    createClass(Opcode, [{
        key: "size",
        get: function get$$1() {
            var rawType = this.heap.getbyaddr(this.offset);
            return ((rawType & OPERAND_LEN_MASK) >> ARG_SHIFT) + 1;
        }
    }, {
        key: "type",
        get: function get$$1() {
            return this.heap.getbyaddr(this.offset) & TYPE_MASK;
        }
    }, {
        key: "op1",
        get: function get$$1() {
            return this.heap.getbyaddr(this.offset + 1);
        }
    }, {
        key: "op2",
        get: function get$$1() {
            return this.heap.getbyaddr(this.offset + 2);
        }
    }, {
        key: "op3",
        get: function get$$1() {
            return this.heap.getbyaddr(this.offset + 3);
        }
    }]);
    return Opcode;
}();

var TableSlotState;
(function (TableSlotState) {
    TableSlotState[TableSlotState["Allocated"] = 0] = "Allocated";
    TableSlotState[TableSlotState["Freed"] = 1] = "Freed";
    TableSlotState[TableSlotState["Purged"] = 2] = "Purged";
    TableSlotState[TableSlotState["Pointer"] = 3] = "Pointer";
})(TableSlotState || (TableSlotState = {}));
var ENTRY_SIZE = 2;
var INFO_OFFSET = 1;
var SIZE_MASK = 65535;
var SCOPE_MASK = 1073676288;
var STATE_MASK = 3221225472;
function encodeTableInfo(size, scopeSize, state) {
    return size | scopeSize << 16 | state << 30;
}
function changeState(info, newState) {
    return info | newState << 30;
}
/**
 * The Heap is responsible for dynamically allocating
 * memory in which we read/write the VM's instructions
 * from/to. When we malloc we pass out a VMHandle, which
 * is used as an indirect way of accessing the memory during
 * execution of the VM. Internally we track the different
 * regions of the memory in an int array known as the table.
 *
 * The table 32-bit aligned and has the following layout:
 *
 * | ... | hp (u32) |       info (u32)          |
 * | ... |  Handle  | Size | Scope Size | State |
 * | ... | 32-bits  | 16b  |    14b     |  2b   |
 *
 * With this information we effectively have the ability to
 * control when we want to free memory. That being said you
 * can not free during execution as raw address are only
 * valid during the execution. This means you cannot close
 * over them as you will have a bad memory access exception.
 */
var Heap = function () {
    function Heap(serializedHeap) {
        classCallCheck(this, Heap);

        this.offset = 0;
        this.handle = 0;
        if (serializedHeap) {
            var buffer = serializedHeap.buffer,
                table = serializedHeap.table,
                handle = serializedHeap.handle;

            this.heap = new Uint16Array(buffer);
            this.table = table;
            this.offset = this.heap.length;
            this.handle = handle;
        } else {
            this.heap = new Uint16Array(0x100000);
            this.table = [];
        }
    }

    Heap.prototype.push = function push(item) {
        this.heap[this.offset++] = item;
    };

    Heap.prototype.getbyaddr = function getbyaddr(address) {
        return this.heap[address];
    };

    Heap.prototype.setbyaddr = function setbyaddr(address, value) {
        this.heap[address] = value;
    };

    Heap.prototype.malloc = function malloc() {
        this.table.push(this.offset, 0);
        var handle = this.handle;
        this.handle += ENTRY_SIZE;
        return handle;
    };

    Heap.prototype.finishMalloc = function finishMalloc(handle, scopeSize) {
        var start = this.table[handle];
        var finish = this.offset;
        var instructionSize = finish - start;
        var info = encodeTableInfo(instructionSize, scopeSize, TableSlotState.Allocated);
        this.table[handle + INFO_OFFSET] = info;
    };

    Heap.prototype.size = function size() {
        return this.offset;
    };
    // It is illegal to close over this address, as compaction
    // may move it. However, it is legal to use this address
    // multiple times between compactions.


    Heap.prototype.getaddr = function getaddr(handle) {
        return this.table[handle];
    };

    Heap.prototype.gethandle = function gethandle(address) {
        this.table.push(address, encodeTableInfo(0, 0, TableSlotState.Pointer));
        var handle = this.handle;
        this.handle += ENTRY_SIZE;
        return handle;
    };

    Heap.prototype.sizeof = function sizeof(handle) {
        return -1;
    };

    Heap.prototype.scopesizeof = function scopesizeof(handle) {
        var info = this.table[handle + INFO_OFFSET];
        return (info & SCOPE_MASK) >> 16;
    };

    Heap.prototype.free = function free(handle) {
        var info = this.table[handle + INFO_OFFSET];
        this.table[handle + INFO_OFFSET] = changeState(info, TableSlotState.Freed);
    };
    /**
     * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift
     * reachable memory to the bottom of the heap and freeable
     * memory to the top of the heap. When we have shifted all
     * the reachable memory to the top of the heap, we move the
     * offset to the next free position.
     */


    Heap.prototype.compact = function compact() {
        var compactedSize = 0;
        var table = this.table,
            length = this.table.length,
            heap = this.heap;

        for (var i = 0; i < length; i += ENTRY_SIZE) {
            var offset = table[i];
            var info = table[i + INFO_OFFSET];
            var size = info & SIZE_MASK;
            var state = info & STATE_MASK >> 30;
            if (state === TableSlotState.Purged) {
                continue;
            } else if (state === TableSlotState.Freed) {
                // transition to "already freed" aka "purged"
                // a good improvement would be to reuse
                // these slots
                table[i + INFO_OFFSET] = changeState(info, TableSlotState.Purged);
                compactedSize += size;
            } else if (state === TableSlotState.Allocated) {
                for (var j = offset; j <= i + size; j++) {
                    heap[j - compactedSize] = heap[j];
                }
                table[i] = offset - compactedSize;
            } else if (state === TableSlotState.Pointer) {
                table[i] = offset - compactedSize;
            }
        }
        this.offset = this.offset - compactedSize;
    };

    Heap.prototype.capture = function capture() {
        // Only called in eager mode
        var buffer = slice(this.heap, 0, this.offset);
        return {
            handle: this.handle,
            table: this.table,
            buffer: buffer
        };
    };

    return Heap;
}();
var WriteOnlyProgram = function () {
    function WriteOnlyProgram() {
        var constants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new WriteOnlyConstants();
        var heap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Heap();
        classCallCheck(this, WriteOnlyProgram);

        this.constants = constants;
        this.heap = heap;
        this._opcode = new Opcode(this.heap);
    }

    WriteOnlyProgram.prototype.opcode = function opcode(offset) {
        this._opcode.offset = offset;
        return this._opcode;
    };

    return WriteOnlyProgram;
}();

var Program = function (_WriteOnlyProgram) {
    inherits(Program, _WriteOnlyProgram);

    function Program() {
        classCallCheck(this, Program);
        return possibleConstructorReturn(this, _WriteOnlyProgram.apply(this, arguments));
    }

    return Program;
}(WriteOnlyProgram);
function slice(arr, start, end) {
    if (arr instanceof Uint16Array) {
        if (arr.slice !== undefined) {
            return arr.slice(start, end).buffer;
        }
        var ret = new Uint16Array(end);
        for (; start < end; start++) {
            ret[start] = arr[start];
        }
        return ret.buffer;
    }
    return null;
}

function buildAction(vm, _args) {
    var componentRef = vm.getSelf();
    var args = _args.capture();
    var actionFunc = args.positional.at(0).value();
    if (typeof actionFunc !== 'function') {
        throwNoActionError(actionFunc, args.positional.at(0));
    }
    return new RootReference$1(function action() {
        var curriedArgs = args.positional.value();
        // Consume the action function that was already captured above.
        curriedArgs.shift();
        curriedArgs.push.apply(curriedArgs, arguments);
        // Invoke the function with the component as the context, the curried
        // arguments passed to `{{action}}`, and the arguments the bound function
        // was invoked with.
        actionFunc.apply(componentRef && componentRef.value(), curriedArgs);
    });
}
function throwNoActionError(actionFunc, actionFuncReference) {
    var referenceInfo = debugInfoForReference(actionFuncReference);
    throw new Error('You tried to create an action with the {{action}} helper, but the first argument ' + referenceInfo + 'was ' + (typeof actionFunc === 'undefined' ? 'undefined' : _typeof(actionFunc)) + ' instead of a function.');
}
function debugInfoForReference(reference) {
    var message = '';
    var parent = void 0;
    var property = void 0;
    if (reference === null || reference === undefined) {
        return message;
    }
    if ('parent' in reference && 'property' in reference) {
        parent = reference['parent'].value();
        property = reference['property'];
    } else if ('_parentValue' in reference && '_propertyKey' in reference) {
        parent = reference['_parentValue'];
        property = reference['_propertyKey'];
    }
    if (property !== undefined) {
        message += '(\'' + property + '\' on ' + debugName(parent) + ') ';
    }
    return message;
}
function debugName(obj) {
    var objType = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
    if (obj === null || obj === undefined) {
        return objType;
    } else if (objType === 'number' || objType === 'boolean') {
        return obj.toString();
    } else {
        if (obj['debugName']) {
            return obj['debugName'];
        }
        try {
            return JSON.stringify(obj);
        } catch (e) {}
        return obj.toString();
    }
}

var TypedRegistry = function () {
    function TypedRegistry() {
        classCallCheck(this, TypedRegistry);

        this.byName = dict();
        this.byHandle = dict();
    }

    TypedRegistry.prototype.hasName = function hasName(name) {
        return name in this.byName;
    };

    TypedRegistry.prototype.getHandle = function getHandle(name) {
        return this.byName[name];
    };

    TypedRegistry.prototype.hasHandle = function hasHandle(name) {
        return name in this.byHandle;
    };

    TypedRegistry.prototype.getByHandle = function getByHandle(handle) {
        return this.byHandle[handle];
    };

    TypedRegistry.prototype.register = function register(handle, name, value) {
        this.byHandle[handle] = value;
        this.byName[name] = handle;
    };

    return TypedRegistry;
}();

var SimplePathReference = function () {
    function SimplePathReference(parent, property) {
        classCallCheck(this, SimplePathReference);

        this.tag = VOLATILE_TAG;
        this.parent = parent;
        this.property = property;
    }

    SimplePathReference.prototype.value = function value() {
        return this.parent.value()[this.property];
    };

    SimplePathReference.prototype.get = function get$$1(prop) {
        return new SimplePathReference(this, prop);
    };

    return SimplePathReference;
}();
var HelperReference = function () {
    function HelperReference(helper, args) {
        classCallCheck(this, HelperReference);

        this.tag = VOLATILE_TAG;
        this.helper = helper;
        this.args = args.capture();
    }

    HelperReference.prototype.value = function value() {
        var helper = this.helper,
            args = this.args;

        return helper(args.positional.value(), args.named.value());
    };

    HelperReference.prototype.get = function get$$1(prop) {
        return new SimplePathReference(this, prop);
    };

    return HelperReference;
}();

var RuntimeResolver = function () {
    function RuntimeResolver(owner) {
        classCallCheck(this, RuntimeResolver);

        this.owner = owner;
        this.handleLookup = [];
        this.cache = {
            component: new TypedRegistry(),
            template: new TypedRegistry(),
            compiledTemplate: new TypedRegistry(),
            helper: new TypedRegistry(),
            manager: new TypedRegistry(),
            modifier: new TypedRegistry()
        };
    }

    RuntimeResolver.prototype.setCompileOptions = function setCompileOptions(compileOptions) {
        this.templateOptions = compileOptions;
    };

    RuntimeResolver.prototype.lookup = function lookup(type, name, referrer) {
        if (this.cache[type].hasName(name)) {
            return this.cache[type].getHandle(name);
        } else {
            return null;
        }
    };

    RuntimeResolver.prototype.register = function register(type, name, value) {
        var registry = this.cache[type];
        var handle = this.handleLookup.length;
        this.handleLookup.push(registry);
        this.cache[type].register(handle, name, value);
        return handle;
    };

    RuntimeResolver.prototype.lookupModifier = function lookupModifier(name, meta) {
        var handle = this.lookup('modifier', name);
        if (handle === null) {
            throw new Error("Modifier for " + name + " not found.");
        }
        return handle;
    };

    RuntimeResolver.prototype.compileTemplate = function compileTemplate(name, layout) {
        if (!this.cache.compiledTemplate.hasName(name)) {
            var serializedTemplate = this.resolve(layout);
            var block = serializedTemplate.block,
                meta = serializedTemplate.meta,
                id = serializedTemplate.id;

            var parsedBlock = JSON.parse(block);
            var template = new ScannableTemplate(this.templateOptions, { id: id, block: parsedBlock, referrer: meta }).asLayout();
            var invocation = {
                handle: template.compile(),
                symbolTable: template.symbolTable
            };
            this.register('compiledTemplate', name, invocation);
            return invocation;
        }
        var handle = this.lookup('compiledTemplate', name);
        return this.resolve(handle);
    };

    RuntimeResolver.prototype.registerHelper = function registerHelper(name, helper) {
        var glimmerHelper = function glimmerHelper(_vm, args) {
            return new HelperReference(helper, args);
        };
        return this.register('helper', name, glimmerHelper);
    };

    RuntimeResolver.prototype.registerInternalHelper = function registerInternalHelper(name, helper) {
        this.register('helper', name, helper);
    };

    RuntimeResolver.prototype.registerComponent = function registerComponent(name, resolvedSpecifier, Component$$1, template) {
        var templateEntry = this.registerTemplate(resolvedSpecifier, template);
        var manager = this.managerFor(templateEntry.meta.managerId);
        var definition = new ComponentDefinition(name, manager, Component$$1, templateEntry.handle);
        return this.register('component', name, definition);
    };

    RuntimeResolver.prototype.lookupComponentHandle = function lookupComponentHandle(name, referrer) {
        if (!this.cache.component.hasName(name)) {
            this.lookupComponent(name, referrer);
        }
        return this.lookup('component', name, referrer);
    };

    RuntimeResolver.prototype.managerFor = function managerFor() {
        var managerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';

        var manager = void 0;
        if (!this.cache.manager.hasName(managerId)) {
            var rootName = this.owner.rootName;

            manager = this.owner.lookup("component-manager:/" + rootName + "/component-managers/" + managerId);
            if (!manager) {
                throw new Error("No component manager found for ID " + managerId + ".");
            }
            this.register('manager', managerId, manager);
            return manager;
        } else {
            var handle = this.cache.manager.getHandle(managerId);
            return this.cache.manager.getByHandle(handle);
        }
    };

    RuntimeResolver.prototype.registerTemplate = function registerTemplate(resolvedSpecifier, template) {
        return {
            name: resolvedSpecifier,
            handle: this.register('template', resolvedSpecifier, template),
            meta: template.meta
        };
    };

    RuntimeResolver.prototype.lookupComponent = function lookupComponent(name, meta) {
        var handle = void 0;
        if (!this.cache.component.hasName(name)) {
            var specifier = expect(this.identifyComponent(name, meta), "Could not find the component '" + name + "'");
            var template = this.owner.lookup('template', specifier);
            var componentSpecifier = this.owner.identify('component', specifier);
            var componentFactory = null;
            if (componentSpecifier !== undefined) {
                componentFactory = this.owner.factoryFor(componentSpecifier);
            } else {
                componentFactory = {
                    create: function create(injections) {
                        return Component.create(injections);
                    }
                };
            }
            handle = this.registerComponent(name, specifier, componentFactory, template);
        } else {
            handle = this.lookup('component', name, meta);
        }
        return this.resolve(handle);
    };

    RuntimeResolver.prototype.lookupHelper = function lookupHelper(name, meta) {
        if (!this.cache.helper.hasName(name)) {
            var owner = this.owner;
            var relSpecifier = "helper:" + name;
            var referrer = meta.specifier;
            var specifier = owner.identify(relSpecifier, referrer);
            if (specifier === undefined) {
                return null;
            }
            var helper = this.owner.lookup(specifier, meta.specifier);
            return this.registerHelper(name, helper);
        }
        return this.lookup('helper', name, meta);
    };

    RuntimeResolver.prototype.lookupPartial = function lookupPartial(name, meta) {
        throw new Error("Partials are not available in Glimmer applications.");
    };

    RuntimeResolver.prototype.resolve = function resolve(handle) {
        var registry = this.handleLookup[handle];
        return registry.getByHandle(handle);
    };

    RuntimeResolver.prototype.identifyComponent = function identifyComponent(name, meta) {
        var owner = this.owner;
        var relSpecifier = "template:" + name;
        var referrer = meta.specifier;
        var specifier = owner.identify(relSpecifier, referrer);
        if (specifier === undefined && owner.identify("component:" + name, referrer)) {
            throw new Error("The component '" + name + "' is missing a template. All components must have a template. Make sure there is a template.hbs in the component directory.");
        }
        return specifier;
    };

    return RuntimeResolver;
}();

var mainTemplate = { "id": "j7SGa6Pm", "block": "{\"symbols\":[\"root\"],\"statements\":[[4,\"each\",[[22,[\"roots\"]]],[[\"key\"],[\"id\"]],{\"statements\":[[4,\"in-element\",[[21,1,[\"parent\"]]],[[\"guid\",\"nextSibling\"],[\"%cursor:0%\",[21,1,[\"nextSibling\"]]]],{\"statements\":[[1,[26,\"component\",[[21,1,[\"component\"]]],null],false]],\"parameters\":[]},null]],\"parameters\":[1]},null]],\"hasEval\":false}", "meta": { "specifier": "template:/-application/application/src/templates/main" } };

var CompileTimeLookup = function () {
    function CompileTimeLookup(resolver) {
        classCallCheck(this, CompileTimeLookup);

        this.resolver = resolver;
    }

    CompileTimeLookup.prototype.getComponentDefinition = function getComponentDefinition(handle) {
        var spec = this.resolver.resolve(handle);
        debugAssert(!!spec, 'Couldn\'t find a template for ' + handle);
        return spec;
    };

    CompileTimeLookup.prototype.getCapabilities = function getCapabilities(handle) {
        var definition = this.getComponentDefinition(handle);
        var manager = definition.manager,
            state = definition.state;

        return manager.getCapabilities(state);
    };

    CompileTimeLookup.prototype.getLayout = function getLayout(handle) {
        var definition = this.getComponentDefinition(handle);
        var manager = definition.manager;

        var invocation = manager.getLayout(definition, this.resolver);
        return {
            compile: function compile() {
                return invocation.handle;
            },

            symbolTable: invocation.symbolTable
        };
    };

    CompileTimeLookup.prototype.lookupHelper = function lookupHelper(name, referrer) {
        return this.resolver.lookupHelper(name, referrer);
    };

    CompileTimeLookup.prototype.lookupModifier = function lookupModifier(name, referrer) {
        return this.resolver.lookupModifier(name, referrer);
    };

    CompileTimeLookup.prototype.lookupComponentSpec = function lookupComponentSpec(name, referrer) {
        return this.resolver.lookupComponentHandle(name, referrer);
    };

    CompileTimeLookup.prototype.lookupPartial = function lookupPartial(name, referrer) {
        return this.resolver.lookupPartial(name, referrer);
    };

    return CompileTimeLookup;
}();

var Environment$1 = function (_GlimmerEnvironment) {
    inherits(Environment$$1, _GlimmerEnvironment);

    Environment$$1.create = function create() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        options.document = options.document || self.document;
        options.appendOperations = options.appendOperations || new DOMTreeConstruction(options.document);
        return new Environment$$1(options);
    };

    function Environment$$1(options) {
        classCallCheck(this, Environment$$1);

        var _this = possibleConstructorReturn(this, _GlimmerEnvironment.call(this, { appendOperations: options.appendOperations, updateOperations: new DOMChanges$1(options.document || document) }));

        setOwner(_this, getOwner(options));
        var resolver = _this.resolver = new RuntimeResolver(getOwner(_this));
        var program = _this.program = new Program(new LazyConstants(resolver));
        var macros = new Macros();
        var lookup = new CompileTimeLookup(resolver);
        _this.compileOptions = {
            program: program,
            macros: macros,
            lookup: lookup,
            Builder: LazyOpcodeBuilder
        };
        _this.resolver.setCompileOptions(_this.compileOptions);
        resolver.registerTemplate('main', mainTemplate);
        resolver.registerInternalHelper('action', buildAction);
        resolver.registerHelper('if', function (params) {
            return params[0] ? params[1] : params[2];
        });
        // TODO - required for `protocolForURL` - seek alternative approach
        // e.g. see `installPlatformSpecificProtocolForURL` in Ember
        _this.uselessAnchor = options.document.createElement('a');
        return _this;
    }

    Environment$$1.prototype.protocolForURL = function protocolForURL(url) {
        // TODO - investigate alternative approaches
        // e.g. see `installPlatformSpecificProtocolForURL` in Ember
        this.uselessAnchor.href = url;
        return this.uselessAnchor.protocol;
    };

    Environment$$1.prototype.iterableFor = function iterableFor(ref, keyPath) {
        var keyFor = void 0;
        if (!keyPath) {
            throw new Error('Must specify a key for #each');
        }
        switch (keyPath) {
            case '@index':
                keyFor = function keyFor(_, index) {
                    return String(index);
                };
                break;
            case '@primitive':
                keyFor = function keyFor(item) {
                    return String(item);
                };
                break;
            default:
                keyFor = function keyFor(item) {
                    return item[keyPath];
                };
                break;
        }
        return new Iterable(ref, keyFor);
    };

    return Environment$$1;
}(Environment);

var Application = function () {
    function Application(options) {
        classCallCheck(this, Application);

        this._roots = [];
        this._rootsIndex = 0;
        this._initializers = [];
        this._initialized = false;
        this._rendering = false;
        this._rendered = false;
        this._scheduled = false;
        this._notifiers = [];
        this.rootName = options.rootName;
        this.resolver = options.resolver;
        this.document = options.document || typeof window !== 'undefined' && window.document;
    }
    /**
     * Renders a component by name into the provided element, and optionally
     * adjacent to the provided nextSibling element.
     *
     * ## Examples
     *
     * ```js
     * app.renderComponent('MyComponent', document.body, document.getElementById('my-footer'));
     * ```
     */


    Application.prototype.renderComponent = function renderComponent(component, parent) {
        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        this._roots.push({ id: this._rootsIndex++, component: component, parent: parent, nextSibling: nextSibling });
        this.scheduleRerender();
    };
    /**
     * Initializes the application and renders any components that have been
     * registered via `renderComponent()`.
     */


    Application.prototype.boot = function boot() {
        this.initialize();
        this.env = this.lookup('environment:/' + this.rootName + '/main/main');
        this._render();
    };
    /**
     * Schedules all components to revalidate and potentially update the DOM to
     * reflect any changes to underlying component state.
     *
     * Generally speaking, you  should avoid calling `scheduleRerender()`
     * manually. Instead, use tracked properties on components and models, which
     * invoke this method for you automatically when appropriate.
     */


    Application.prototype.scheduleRerender = function scheduleRerender() {
        var _this = this;

        if (this._scheduled || !this._rendered) return;
        this._rendering = true;
        this._scheduled = true;
        requestAnimationFrame(function () {
            _this._scheduled = false;
            _this._rerender();
            _this._rendering = false;
        });
    };
    /** @hidden */


    Application.prototype.initialize = function initialize() {
        this.initRegistry();
        this.initContainer();
    };
    /** @hidden */


    Application.prototype.registerInitializer = function registerInitializer(initializer) {
        this._initializers.push(initializer);
    };
    /**
     * @hidden
     *
     * Initializes the registry, which maps names to objects in the system. Addons
     * and subclasses can customize the behavior of a Glimmer application by
     * overriding objects in the registry.
     */


    Application.prototype.initRegistry = function initRegistry() {
        var registry = this._registry = new Registry();
        // Create ApplicationRegistry as a proxy to the underlying registry
        // that will only be available during `initialize`.
        var appRegistry = new ApplicationRegistry(this._registry, this.resolver);
        registry.register('environment:/' + this.rootName + '/main/main', Environment$1);
        registry.registerOption('helper', 'instantiate', false);
        registry.registerOption('template', 'instantiate', false);
        registry.register('document:/' + this.rootName + '/main/main', this.document);
        registry.registerOption('document', 'instantiate', false);
        registry.registerInjection('environment', 'document', 'document:/' + this.rootName + '/main/main');
        registry.registerInjection('component-manager', 'env', 'environment:/' + this.rootName + '/main/main');
        var initializers = this._initializers;
        for (var i = 0; i < initializers.length; i++) {
            initializers[i].initialize(appRegistry);
        }
        this._initialized = true;
    };
    /**
     * @hidden
     *
     * Initializes the container, which stores instances of objects that come from
     * the registry.
     */


    Application.prototype.initContainer = function initContainer() {
        var _this2 = this;

        this._container = new Container(this._registry, this.resolver);
        // Inject `this` (the app) as the "owner" of every object instantiated
        // by its container.
        this._container.defaultInjections = function (specifier) {
            var hash = {};
            setOwner(hash, _this2);
            return hash;
        };
    };
    /**
     * @hidden
     *
     * The compiled `main` root layout template.
     */


    /** @hidden
     *
     * Ensures the DOM is up-to-date by performing a revalidation on the root
     * template's render result. This method should not be called directly;
     * instead, any mutations in the program that could cause side-effects should
     * call `scheduleRerender()`, which ensures that DOM updates only happen once
     * at the end of the browser's event loop.
     */
    Application.prototype._rerender = function _rerender() {
        var env = this.env,
            result = this._result;

        if (!result) {
            throw new Error('Cannot re-render before initial render has completed');
        }
        try {
            env.begin();
            result.rerender();
            env.commit();
            this._didRender();
        } catch (err) {
            this._didError(err);
        }
    };
    /** @hidden */


    Application.prototype._render = function _render() {
        var env = this.env,
            templateIterator = this.templateIterator;

        try {
            // Begin a new transaction. The transaction stores things like component
            // lifecycle events so they can be flushed once rendering has completed.
            env.begin();
            // Iterate the template iterator, executing the compiled template program
            // until there are no more instructions left to execute.
            var result = void 0;
            do {
                result = templateIterator.next();
            } while (!result.done);
            // Finally, commit the transaction and flush component lifecycle hooks.
            env.commit();
            this._result = result.value;
            this._didRender();
        } catch (err) {
            this._didError(err);
            throw err;
        }
    };

    Application.prototype._didRender = function _didRender() {
        this._rendered = true;
        var notifiers = this._notifiers;
        this._notifiers = [];
        notifiers.forEach(function (n) {
            return n[0]();
        });
    };

    Application.prototype._didError = function _didError(err) {
        var notifiers = this._notifiers;
        this._notifiers = [];
        notifiers.forEach(function (n) {
            return n[1](err);
        });
    };
    /**
     * Owner interface implementation
     *
     * @hidden
     */


    Application.prototype.identify = function identify(specifier, referrer) {
        return this.resolver.identify(specifier, referrer);
    };
    /** @hidden */


    Application.prototype.factoryFor = function factoryFor(specifier, referrer) {
        return this._container.factoryFor(this.identify(specifier, referrer));
    };
    /** @hidden */


    Application.prototype.lookup = function lookup(specifier, referrer) {
        return this._container.lookup(this.identify(specifier, referrer));
    };

    createClass(Application, [{
        key: 'mainLayout',
        get: function get$$1() {
            return templateFactory(mainTemplate).create(this.env.compileOptions);
        }
        /**
         * @hidden
         *
         * Configures and returns a template iterator for the root template, appropriate
         * for performing the initial render of the Glimmer application.
         */

    }, {
        key: 'templateIterator',
        get: function get$$1() {
            var env = this.env,
                mainLayout = this.mainLayout;
            // Create the template context for the root `main` template, which just
            // contains the array of component roots. Any property references in that
            // template will be looked up from this object.

            var self = new RootReference$1({ roots: this._roots });
            // Create an empty root scope.
            var dynamicScope = new DynamicScope();
            // The cursor tells the template which element to render into.
            var cursor = {
                element: this.document.body,
                nextSibling: null
            };
            return mainLayout.renderLayout({
                env: env,
                self: self,
                dynamicScope: dynamicScope,
                builder: clientBuilder(env, cursor)
            });
        }
    }]);
    return Application;
}();

// TODO - use symbol

function isSpecifierStringAbsolute$1(specifier) {
    var _specifier$split = specifier.split(':'),
        type = _specifier$split[0],
        path = _specifier$split[1];

    return !!(type && path && path.indexOf('/') === 0 && path.split('/').length > 3);
}
function isSpecifierObjectAbsolute$1(specifier) {
    return specifier.rootName !== undefined && specifier.collection !== undefined && specifier.name !== undefined && specifier.type !== undefined;
}
function serializeSpecifier$1(specifier) {
    var type = specifier.type;
    var path = serializeSpecifierPath$1(specifier);
    if (path) {
        return type + ':' + path;
    } else {
        return type;
    }
}
function serializeSpecifierPath$1(specifier) {
    var path = [];
    if (specifier.rootName) {
        path.push(specifier.rootName);
    }
    if (specifier.collection) {
        path.push(specifier.collection);
    }
    if (specifier.namespace) {
        path.push(specifier.namespace);
    }
    if (specifier.name) {
        path.push(specifier.name);
    }
    if (path.length > 0) {
        var fullPath = path.join('/');
        if (isSpecifierObjectAbsolute$1(specifier)) {
            fullPath = '/' + fullPath;
        }
        return fullPath;
    }
}
function deserializeSpecifier$1(specifier) {
    var obj = {};
    if (specifier.indexOf(':') > -1) {
        var _specifier$split2 = specifier.split(':'),
            type = _specifier$split2[0],
            path = _specifier$split2[1];

        obj.type = type;
        var pathSegments = void 0;
        if (path.indexOf('/') === 0) {
            pathSegments = path.substr(1).split('/');
            obj.rootName = pathSegments.shift();
            obj.collection = pathSegments.shift();
        } else {
            pathSegments = path.split('/');
        }
        if (pathSegments.length > 0) {
            obj.name = pathSegments.pop();
            if (pathSegments.length > 0) {
                obj.namespace = pathSegments.join('/');
            }
        }
    } else {
        obj.type = specifier;
    }
    return obj;
}

function assert$1(description, test) {
    if (!test) {
        throw new Error('Assertion Failed: ' + description);
    }
}

function detectLocalResolutionCollection(specifier) {
    var namespace = specifier.namespace,
        collection = specifier.collection;
    // Look for the local-most private collection contained in the namespace
    // (which will appear closest to the end of the string)

    var startPos = namespace.lastIndexOf('/-');
    if (startPos > -1) {
        startPos += 2;
        var endPos = namespace.indexOf('/', startPos);
        collection = namespace.slice(startPos, endPos > -1 ? endPos : undefined);
    }
    return collection;
}

var Resolver = function () {
    function Resolver(config, registry) {
        classCallCheck(this, Resolver);

        this.config = config;
        this.registry = registry;
    }

    Resolver.prototype.identify = function identify(specifier, referrer) {
        if (isSpecifierStringAbsolute$1(specifier)) {
            return specifier;
        }
        var s = deserializeSpecifier$1(specifier);
        var result = void 0;
        if (referrer) {
            var r = deserializeSpecifier$1(referrer);
            if (isSpecifierObjectAbsolute$1(r)) {
                assert$1('Specifier must not include a rootName, collection, or namespace when combined with an absolute referrer', s.rootName === undefined && s.collection === undefined && s.namespace === undefined);
                s.rootName = r.rootName;
                s.collection = r.collection;
                var definitiveCollection = this._definitiveCollection(s.type);
                if (!s.name) {
                    /*
                     * For specifiers without a name use the referrer's name and
                     * do not fallback to any other resolution rules.
                     */
                    s.namespace = r.namespace;
                    s.name = r.name;
                    return this._serializeAndVerify(s);
                }
                s.namespace = r.namespace ? r.namespace + '/' + r.name : r.name;
                if (detectLocalResolutionCollection(s) === definitiveCollection) {
                    /*
                     * For specifiers with a name, try local resolution. Based on
                     * the referrer.
                     */
                    if (result = this._serializeAndVerify(s)) {
                        return result;
                    }
                }
                // Look for a private collection in the referrer's namespace
                if (definitiveCollection) {
                    s.namespace += '/-' + definitiveCollection;
                    if (result = this._serializeAndVerify(s)) {
                        return result;
                    }
                }
                // Because local and private resolution has failed, clear all but `name` and `type`
                // to proceed with top-level resolution
                s.rootName = s.collection = s.namespace = undefined;
            } else {
                assert$1('Referrer must either be "absolute" or include a `type` to determine the associated type', r.type);
                // Look in the definitive collection for the associated type
                s.collection = this._definitiveCollection(r.type);
                if (!s.namespace) {
                    s.namespace = r.rootName;
                }
                assert$1('\'' + r.type + '\' does not have a definitive collection', s.collection);
            }
        }
        // If the collection is unspecified, use the definitive collection for the `type`
        if (!s.collection) {
            s.collection = this._definitiveCollection(s.type);
            assert$1('\'' + s.type + '\' does not have a definitive collection', s.collection);
        }
        if (!s.rootName) {
            // If the root name is unspecified, try the app's `rootName` first
            s.rootName = this.config.app.rootName || 'app';
            if (result = this._serializeAndVerify(s)) {
                return result;
            }
            // Then look for an addon with a matching `rootName`
            if (s.namespace) {
                s.rootName = s.namespace;
                s.namespace = undefined;
            } else {
                s.rootName = s.name;
                s.name = 'main';
            }
        }
        if (result = this._serializeAndVerify(s)) {
            return result;
        }
    };

    Resolver.prototype.retrieve = function retrieve(specifier) {
        return this.registry.get(specifier);
    };

    Resolver.prototype.resolve = function resolve(specifier, referrer) {
        var id = this.identify(specifier, referrer);
        if (id) {
            return this.retrieve(id);
        }
    };

    Resolver.prototype._definitiveCollection = function _definitiveCollection(type) {
        var typeDef = this.config.types[type];
        assert$1('\'' + type + '\' is not a recognized type', typeDef);
        return typeDef.definitiveCollection;
    };

    Resolver.prototype._serializeAndVerify = function _serializeAndVerify(specifier) {
        var serialized = serializeSpecifier$1(specifier);
        if (this.registry.has(serialized)) {
            return serialized;
        }
    };

    return Resolver;
}();

var BasicRegistry = function () {
    function BasicRegistry() {
        var entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        classCallCheck(this, BasicRegistry);

        this._entries = entries;
    }

    BasicRegistry.prototype.has = function has(specifier) {
        return specifier in this._entries;
    };

    BasicRegistry.prototype.get = function get$$1(specifier) {
        return this._entries[specifier];
    };

    return BasicRegistry;
}();

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var SearchInput = function (_Component) {
    inherits(SearchInput, _Component);

    function SearchInput() {
        classCallCheck(this, SearchInput);

        var _this = possibleConstructorReturn(this, _Component.apply(this, arguments));

        _this.state = {
            query: '',
            index: null,
            results: {},
            selectedResult: null,
            isLoading: false,
            showResults: false
        };
        return _this;
    }
    // lifecycle hooks
    // actions


    SearchInput.prototype.setQuery = function setQuery(event) {
        var query = event.target.value.toLowerCase();
        if (query && !this.state.index) {
            this._loadIndex();
        }
        this.state = Object.assign({}, this.state, { query: query });
        this.performSearch(query);
    };

    SearchInput.prototype.openResult = function openResult(result) {
        window.location.href = result.url;
    };

    SearchInput.prototype.openSelectedResult = function openSelectedResult(event) {
        var result = this.state.selectedResult;
        event.preventDefault();
        if (result) {
            this.openResult(result);
        }
    };

    SearchInput.prototype.inputGainedFocus = function inputGainedFocus(event) {
        if (this.state.query) {
            this.showResults();
        }
    };

    SearchInput.prototype.inputLostFocus = function inputLostFocus(event) {
        this.hideResults();
    };

    SearchInput.prototype.inputKeydown = function inputKeydown(event) {
        if (!this.state.showResults || !this.state.selectedResult) {
            return;
        }
        if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
            var results = this.state.results && this.state.results.pages || [];
            var result = this.state.selectedResult;
            var currIndex = results.indexOf(result);
            var newIndex = 0;
            event.preventDefault();
            if (event.key === 'ArrowDown') {
                newIndex = currIndex + 1;
                // loop to top
                if (newIndex >= results.length) {
                    newIndex = 0;
                }
            }
            if (event.key === 'ArrowUp') {
                newIndex = currIndex - 1;
                // loop to bottom
                if (newIndex < 0) {
                    newIndex = results.length - 1;
                }
            }
            var selectedResult = results[newIndex];
            this.state = Object.assign({}, this.state, { selectedResult: selectedResult });
        }
    };
    // functions


    SearchInput.prototype.performSearch = function performSearch(query) {
        var index = this.state.index || { pages: [] };
        var results = { pages: [] };
        var selectedResult = null;
        if (query) {
            results.pages = index.pages.filter(function (page) {
                var matchedTerms = page.terms.filter(function (term) {
                    return term.indexOf(query) > -1;
                });
                return matchedTerms.length > 0;
            });
        } else {
            results.pages = [];
        }
        // highlight the first result
        var _results$pages = results.pages;
        selectedResult = _results$pages[0];

        this.state = Object.assign({}, this.state, { results: results,
            selectedResult: selectedResult });
        if (query) {
            this.showResults();
        } else {
            this.hideResults();
        }
    };

    SearchInput.prototype.showResults = function showResults() {
        if (this.state.showResults) {
            return;
        }
        this.state = Object.assign({}, this.state, { showResults: true });
    };

    SearchInput.prototype.hideResults = function hideResults() {
        if (!this.state.showResults) {
            return;
        }
        this.state = Object.assign({}, this.state, { showResults: false });
    };

    SearchInput.prototype.clearResults = function clearResults() {
        this.state = Object.assign({}, this.state, { query: '', results: [] });
        this.hideResults();
    };
    // private functions


    SearchInput.prototype._loadIndex = function _loadIndex() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
            var indexUrl, request, json, index;
            return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            indexUrl = 'http://localhost:9999/search-index.json';

                            if (!(this.state.index || this.state.isLoading)) {
                                _context.next = 3;
                                break;
                            }

                            return _context.abrupt("return");

                        case 3:
                            this.state = Object.assign({}, this.state, { isLoading: true });
                            // TODO: use proper URL depending on env
                            _context.next = 6;
                            return fetch(indexUrl);

                        case 6:
                            request = _context.sent;
                            _context.next = 9;
                            return request.json();

                        case 9:
                            json = _context.sent;
                            index = this._generateIndex(json);

                            this.state = Object.assign({}, this.state, { index: index, isLoading: false });
                            this.performSearch(this.state.query);

                        case 13:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee, this);
        }));
    };

    SearchInput.prototype._generateIndex = function _generateIndex(json) {
        var pages = json.pages.map(function (page) {
            var keywords = page.keywords || [];
            return {
                url: page.url,
                title: page.title,
                terms: [page.title.toLowerCase()].concat(keywords)
            };
        });
        return { pages: pages };
    };

    return SearchInput;
}(Component);

__decorate([tracked], SearchInput.prototype, "state", void 0);

var __ui_components_SearchInput_template__ = { "id": "81erj4FV", "block": "{\"symbols\":[\"result\",\"@class\",\"@style\"],\"statements\":[[6,\"form\"],[10,\"action\",\"\"],[11,\"class\",[27,[\"relative gd-drop \",[26,\"if\",[[22,[\"state\",\"showResults\"]],\"active\"],null]]]],[11,\"onsubmit\",[26,\"action\",[[22,[\"openSelectedResult\"]]],null],null],[8],[0,\"\\n    \"],[6,\"input\"],[10,\"type\",\"text\"],[11,\"value\",[22,[\"state\",\"query\"]],null],[10,\"placeholder\",\"Search...\"],[11,\"class\",[21,2,[]],null],[11,\"style\",[21,3,[]],null],[10,\"autocomplete\",\"off\"],[11,\"oninput\",[26,\"action\",[[22,[\"setQuery\"]]],null],null],[11,\"onfocus\",[26,\"action\",[[22,[\"inputGainedFocus\"]]],null],null],[11,\"onblur\",[26,\"action\",[[22,[\"inputLostFocus\"]]],null],null],[11,\"onkeydown\",[26,\"action\",[[22,[\"inputKeydown\"]]],null],null],[8],[9],[0,\"\\n\\n\\n        \"],[6,\"ul\"],[10,\"id\",\"results\"],[10,\"class\",\"absolute z-999 bg-white o-0 br3 br--bottom anim-slow shadow-1-strong darkgrey dd-w2 trans-form-up pa0 f8 midgrey lh-copy list js-search-dropdown \"],[8],[0,\"\\n\"],[4,\"if\",[[22,[\"state\",\"isLoading\"]]],null,{\"statements\":[[0,\"                \"],[6,\"li\"],[10,\"class\",\"\"],[8],[0,\"Loading...\"],[9],[0,\"\\n\"]],\"parameters\":[]},{\"statements\":[[4,\"each\",[[22,[\"state\",\"results\",\"pages\"]]],[[\"key\"],[\"@index\"]],{\"statements\":[[0,\"                    \"],[6,\"li\"],[11,\"class\",[27,[[26,\"if\",[[26,\"eq\",[[21,1,[]],[22,[\"state\",\"selectedResult\"]]],null],\"bg-yellow\"],null]]]],[11,\"onmousedown\",[26,\"action\",[[22,[\"openResult\"]],[21,1,[]]],null],null],[8],[0,\"\\n                        \"],[6,\"a\"],[11,\"href\",[21,1,[\"url\"]],null],[10,\"class\",\"darkgrey-l2 hover-blue-d2 link db pl2 pr2 pt1 pb1\"],[8],[1,[21,1,[\"title\"]],false],[9],[0,\"\\n                    \"],[9],[0,\"\\n\"]],\"parameters\":[1]},{\"statements\":[[0,\"                    \"],[6,\"li\"],[10,\"class\",\"pa2 tc\"],[8],[0,\"No results found\"],[9],[0,\"\\n\"]],\"parameters\":[]}]],\"parameters\":[]}],[0,\"        \"],[9],[0,\"\\n\"],[9],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/search-input/components/SearchInput" } };

var __ui_components_SearchInputBrand_template__ = { "id": "molihOa8", "block": "{\"symbols\":[],\"statements\":[[5,\"SearchInput\",[],[[\"@class\",\"@style\"],[\"pa2 br2 ba b--transparent bg-white middarkgrey whitney f8\",\"width: 210px\"]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/search-input/components/SearchInputBrand" } };

var __ui_components_SearchInputProduct_template__ = { "id": "hBKCmBta", "block": "{\"symbols\":[],\"statements\":[[5,\"SearchInput\",[],[[\"@class\"],[\"pa2 br2 ba b--transparent bg-white-10 white whitney f8 gh-nav-searchbox input-reset form-text\"]],{\"statements\":[],\"parameters\":[]}],[0,\"\\n\"]],\"hasEval\":false}", "meta": { "specifier": "template:/search-input/components/SearchInputProduct" } };

function eq(params) {
    return params[0] === params[1];
}

var moduleMap = { 'component:/search-input/components/SearchInput': SearchInput, 'template:/search-input/components/SearchInput': __ui_components_SearchInput_template__, 'template:/search-input/components/SearchInputBrand': __ui_components_SearchInputBrand_template__, 'template:/search-input/components/SearchInputProduct': __ui_components_SearchInputProduct_template__, 'helper:/search-input/components/eq': eq };

var resolverConfiguration = { "app": { "name": "search-input", "rootName": "search-input" }, "types": { "application": { "definitiveCollection": "main" }, "component": { "definitiveCollection": "components" }, "component-test": { "unresolvable": true }, "helper": { "definitiveCollection": "components" }, "helper-test": { "unresolvable": true }, "renderer": { "definitiveCollection": "main" }, "template": { "definitiveCollection": "components" } }, "collections": { "main": { "types": ["application", "renderer"] }, "components": { "group": "ui", "types": ["component", "component-test", "template", "helper", "helper-test"], "defaultType": "component", "privateCollections": ["utils"] }, "styles": { "group": "ui", "unresolvable": true }, "utils": { "unresolvable": true } } };

var App = function (_Application) {
    inherits(App, _Application);

    function App() {
        classCallCheck(this, App);

        var moduleRegistry = new BasicRegistry(moduleMap);
        var resolver = new Resolver(resolverConfiguration, moduleRegistry);
        return possibleConstructorReturn(this, _Application.call(this, {
            resolver: resolver,
            rootName: resolverConfiguration.app.rootName
        }));
    }

    return App;
}(Application);

(function (self) {
  'use strict';

  if (self.fetch) {
    return;
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && function () {
      try {
        new Blob();
        return true;
      } catch (e) {
        return false;
      }
    }(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

    var isDataView = function isDataView(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj);
    };

    var isArrayBufferView = ArrayBuffer.isView || function (obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name');
    }
    return name.toLowerCase();
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value;
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function next() {
        var value = items.shift();
        return { done: value === undefined, value: value };
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function () {
        return iterator;
      };
    }

    return iterator;
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function (value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function (header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function (name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function (name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ',' + value : value;
  };

  Headers.prototype['delete'] = function (name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function (name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
  };

  Headers.prototype.has = function (name) {
    return this.map.hasOwnProperty(normalizeName(name));
  };

  Headers.prototype.set = function (name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function (callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push(name);
    });
    return iteratorFor(items);
  };

  Headers.prototype.values = function () {
    var items = [];
    this.forEach(function (value) {
      items.push(value);
    });
    return iteratorFor(items);
  };

  Headers.prototype.entries = function () {
    var items = [];
    this.forEach(function (value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items);
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'));
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function (resolve, reject) {
      reader.onload = function () {
        resolve(reader.result);
      };
      reader.onerror = function () {
        reject(reader.error);
      };
    });
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise;
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('');
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0);
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer;
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function (body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type');
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function () {
        var rejected = consumed(this);
        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob');
        } else {
          return Promise.resolve(new Blob([this._bodyText]));
        }
      };

      this.arrayBuffer = function () {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
        } else {
          return this.blob().then(readBlobAsArrayBuffer);
        }
      };
    }

    this.text = function () {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text');
      } else {
        return Promise.resolve(this._bodyText);
      }
    };

    if (support.formData) {
      this.formData = function () {
        return this.text().then(decode);
      };
    }

    this.json = function () {
      return this.text().then(JSON.parse);
    };

    return this;
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read');
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests');
    }
    this._initBody(body);
  }

  Request.prototype.clone = function () {
    return new Request(this, { body: this._bodyInit });
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function (bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form;
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    rawHeaders.split(/\r?\n/).forEach(function (line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers;
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = 'status' in options ? options.status : 200;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function () {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    });
  };

  Response.error = function () {
    var response = new Response(null, { status: 0, statusText: '' });
    response.type = 'error';
    return response;
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function (url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code');
    }

    return new Response(null, { status: status, headers: { location: url } });
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function (input, init) {
    return new Promise(function (resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function () {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function () {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function (value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    });
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : undefined);

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function () {
    fn.apply(thisArg, arguments);
  };
}

function Promise$1(fn) {
  if (!(this instanceof Promise$1)) throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  this._state = 0;
  this._handled = false;
  this._value = undefined;
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise$1._immediateFn(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
    if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {
      var then = newValue.then;
      if (newValue instanceof Promise$1) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise$1._immediateFn(function () {
      if (!self._handled) {
        Promise$1._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return;
      done = true;
      resolve(self, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(self, reason);
    });
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise$1.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

Promise$1.prototype.then = function (onFulfilled, onRejected) {
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise$1.prototype['finally'] = function (callback) {
  var constructor = this.constructor;
  return this.then(function (value) {
    return constructor.resolve(callback()).then(function () {
      return value;
    });
  }, function (reason) {
    return constructor.resolve(callback()).then(function () {
      return constructor.reject(reason);
    });
  });
};

Promise$1.all = function (arr) {
  return new Promise$1(function (resolve, reject) {
    if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise$1.resolve = function (value) {
  if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise$1) {
    return value;
  }

  return new Promise$1(function (resolve) {
    resolve(value);
  });
};

Promise$1.reject = function (value) {
  return new Promise$1(function (resolve, reject) {
    reject(value);
  });
};

Promise$1.race = function (values) {
  return new Promise$1(function (resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise$1._immediateFn = typeof setImmediate === 'function' && function (fn) {
  setImmediate(fn);
} || function (fn) {
  setTimeoutFunc(fn, 0);
};

Promise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

var global$1 = function () {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global$1 !== 'undefined') {
    return global$1;
  }
  throw new Error('unable to locate global object');
}();

if (!global$1.Promise) {
  global$1.Promise = Promise$1;
}

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!function (global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction ||
    // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  runtime.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function (arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value && (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
      // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,
      // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));

    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function (object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function stop() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
}(
// In sloppy mode, unbound `this` refers to the global object, fallback to
// Function constructor if we're in global strict mode. That is sadly a form
// of indirect eval which violates Content Security Policy.
function () {
  return this;
}() || Function("return this")());

// import polyfills for IE11
var app = new App();
var productElement = document.getElementById('product-search-input');
var brandElement = document.getElementById('brand-search-input');
setPropertyDidChange(function () {
    app.scheduleRerender();
});
app.registerInitializer({
    initialize: function initialize(registry) {
        registry.register('component-manager:/' + app.rootName + '/component-managers/main', ComponentManager);
    }
});
if (productElement) {
    app.renderComponent('SearchInputProduct', productElement, null);
}
if (brandElement) {
    app.renderComponent('SearchInputBrand', brandElement, null);
}
app.boot();

})));

//# sourceMappingURL=app.js.map

//# sourceMappingURL=components.js.map

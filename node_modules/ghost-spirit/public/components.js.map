{"version":3,"sources":["app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"components.js","sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(factory());\n}(this, (function () { 'use strict';\n\nfunction expect(val, message) {\n    if (val === null || val === undefined) throw new Error(message);\n    return val;\n}\nfunction unreachable() {\n    var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"unreachable\";\n\n    return new Error(message);\n}\n\n// import Logger from './logger';\n// let alreadyWarned = false;\nfunction debugAssert(test, msg) {\n    // if (!alreadyWarned) {\n    //   alreadyWarned = true;\n    //   Logger.warn(\"Don't leave debug assertions on in public builds\");\n    // }\n    if (!test) {\n        throw new Error(msg || \"assertion failure\");\n    }\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\n\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar objKeys = Object.keys;\n\nfunction assign(obj) {\n    for (var i = 1; i < arguments.length; i++) {\n        var assignment = arguments[i];\n        if (assignment === null || (typeof assignment === 'undefined' ? 'undefined' : _typeof(assignment)) !== 'object') continue;\n        var keys = objKeys(assignment);\n        for (var j = 0; j < keys.length; j++) {\n            var key = keys[j];\n            obj[key] = assignment[key];\n        }\n    }\n    return obj;\n}\nfunction fillNulls(count) {\n    var arr = new Array(count);\n    for (var i = 0; i < count; i++) {\n        arr[i] = null;\n    }\n    return arr;\n}\n\nvar GUID = 0;\nfunction initializeGuid(object) {\n    return object._guid = ++GUID;\n}\nfunction ensureGuid(object) {\n    return object._guid || initializeGuid(object);\n}\n\nfunction dict() {\n    return Object.create(null);\n}\nvar DictSet = function () {\n    function DictSet() {\n        classCallCheck(this, DictSet);\n\n        this.dict = dict();\n    }\n\n    DictSet.prototype.add = function add(obj) {\n        if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[ensureGuid(obj)] = obj;\n        return this;\n    };\n\n    DictSet.prototype.delete = function _delete(obj) {\n        if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];\n    };\n\n    return DictSet;\n}();\nvar Stack = function () {\n    function Stack() {\n        classCallCheck(this, Stack);\n\n        this.stack = [];\n        this.current = null;\n    }\n\n    Stack.prototype.push = function push(item) {\n        this.current = item;\n        this.stack.push(item);\n    };\n\n    Stack.prototype.pop = function pop() {\n        var item = this.stack.pop();\n        var len = this.stack.length;\n        this.current = len === 0 ? null : this.stack[len - 1];\n        return item === undefined ? null : item;\n    };\n\n    Stack.prototype.isEmpty = function isEmpty() {\n        return this.stack.length === 0;\n    };\n\n    createClass(Stack, [{\n        key: 'size',\n        get: function get$$1() {\n            return this.stack.length;\n        }\n    }]);\n    return Stack;\n}();\n\nvar ListNode = function ListNode(value) {\n    classCallCheck(this, ListNode);\n\n    this.next = null;\n    this.prev = null;\n    this.value = value;\n};\nvar LinkedList = function () {\n    function LinkedList() {\n        classCallCheck(this, LinkedList);\n\n        this.clear();\n    }\n\n    LinkedList.prototype.head = function head() {\n        return this._head;\n    };\n\n    LinkedList.prototype.tail = function tail() {\n        return this._tail;\n    };\n\n    LinkedList.prototype.clear = function clear() {\n        this._head = this._tail = null;\n    };\n\n    LinkedList.prototype.toArray = function toArray$$1() {\n        var out = [];\n        this.forEachNode(function (n) {\n            return out.push(n);\n        });\n        return out;\n    };\n\n    LinkedList.prototype.nextNode = function nextNode(node) {\n        return node.next;\n    };\n\n    LinkedList.prototype.forEachNode = function forEachNode(callback) {\n        var node = this._head;\n        while (node !== null) {\n            callback(node);\n            node = node.next;\n        }\n    };\n\n    LinkedList.prototype.insertBefore = function insertBefore(node) {\n        var reference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        if (reference === null) return this.append(node);\n        if (reference.prev) reference.prev.next = node;else this._head = node;\n        node.prev = reference.prev;\n        node.next = reference;\n        reference.prev = node;\n        return node;\n    };\n\n    LinkedList.prototype.append = function append(node) {\n        var tail = this._tail;\n        if (tail) {\n            tail.next = node;\n            node.prev = tail;\n            node.next = null;\n        } else {\n            this._head = node;\n        }\n        return this._tail = node;\n    };\n\n    LinkedList.prototype.remove = function remove(node) {\n        if (node.prev) node.prev.next = node.next;else this._head = node.next;\n        if (node.next) node.next.prev = node.prev;else this._tail = node.prev;\n        return node;\n    };\n\n    return LinkedList;\n}();\nvar ListSlice = function () {\n    function ListSlice(head, tail) {\n        classCallCheck(this, ListSlice);\n\n        this._head = head;\n        this._tail = tail;\n    }\n\n    ListSlice.prototype.forEachNode = function forEachNode(callback) {\n        var node = this._head;\n        while (node !== null) {\n            callback(node);\n            node = this.nextNode(node);\n        }\n    };\n\n    ListSlice.prototype.head = function head() {\n        return this._head;\n    };\n\n    ListSlice.prototype.tail = function tail() {\n        return this._tail;\n    };\n\n    ListSlice.prototype.toArray = function toArray$$1() {\n        var out = [];\n        this.forEachNode(function (n) {\n            return out.push(n);\n        });\n        return out;\n    };\n\n    ListSlice.prototype.nextNode = function nextNode(node) {\n        if (node === this._tail) return null;\n        return node.next;\n    };\n\n    return ListSlice;\n}();\nvar EMPTY_SLICE = new ListSlice(null, null);\n\nvar EMPTY_ARRAY = Object.freeze([]);\n\nvar CONSTANT = 0;\nvar INITIAL = 1;\nvar VOLATILE = NaN;\nvar RevisionTag = function () {\n    function RevisionTag() {\n        classCallCheck(this, RevisionTag);\n    }\n\n    RevisionTag.prototype.validate = function validate(snapshot) {\n        return this.value() === snapshot;\n    };\n\n    return RevisionTag;\n}();\nRevisionTag.id = 0;\nvar VALUE = [];\nvar VALIDATE = [];\nvar TagWrapper = function () {\n    function TagWrapper(type, inner) {\n        classCallCheck(this, TagWrapper);\n\n        this.type = type;\n        this.inner = inner;\n    }\n\n    TagWrapper.prototype.value = function value() {\n        var func = VALUE[this.type];\n        return func(this.inner);\n    };\n\n    TagWrapper.prototype.validate = function validate(snapshot) {\n        var func = VALIDATE[this.type];\n        return func(this.inner, snapshot);\n    };\n\n    return TagWrapper;\n}();\nfunction register(Type) {\n    var type = VALUE.length;\n    VALUE.push(function (tag) {\n        return tag.value();\n    });\n    VALIDATE.push(function (tag, snapshot) {\n        return tag.validate(snapshot);\n    });\n    Type.id = type;\n}\n///\n// CONSTANT: 0\nVALUE.push(function () {\n    return CONSTANT;\n});\nVALIDATE.push(function (_tag, snapshot) {\n    return snapshot === CONSTANT;\n});\nvar CONSTANT_TAG = new TagWrapper(0, null);\n// VOLATILE: 1\nVALUE.push(function () {\n    return VOLATILE;\n});\nVALIDATE.push(function (_tag, snapshot) {\n    return snapshot === VOLATILE;\n});\nvar VOLATILE_TAG = new TagWrapper(1, null);\n// CURRENT: 2\nVALUE.push(function () {\n    return $REVISION;\n});\nVALIDATE.push(function (_tag, snapshot) {\n    return snapshot === $REVISION;\n});\nvar CURRENT_TAG = new TagWrapper(2, null);\nfunction isConst(_ref) {\n    var tag = _ref.tag;\n\n    return tag === CONSTANT_TAG;\n}\nfunction isConstTag(tag) {\n    return tag === CONSTANT_TAG;\n}\n///\nvar $REVISION = INITIAL;\nvar DirtyableTag = function (_RevisionTag) {\n    inherits(DirtyableTag, _RevisionTag);\n\n    DirtyableTag.create = function create() {\n        var revision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $REVISION;\n\n        return new TagWrapper(this.id, new DirtyableTag(revision));\n    };\n\n    function DirtyableTag() {\n        var revision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $REVISION;\n        classCallCheck(this, DirtyableTag);\n\n        var _this = possibleConstructorReturn(this, _RevisionTag.call(this));\n\n        _this.revision = revision;\n        return _this;\n    }\n\n    DirtyableTag.prototype.value = function value() {\n        return this.revision;\n    };\n\n    DirtyableTag.prototype.dirty = function dirty() {\n        this.revision = ++$REVISION;\n    };\n\n    return DirtyableTag;\n}(RevisionTag);\nregister(DirtyableTag);\nfunction combineTagged(tagged) {\n    var optimized = [];\n    for (var i = 0, l = tagged.length; i < l; i++) {\n        var tag = tagged[i].tag;\n        if (tag === VOLATILE_TAG) return VOLATILE_TAG;\n        if (tag === CONSTANT_TAG) continue;\n        optimized.push(tag);\n    }\n    return _combine(optimized);\n}\nfunction combineSlice(slice) {\n    var optimized = [];\n    var node = slice.head();\n    while (node !== null) {\n        var tag = node.tag;\n        if (tag === VOLATILE_TAG) return VOLATILE_TAG;\n        if (tag !== CONSTANT_TAG) optimized.push(tag);\n        node = slice.nextNode(node);\n    }\n    return _combine(optimized);\n}\nfunction combine(tags) {\n    var optimized = [];\n    for (var i = 0, l = tags.length; i < l; i++) {\n        var tag = tags[i];\n        if (tag === VOLATILE_TAG) return VOLATILE_TAG;\n        if (tag === CONSTANT_TAG) continue;\n        optimized.push(tag);\n    }\n    return _combine(optimized);\n}\nfunction _combine(tags) {\n    switch (tags.length) {\n        case 0:\n            return CONSTANT_TAG;\n        case 1:\n            return tags[0];\n        case 2:\n            return TagsPair.create(tags[0], tags[1]);\n        default:\n            return TagsCombinator.create(tags);\n    }\n}\nvar CachedTag = function (_RevisionTag2) {\n    inherits(CachedTag, _RevisionTag2);\n\n    function CachedTag() {\n        classCallCheck(this, CachedTag);\n\n        var _this2 = possibleConstructorReturn(this, _RevisionTag2.apply(this, arguments));\n\n        _this2.lastChecked = null;\n        _this2.lastValue = null;\n        return _this2;\n    }\n\n    CachedTag.prototype.value = function value() {\n        var lastChecked = this.lastChecked,\n            lastValue = this.lastValue;\n\n        if (lastChecked !== $REVISION) {\n            this.lastChecked = $REVISION;\n            this.lastValue = lastValue = this.compute();\n        }\n        return this.lastValue;\n    };\n\n    CachedTag.prototype.invalidate = function invalidate() {\n        this.lastChecked = null;\n    };\n\n    return CachedTag;\n}(RevisionTag);\n\nvar TagsPair = function (_CachedTag) {\n    inherits(TagsPair, _CachedTag);\n\n    TagsPair.create = function create(first, second) {\n        return new TagWrapper(this.id, new TagsPair(first, second));\n    };\n\n    function TagsPair(first, second) {\n        classCallCheck(this, TagsPair);\n\n        var _this3 = possibleConstructorReturn(this, _CachedTag.call(this));\n\n        _this3.first = first;\n        _this3.second = second;\n        return _this3;\n    }\n\n    TagsPair.prototype.compute = function compute() {\n        return Math.max(this.first.value(), this.second.value());\n    };\n\n    return TagsPair;\n}(CachedTag);\n\nregister(TagsPair);\n\nvar TagsCombinator = function (_CachedTag2) {\n    inherits(TagsCombinator, _CachedTag2);\n\n    TagsCombinator.create = function create(tags) {\n        return new TagWrapper(this.id, new TagsCombinator(tags));\n    };\n\n    function TagsCombinator(tags) {\n        classCallCheck(this, TagsCombinator);\n\n        var _this4 = possibleConstructorReturn(this, _CachedTag2.call(this));\n\n        _this4.tags = tags;\n        return _this4;\n    }\n\n    TagsCombinator.prototype.compute = function compute() {\n        var tags = this.tags;\n\n        var max = -1;\n        for (var i = 0; i < tags.length; i++) {\n            var value = tags[i].value();\n            max = Math.max(value, max);\n        }\n        return max;\n    };\n\n    return TagsCombinator;\n}(CachedTag);\n\nregister(TagsCombinator);\nvar UpdatableTag = function (_CachedTag3) {\n    inherits(UpdatableTag, _CachedTag3);\n\n    UpdatableTag.create = function create(tag) {\n        return new TagWrapper(this.id, new UpdatableTag(tag));\n    };\n\n    function UpdatableTag(tag) {\n        classCallCheck(this, UpdatableTag);\n\n        var _this5 = possibleConstructorReturn(this, _CachedTag3.call(this));\n\n        _this5.tag = tag;\n        _this5.lastUpdated = INITIAL;\n        return _this5;\n    }\n\n    UpdatableTag.prototype.compute = function compute() {\n        return Math.max(this.lastUpdated, this.tag.value());\n    };\n\n    UpdatableTag.prototype.update = function update(tag) {\n        if (tag !== this.tag) {\n            this.tag = tag;\n            this.lastUpdated = $REVISION;\n            this.invalidate();\n        }\n    };\n\n    return UpdatableTag;\n}(CachedTag);\nregister(UpdatableTag);\nvar CachedReference = function () {\n    function CachedReference() {\n        classCallCheck(this, CachedReference);\n\n        this.lastRevision = null;\n        this.lastValue = null;\n    }\n\n    CachedReference.prototype.value = function value() {\n        var tag = this.tag,\n            lastRevision = this.lastRevision,\n            lastValue = this.lastValue;\n\n        if (lastRevision === null || !tag.validate(lastRevision)) {\n            lastValue = this.lastValue = this.compute();\n            this.lastRevision = tag.value();\n        }\n        return lastValue;\n    };\n\n    CachedReference.prototype.invalidate = function invalidate() {\n        this.lastRevision = null;\n    };\n\n    return CachedReference;\n}();\n\nvar MapperReference = function (_CachedReference) {\n    inherits(MapperReference, _CachedReference);\n\n    function MapperReference(reference, mapper) {\n        classCallCheck(this, MapperReference);\n\n        var _this6 = possibleConstructorReturn(this, _CachedReference.call(this));\n\n        _this6.tag = reference.tag;\n        _this6.reference = reference;\n        _this6.mapper = mapper;\n        return _this6;\n    }\n\n    MapperReference.prototype.compute = function compute() {\n        var reference = this.reference,\n            mapper = this.mapper;\n\n        return mapper(reference.value());\n    };\n\n    return MapperReference;\n}(CachedReference);\n\n\n//////////\nvar ReferenceCache = function () {\n    function ReferenceCache(reference) {\n        classCallCheck(this, ReferenceCache);\n\n        this.lastValue = null;\n        this.lastRevision = null;\n        this.initialized = false;\n        this.tag = reference.tag;\n        this.reference = reference;\n    }\n\n    ReferenceCache.prototype.peek = function peek() {\n        if (!this.initialized) {\n            return this.initialize();\n        }\n        return this.lastValue;\n    };\n\n    ReferenceCache.prototype.revalidate = function revalidate() {\n        if (!this.initialized) {\n            return this.initialize();\n        }\n        var reference = this.reference,\n            lastRevision = this.lastRevision;\n\n        var tag = reference.tag;\n        if (tag.validate(lastRevision)) return NOT_MODIFIED;\n        this.lastRevision = tag.value();\n        var lastValue = this.lastValue;\n\n        var value = reference.value();\n        if (value === lastValue) return NOT_MODIFIED;\n        this.lastValue = value;\n        return value;\n    };\n\n    ReferenceCache.prototype.initialize = function initialize() {\n        var reference = this.reference;\n\n        var value = this.lastValue = reference.value();\n        this.lastRevision = reference.tag.value();\n        this.initialized = true;\n        return value;\n    };\n\n    return ReferenceCache;\n}();\nvar NOT_MODIFIED = \"adb3b78e-3d22-4e4b-877a-6317c2c5c145\";\nfunction isModified(value) {\n    return value !== NOT_MODIFIED;\n}\n\nvar ConstReference = function () {\n    function ConstReference(inner) {\n        classCallCheck(this, ConstReference);\n\n        this.inner = inner;\n        this.tag = CONSTANT_TAG;\n    }\n\n    ConstReference.prototype.value = function value() {\n        return this.inner;\n    };\n\n    return ConstReference;\n}();\n\nvar ListItem = function (_ListNode) {\n    inherits(ListItem, _ListNode);\n\n    function ListItem(iterable, result) {\n        classCallCheck(this, ListItem);\n\n        var _this = possibleConstructorReturn(this, _ListNode.call(this, iterable.valueReferenceFor(result)));\n\n        _this.retained = false;\n        _this.seen = false;\n        _this.key = result.key;\n        _this.iterable = iterable;\n        _this.memo = iterable.memoReferenceFor(result);\n        return _this;\n    }\n\n    ListItem.prototype.update = function update(item) {\n        this.retained = true;\n        this.iterable.updateValueReference(this.value, item);\n        this.iterable.updateMemoReference(this.memo, item);\n    };\n\n    ListItem.prototype.shouldRemove = function shouldRemove() {\n        return !this.retained;\n    };\n\n    ListItem.prototype.reset = function reset() {\n        this.retained = false;\n        this.seen = false;\n    };\n\n    return ListItem;\n}(ListNode);\nvar IterationArtifacts = function () {\n    function IterationArtifacts(iterable) {\n        classCallCheck(this, IterationArtifacts);\n\n        this.iterator = null;\n        this.map = dict();\n        this.list = new LinkedList();\n        this.tag = iterable.tag;\n        this.iterable = iterable;\n    }\n\n    IterationArtifacts.prototype.isEmpty = function isEmpty() {\n        var iterator = this.iterator = this.iterable.iterate();\n        return iterator.isEmpty();\n    };\n\n    IterationArtifacts.prototype.iterate = function iterate() {\n        var iterator = void 0;\n        if (this.iterator === null) {\n            iterator = this.iterable.iterate();\n        } else {\n            iterator = this.iterator;\n        }\n        this.iterator = null;\n        return iterator;\n    };\n\n    IterationArtifacts.prototype.has = function has(key) {\n        return !!this.map[key];\n    };\n\n    IterationArtifacts.prototype.get = function get$$1(key) {\n        return this.map[key];\n    };\n\n    IterationArtifacts.prototype.wasSeen = function wasSeen(key) {\n        var node = this.map[key];\n        return node !== undefined && node.seen;\n    };\n\n    IterationArtifacts.prototype.append = function append(item) {\n        var map = this.map,\n            list = this.list,\n            iterable = this.iterable;\n\n        var node = map[item.key] = new ListItem(iterable, item);\n        list.append(node);\n        return node;\n    };\n\n    IterationArtifacts.prototype.insertBefore = function insertBefore(item, reference) {\n        var map = this.map,\n            list = this.list,\n            iterable = this.iterable;\n\n        var node = map[item.key] = new ListItem(iterable, item);\n        node.retained = true;\n        list.insertBefore(node, reference);\n        return node;\n    };\n\n    IterationArtifacts.prototype.move = function move(item, reference) {\n        var list = this.list;\n\n        item.retained = true;\n        list.remove(item);\n        list.insertBefore(item, reference);\n    };\n\n    IterationArtifacts.prototype.remove = function remove(item) {\n        var list = this.list;\n\n        list.remove(item);\n        delete this.map[item.key];\n    };\n\n    IterationArtifacts.prototype.nextNode = function nextNode(item) {\n        return this.list.nextNode(item);\n    };\n\n    IterationArtifacts.prototype.head = function head() {\n        return this.list.head();\n    };\n\n    return IterationArtifacts;\n}();\nvar ReferenceIterator = function () {\n    // if anyone needs to construct this object with something other than\n    // an iterable, let @wycats know.\n    function ReferenceIterator(iterable) {\n        classCallCheck(this, ReferenceIterator);\n\n        this.iterator = null;\n        var artifacts = new IterationArtifacts(iterable);\n        this.artifacts = artifacts;\n    }\n\n    ReferenceIterator.prototype.next = function next() {\n        var artifacts = this.artifacts;\n\n        var iterator = this.iterator = this.iterator || artifacts.iterate();\n        var item = iterator.next();\n        if (item === null) return null;\n        return artifacts.append(item);\n    };\n\n    return ReferenceIterator;\n}();\nvar Phase;\n(function (Phase) {\n    Phase[Phase[\"Append\"] = 0] = \"Append\";\n    Phase[Phase[\"Prune\"] = 1] = \"Prune\";\n    Phase[Phase[\"Done\"] = 2] = \"Done\";\n})(Phase || (Phase = {}));\nvar IteratorSynchronizer = function () {\n    function IteratorSynchronizer(_ref) {\n        var target = _ref.target,\n            artifacts = _ref.artifacts;\n        classCallCheck(this, IteratorSynchronizer);\n\n        this.target = target;\n        this.artifacts = artifacts;\n        this.iterator = artifacts.iterate();\n        this.current = artifacts.head();\n    }\n\n    IteratorSynchronizer.prototype.sync = function sync() {\n        var phase = Phase.Append;\n        while (true) {\n            switch (phase) {\n                case Phase.Append:\n                    phase = this.nextAppend();\n                    break;\n                case Phase.Prune:\n                    phase = this.nextPrune();\n                    break;\n                case Phase.Done:\n                    this.nextDone();\n                    return;\n            }\n        }\n    };\n\n    IteratorSynchronizer.prototype.advanceToKey = function advanceToKey(key) {\n        var current = this.current,\n            artifacts = this.artifacts;\n\n        var seek = current;\n        while (seek !== null && seek.key !== key) {\n            seek.seen = true;\n            seek = artifacts.nextNode(seek);\n        }\n        if (seek !== null) {\n            this.current = artifacts.nextNode(seek);\n        }\n    };\n\n    IteratorSynchronizer.prototype.nextAppend = function nextAppend() {\n        var iterator = this.iterator,\n            current = this.current,\n            artifacts = this.artifacts;\n\n        var item = iterator.next();\n        if (item === null) {\n            return this.startPrune();\n        }\n        var key = item.key;\n\n        if (current !== null && current.key === key) {\n            this.nextRetain(item);\n        } else if (artifacts.has(key)) {\n            this.nextMove(item);\n        } else {\n            this.nextInsert(item);\n        }\n        return Phase.Append;\n    };\n\n    IteratorSynchronizer.prototype.nextRetain = function nextRetain(item) {\n        var artifacts = this.artifacts,\n            current = this.current;\n\n        current = current;\n        current.update(item);\n        this.current = artifacts.nextNode(current);\n        this.target.retain(item.key, current.value, current.memo);\n    };\n\n    IteratorSynchronizer.prototype.nextMove = function nextMove(item) {\n        var current = this.current,\n            artifacts = this.artifacts,\n            target = this.target;\n        var key = item.key;\n\n        var found = artifacts.get(item.key);\n        found.update(item);\n        if (artifacts.wasSeen(item.key)) {\n            artifacts.move(found, current);\n            target.move(found.key, found.value, found.memo, current ? current.key : null);\n        } else {\n            this.advanceToKey(key);\n        }\n    };\n\n    IteratorSynchronizer.prototype.nextInsert = function nextInsert(item) {\n        var artifacts = this.artifacts,\n            target = this.target,\n            current = this.current;\n\n        var node = artifacts.insertBefore(item, current);\n        target.insert(node.key, node.value, node.memo, current ? current.key : null);\n    };\n\n    IteratorSynchronizer.prototype.startPrune = function startPrune() {\n        this.current = this.artifacts.head();\n        return Phase.Prune;\n    };\n\n    IteratorSynchronizer.prototype.nextPrune = function nextPrune() {\n        var artifacts = this.artifacts,\n            target = this.target,\n            current = this.current;\n\n        if (current === null) {\n            return Phase.Done;\n        }\n        var node = current;\n        this.current = artifacts.nextNode(node);\n        if (node.shouldRemove()) {\n            artifacts.remove(node);\n            target.delete(node.key);\n        } else {\n            node.reset();\n        }\n        return Phase.Prune;\n    };\n\n    IteratorSynchronizer.prototype.nextDone = function nextDone() {\n        this.target.done();\n    };\n\n    return IteratorSynchronizer;\n}();\n\nfunction tracked() {\n    for (var _len = arguments.length, dependencies = Array(_len), _key = 0; _key < _len; _key++) {\n        dependencies[_key] = arguments[_key];\n    }\n\n    var target = dependencies[0],\n        key = dependencies[1],\n        descriptor = dependencies[2];\n\n    if (typeof target === \"string\") {\n        return function (target, key, descriptor) {\n            return descriptorForTrackedComputedProperty(target, key, descriptor, dependencies);\n        };\n    } else {\n        if (descriptor) {\n            return descriptorForTrackedComputedProperty(target, key, descriptor, []);\n        } else {\n            installTrackedProperty(target, key);\n        }\n    }\n}\nfunction descriptorForTrackedComputedProperty(target, key, descriptor, dependencies) {\n    var meta = metaFor(target);\n    meta.trackedProperties[key] = true;\n    meta.trackedPropertyDependencies[key] = dependencies || [];\n    return {\n        enumerable: true,\n        configurable: false,\n        get: descriptor.get,\n        set: function set$$1() {\n            metaFor(this).dirtyableTagFor(key).inner.dirty();\n            descriptor.set.apply(this, arguments);\n            propertyDidChange();\n        }\n    };\n}\n/**\n  Installs a getter/setter for change tracking. The accessor\n  acts just like a normal property, but it triggers the `propertyDidChange`\n  hook when written to.\n\n  Values are saved on the object using a \"shadow key,\" or a symbol based on the\n  tracked property name. Sets write the value to the shadow key, and gets read\n  from it.\n */\nfunction installTrackedProperty(target, key) {\n    var value = void 0;\n    var shadowKey = Symbol(key);\n    var meta = metaFor(target);\n    meta.trackedProperties[key] = true;\n    if (target[key] !== undefined) {\n        value = target[key];\n    }\n    Object.defineProperty(target, key, {\n        configurable: true,\n        get: function get$$1() {\n            return this[shadowKey];\n        },\n        set: function set$$1(newValue) {\n            metaFor(this).dirtyableTagFor(key).inner.dirty();\n            this[shadowKey] = newValue;\n            propertyDidChange();\n        }\n    });\n}\n/**\n * Stores bookkeeping information about tracked properties on the target object\n * and includes helper methods for manipulating and retrieving that data.\n *\n * Computed properties (i.e., tracked getters/setters) deserve some explanation.\n * A computed property is invalidated when either it is set, or one of its\n * dependencies is invalidated. Therefore, we store two tags for each computed\n * property:\n *\n * 1. The dirtyable tag that we invalidate when the setter is invoked.\n * 2. A union tag (tag combinator) of the dirtyable tag and all of the computed\n *    property's dependencies' tags, used by Glimmer to determine \"does this\n *    computed property need to be recomputed?\"\n */\n\nvar Meta = function () {\n    function Meta(parent) {\n        classCallCheck(this, Meta);\n\n        this.tags = dict();\n        this.computedPropertyTags = dict();\n        this.trackedProperties = parent ? Object.create(parent.trackedProperties) : dict();\n        this.trackedPropertyDependencies = parent ? Object.create(parent.trackedPropertyDependencies) : dict();\n    }\n    /**\n     * The tag representing whether the given property should be recomputed. Used\n     * by e.g. Glimmer VM to detect when a property should be re-rendered. Think\n     * of this as the \"public-facing\" tag.\n     *\n     * For static tracked properties, this is a single DirtyableTag. For computed\n     * properties, it is a combinator of the property's DirtyableTag as well as\n     * all of its dependencies' tags.\n     */\n\n\n    Meta.prototype.tagFor = function tagFor(key) {\n        var tag = this.tags[key];\n        if (tag) {\n            return tag;\n        }\n        var dependencies = void 0;\n        if (dependencies = this.trackedPropertyDependencies[key]) {\n            return this.tags[key] = combinatorForComputedProperties(this, key, dependencies);\n        }\n        return this.tags[key] = DirtyableTag.create();\n    };\n    /**\n     * The tag used internally to invalidate when a tracked property is set. For\n     * static properties, this is the same DirtyableTag returned from `tagFor`.\n     * For computed properties, it is the DirtyableTag used as one of the tags in\n     * the tag combinator of the CP and its dependencies.\n    */\n\n\n    Meta.prototype.dirtyableTagFor = function dirtyableTagFor(key) {\n        var dependencies = this.trackedPropertyDependencies[key];\n        var tag = void 0;\n        if (dependencies) {\n            // The key is for a computed property.\n            tag = this.computedPropertyTags[key];\n            if (tag) {\n                return tag;\n            }\n            return this.computedPropertyTags[key] = DirtyableTag.create();\n        } else {\n            // The key is for a static property.\n            tag = this.tags[key];\n            if (tag) {\n                return tag;\n            }\n            return this.tags[key] = DirtyableTag.create();\n        }\n    };\n\n    return Meta;\n}();\n\nfunction combinatorForComputedProperties(meta, key, dependencies) {\n    // Start off with the tag for the CP's own dirty state.\n    var tags = [meta.dirtyableTagFor(key)];\n    // Next, add in all of the tags for its dependencies.\n    if (dependencies && dependencies.length) {\n        for (var i = 0; i < dependencies.length; i++) {\n            tags.push(meta.tagFor(dependencies[i]));\n        }\n    }\n    // Return a combinator across the CP's tags and its dependencies' tags.\n    return combine(tags);\n}\nvar META = Symbol(\"ember-object\");\nfunction metaFor(obj) {\n    var meta = obj[META];\n    if (meta && hasOwnProperty(obj, META)) {\n        return meta;\n    }\n    return obj[META] = new Meta(meta);\n}\nvar hOP = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return hOP.call(obj, key);\n}\nvar propertyDidChange = function propertyDidChange() {};\nfunction setPropertyDidChange(cb) {\n    propertyDidChange = cb;\n}\nfunction hasTag(obj, key) {\n    var meta = obj[META];\n    if (!obj[META]) {\n        return false;\n    }\n    if (!meta.trackedProperties[key]) {\n        return false;\n    }\n    return true;\n}\nvar UntrackedPropertyError = function (_Error) {\n    inherits(UntrackedPropertyError, _Error);\n\n    function UntrackedPropertyError(target, key, message) {\n        classCallCheck(this, UntrackedPropertyError);\n\n        var _this = possibleConstructorReturn(this, _Error.call(this, message));\n\n        _this.target = target;\n        _this.key = key;\n        return _this;\n    }\n\n    UntrackedPropertyError.for = function _for(obj, key) {\n        return new UntrackedPropertyError(obj, key, \"The property '\" + key + \"' on \" + obj + \" was changed after being rendered. If you want to change a property used in a template after the component has rendered, mark the property as a tracked property with the @tracked decorator.\");\n    };\n\n    return UntrackedPropertyError;\n}(Error);\nfunction defaultErrorThrower(obj, key) {\n    throw UntrackedPropertyError.for(obj, key);\n}\nfunction tagForProperty(obj, key) {\n    var throwError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultErrorThrower;\n\n    if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" && obj) {\n        if (true && !hasTag(obj, key)) {\n            installDevModeErrorInterceptor(obj, key, throwError);\n        }\n        var meta = metaFor(obj);\n        return meta.tagFor(key);\n    } else {\n        return CONSTANT_TAG;\n    }\n}\n/**\n * In development mode only, we install an ad hoc setter on properties where a\n * tag is requested (i.e., it was used in a template) without being tracked. In\n * cases where the property is set, we raise an error.\n */\nfunction installDevModeErrorInterceptor(obj, key, throwError) {\n    var target = obj;\n    var descriptor = void 0;\n    // Find the descriptor for the current property. We may need to walk the\n    // prototype chain to do so. If the property is undefined, we may never get a\n    // descriptor here.\n    var hasOwnDescriptor = true;\n    while (target) {\n        descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor) {\n            break;\n        }\n        hasOwnDescriptor = false;\n        target = Object.getPrototypeOf(target);\n    }\n    // If possible, define a property descriptor that passes through the current\n    // value on reads but throws an exception on writes.\n    if (descriptor) {\n        if (descriptor.configurable || !hasOwnDescriptor) {\n            Object.defineProperty(obj, key, {\n                configurable: descriptor.configurable,\n                enumerable: descriptor.enumerable,\n                get: function get$$1() {\n                    if (descriptor.get) {\n                        return descriptor.get.call(this);\n                    } else {\n                        return descriptor.value;\n                    }\n                },\n                set: function set$$1() {\n                    throwError(this, key);\n                }\n            });\n        }\n    } else {\n        Object.defineProperty(obj, key, {\n            set: function set$$1() {\n                throwError(this, key);\n            }\n        });\n    }\n}\n\n/**\n * The `Component` class defines an encapsulated UI element that is rendered to\n * the DOM. A component is made up of a template and, optionally, this component\n * object.\n *\n * ## Defining a Component\n *\n * To define a component, subclass `Component` and add your own properties,\n * methods and lifecycle hooks:\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n * }\n * ```\n *\n * ## Lifecycle Hooks\n *\n * Lifecycle hooks allow you to respond to changes to a component, such as when\n * it gets created, rendered, updated or destroyed. To add a lifecycle hook to a\n * component, implement the hook as a method on your component subclass.\n *\n * For example, to be notified when Glimmer has rendered your component so you\n * can attach a legacy jQuery plugin, implement the `didInsertElement()` method:\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n *   didInsertElement() {\n *     $(this.element).pickadate();\n *   }\n * }\n * ```\n *\n * ## Data for Templates\n *\n * `Component`s have two different kinds of data, or state, that can be\n * displayed in templates:\n *\n * 1. Arguments\n * 2. Properties\n *\n * Arguments are data that is passed in to a component from its parent\n * component. For example, if I have a `user-greeting` component, I can pass it\n * a name and greeting to use:\n *\n * ```hbs\n * <user-greeting @name=\"Ricardo\" @greeting=\"Olá\">\n * ```\n *\n * Inside my `user-greeting` template, I can access the `@name` and `@greeting`\n * arguments that I've been given:\n *\n * ```hbs\n * {{@greeting}}, {{@name}}!\n * ```\n *\n * Arguments are also available inside my component:\n *\n * ```ts\n * console.log(this.args.greeting); // prints \"Olá\"\n * ```\n *\n * Properties, on the other hand, are internal to the component and declared in\n * the class. You can use properties to store data that you want to show in the\n * template, or pass to another component as an argument.\n *\n * ```ts\n * import Component from '@glimmer/component';\n *\n * export default class extends Component {\n *   user = {\n *     name: 'Robbie'\n *   }\n * }\n * ```\n *\n * In the above example, we've defined a component with a `user` property that\n * contains an object with its own `name` property.\n *\n * We can render that property in our template:\n *\n * ```hbs\n * Hello, {{user.name}}!\n * ```\n *\n * We can also take that property and pass it as an argument to the\n * `user-greeting` component we defined above:\n *\n * ```hbs\n * <user-greeting @greeting=\"Hello\" @name={{user.name}} />\n * ```\n *\n * ## Arguments vs. Properties\n *\n * Remember, arguments are data that was given to your component by its parent\n * component, and properties are data your component has defined for itself.\n *\n * You can tell the difference between arguments and properties in templates\n * because arguments always start with an `@` sign (think \"A is for arguments\"):\n *\n * ```hbs\n * {{@firstName}}\n * ```\n *\n * We know that `@firstName` came from the parent component, not the current\n * component, because it starts with `@` and is therefore an argument.\n *\n * On the other hand, if we see:\n *\n * ```hbs\n * {{name}}\n * ```\n *\n * We know that `name` is a property on the component. If we want to know where\n * the data is coming from, we can go look at our component class to find out.\n *\n * Inside the component itself, arguments always show up inside the component's\n * `args` property. For example, if `{{@firstName}}` is `Tom` in the template,\n * inside the component `this.args.firstName` would also be `Tom`.\n */\n\nvar Component = function () {\n  /**\n   * Constructs a new component and assigns itself the passed properties. You\n   * should not construct new components yourself. Instead, Glimmer will\n   * instantiate new components automatically as it renders.\n   *\n   * @param options\n   */\n  function Component(options) {\n    classCallCheck(this, Component);\n\n    /**\n     * Development-mode only name of the component, useful for debugging.\n     */\n    this.debugName = null;\n    /** @private\n     * Slot on the component to save Arguments object passed to the `args` setter.\n     */\n    this.__args__ = null;\n    Object.assign(this, options);\n  }\n  /**\n   * The element corresponding to the main element of the component's template.\n   * The main element is the element in the template that has `...attributes` set on it:\n   *\n   * ```hbs\n   * <h1>Modal</h1>\n   * <div class=\"contents\" ...attributes>\n   *   {{yield}}\n   * </div>\n   * ```\n   *\n   * In this example, `this.element` would be the `div` with the class `contents`.\n   *\n   * You should not try to access this property until after the component's `didInsertElement()`\n   * lifecycle hook is called.\n   */\n\n\n  Component.create = function create(injections) {\n    return new this(injections);\n  };\n  /**\n   * Called when the component has been inserted into the DOM.\n   * Override this function to do any set up that requires an element in the document body.\n   */\n\n\n  Component.prototype.didInsertElement = function didInsertElement() {};\n  /**\n   * Called when the component has updated and rerendered itself.\n   * Called only during a rerender, not during an initial render.\n   */\n\n\n  Component.prototype.didUpdate = function didUpdate() {};\n  /**\n   * Called before the component has been removed from the DOM.\n   */\n\n\n  Component.prototype.willDestroy = function willDestroy() {};\n\n  Component.prototype.destroy = function destroy() {\n    this.willDestroy();\n  };\n\n  Component.prototype.toString = function toString() {\n    return this.debugName + \" component\";\n  };\n\n  createClass(Component, [{\n    key: \"element\",\n    get: function get$$1() {\n      var bounds = this.bounds;\n\n      debugAssert(bounds && bounds.firstNode === bounds.lastNode, \"The 'element' property can only be accessed on components that contain a single root element in their template. Try using 'bounds' instead to access the first and last nodes.\");\n      return bounds.firstNode;\n    }\n    /**\n     * Named arguments passed to the component from its parent component.\n     * They can be accessed in JavaScript via `this.args.argumentName` and in the template via `@argumentName`.\n     *\n     * Say you have the following component, which will have two `args`, `firstName` and `lastName`:\n     *\n     * ```hbs\n     * <my-component @firstName=\"Arthur\" @lastName=\"Dent\" />\n     * ```\n     *\n     * If you needed to calculate `fullName` by combining both of them, you would do:\n     *\n     * ```ts\n     * didInsertElement() {\n     *   console.log(`Hi, my full name is ${this.args.firstName} ${this.args.lastName}`);\n     * }\n     * ```\n     *\n     * While in the template you could do:\n     *\n     * ```hbs\n     * <p>Welcome, {{@firstName}} {{@lastName}}!</p>\n     * ```\n     *\n     */\n\n  }, {\n    key: \"args\",\n    get: function get$$1() {\n      return this.__args__;\n    },\n    set: function set$$1(args) {\n      this.__args__ = args;\n      metaFor(this).dirtyableTagFor(\"args\").inner.dirty();\n    }\n  }]);\n  return Component;\n}();\n\nvar capabilities = {\n    dynamicLayout: false,\n    dynamicTag: true,\n    prepareArgs: false,\n    createArgs: true,\n    attributeHook: true,\n    elementHook: true\n};\n\nvar ComponentDefinition = function () {\n    function ComponentDefinition(name, manager, ComponentClass, layout) {\n        classCallCheck(this, ComponentDefinition);\n\n        this.name = name;\n        this.manager = manager;\n        this.ComponentClass = ComponentClass;\n        this.layout = layout;\n        this.state = {\n            name: name,\n            capabilities: capabilities,\n            ComponentClass: ComponentClass,\n            layout: layout\n        };\n    }\n\n    ComponentDefinition.prototype.toJSON = function toJSON() {\n        return { GlimmerDebug: \"<component-definition name=\\\"\" + this.name + \"\\\">\" };\n    };\n\n    return ComponentDefinition;\n}();\n\nvar Container = function () {\n    function Container(registry) {\n        var resolver = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        classCallCheck(this, Container);\n\n        this._registry = registry;\n        this._resolver = resolver;\n        this._lookups = {};\n        this._factoryDefinitionLookups = {};\n    }\n\n    Container.prototype.factoryFor = function factoryFor(specifier) {\n        var factoryDefinition = this._factoryDefinitionLookups[specifier];\n        if (!factoryDefinition) {\n            if (this._resolver) {\n                factoryDefinition = this._resolver.retrieve(specifier);\n            }\n            if (!factoryDefinition) {\n                factoryDefinition = this._registry.registration(specifier);\n            }\n            if (factoryDefinition) {\n                this._factoryDefinitionLookups[specifier] = factoryDefinition;\n            }\n        }\n        if (!factoryDefinition) {\n            return;\n        }\n        return this.buildFactory(specifier, factoryDefinition);\n    };\n\n    Container.prototype.lookup = function lookup(specifier) {\n        var singleton = this._registry.registeredOption(specifier, 'singleton') !== false;\n        if (singleton && this._lookups[specifier]) {\n            return this._lookups[specifier];\n        }\n        var factory = this.factoryFor(specifier);\n        if (!factory) {\n            return;\n        }\n        if (this._registry.registeredOption(specifier, 'instantiate') === false) {\n            return factory.class;\n        }\n        var object = factory.create();\n        if (singleton && object) {\n            this._lookups[specifier] = object;\n        }\n        return object;\n    };\n\n    Container.prototype.defaultInjections = function defaultInjections(specifier) {\n        return {};\n    };\n\n    Container.prototype.buildInjections = function buildInjections(specifier) {\n        var hash = this.defaultInjections(specifier);\n        var injections = this._registry.registeredInjections(specifier);\n        var injection = void 0;\n        for (var i = 0; i < injections.length; i++) {\n            injection = injections[i];\n            hash[injection.property] = this.lookup(injection.source);\n        }\n        return hash;\n    };\n\n    Container.prototype.buildFactory = function buildFactory(specifier, factoryDefinition) {\n        var injections = this.buildInjections(specifier);\n        return {\n            class: factoryDefinition,\n            create: function create(options) {\n                var mergedOptions = Object.assign({}, injections, options);\n                return factoryDefinition.create(mergedOptions);\n            }\n        };\n    };\n\n    return Container;\n}();\n\nvar Registry = function () {\n    function Registry(options) {\n        classCallCheck(this, Registry);\n\n        this._registrations = {};\n        this._registeredOptions = {};\n        this._registeredInjections = {};\n        if (options && options.fallback) {\n            this._fallback = options.fallback;\n        }\n    }\n\n    Registry.prototype.register = function register(specifier, factoryDefinition, options) {\n        this._registrations[specifier] = factoryDefinition;\n        if (options) {\n            this._registeredOptions[specifier] = options;\n        }\n    };\n\n    Registry.prototype.registration = function registration(specifier) {\n        var registration = this._registrations[specifier];\n        if (registration === undefined && this._fallback) {\n            registration = this._fallback.registration(specifier);\n        }\n        return registration;\n    };\n\n    Registry.prototype.unregister = function unregister(specifier) {\n        delete this._registrations[specifier];\n        delete this._registeredOptions[specifier];\n        delete this._registeredInjections[specifier];\n    };\n\n    Registry.prototype.registerOption = function registerOption(specifier, option, value) {\n        var options = this._registeredOptions[specifier];\n        if (!options) {\n            options = {};\n            this._registeredOptions[specifier] = options;\n        }\n        options[option] = value;\n    };\n\n    Registry.prototype.registeredOption = function registeredOption(specifier, option) {\n        var result = void 0;\n        var options = this.registeredOptions(specifier);\n        if (options) {\n            result = options[option];\n        }\n        if (result === undefined && this._fallback !== undefined) {\n            result = this._fallback.registeredOption(specifier, option);\n        }\n        return result;\n    };\n\n    Registry.prototype.registeredOptions = function registeredOptions(specifier) {\n        var options = this._registeredOptions[specifier];\n        if (options === undefined) {\n            var _specifier$split = specifier.split(':'),\n                type = _specifier$split[0];\n\n            options = this._registeredOptions[type];\n        }\n        return options;\n    };\n\n    Registry.prototype.unregisterOption = function unregisterOption(specifier, option) {\n        var options = this._registeredOptions[specifier];\n        if (options) {\n            delete options[option];\n        }\n    };\n\n    Registry.prototype.registerInjection = function registerInjection(specifier, property, source) {\n        var injections = this._registeredInjections[specifier];\n        if (injections === undefined) {\n            this._registeredInjections[specifier] = injections = [];\n        }\n        injections.push({\n            property: property,\n            source: source\n        });\n    };\n\n    Registry.prototype.registeredInjections = function registeredInjections(specifier) {\n        var _specifier$split2 = specifier.split(':'),\n            type = _specifier$split2[0];\n\n        var injections = this._fallback ? this._fallback.registeredInjections(specifier) : [];\n        Array.prototype.push.apply(injections, this._registeredInjections[type]);\n        Array.prototype.push.apply(injections, this._registeredInjections[specifier]);\n        return injections;\n    };\n\n    return Registry;\n}();\n\n// TODO - use symbol\nvar OWNER = '__owner__';\nfunction getOwner(object) {\n    return object[OWNER];\n}\nfunction setOwner(object, owner) {\n    object[OWNER] = owner;\n}\n\n/**\n * Contains the first and last DOM nodes in a component's rendered\n * template. These nodes can be used to traverse the section of DOM\n * that belongs to a particular component.\n *\n * Note that these nodes *can* change over the lifetime of a component\n * if the beginning or ending of the template is dynamic.\n */\nvar Bounds = function () {\n    function Bounds(_bounds) {\n        classCallCheck(this, Bounds);\n\n        this._bounds = _bounds;\n    }\n\n    createClass(Bounds, [{\n        key: \"firstNode\",\n        get: function get$$1() {\n            return this._bounds.firstNode();\n        }\n    }, {\n        key: \"lastNode\",\n        get: function get$$1() {\n            return this._bounds.lastNode();\n        }\n    }]);\n    return Bounds;\n}();\n\nvar AppendOpcodes = function () {\n    function AppendOpcodes() {\n        classCallCheck(this, AppendOpcodes);\n\n        this.evaluateOpcode = fillNulls(78 /* Size */).slice();\n    }\n\n    AppendOpcodes.prototype.add = function add(name, evaluate) {\n        this.evaluateOpcode[name] = evaluate;\n    };\n\n    AppendOpcodes.prototype.evaluate = function evaluate(vm, opcode, type) {\n        var func = this.evaluateOpcode[type];\n        var sp = void 0;\n        var expectedChange = void 0;\n        var state = void 0;\n        func(vm, opcode);\n        \n    };\n\n    return AppendOpcodes;\n}();\nvar APPEND_OPCODES = new AppendOpcodes();\nvar AbstractOpcode = function AbstractOpcode() {\n    classCallCheck(this, AbstractOpcode);\n\n    initializeGuid(this);\n};\nvar UpdatingOpcode = function (_AbstractOpcode) {\n    inherits(UpdatingOpcode, _AbstractOpcode);\n\n    function UpdatingOpcode() {\n        classCallCheck(this, UpdatingOpcode);\n\n        var _this = possibleConstructorReturn(this, _AbstractOpcode.apply(this, arguments));\n\n        _this.next = null;\n        _this.prev = null;\n        return _this;\n    }\n\n    return UpdatingOpcode;\n}(AbstractOpcode);\n\n/**\n * Registers\n *\n * For the most part, these follows MIPS naming conventions, however the\n * register numbers are different.\n */\nvar Register;\n(function (Register) {\n    // $0 or $pc (program counter): pointer into `program` for the next insturction; -1 means exit\n    Register[Register[\"pc\"] = 0] = \"pc\";\n    // $1 or $ra (return address): pointer into `program` for the return\n    Register[Register[\"ra\"] = 1] = \"ra\";\n    // $2 or $fp (frame pointer): pointer into the `evalStack` for the base of the stack\n    Register[Register[\"fp\"] = 2] = \"fp\";\n    // $3 or $sp (stack pointer): pointer into the `evalStack` for the top of the stack\n    Register[Register[\"sp\"] = 3] = \"sp\";\n    // $4-$5 or $s0-$s1 (saved): callee saved general-purpose registers\n    Register[Register[\"s0\"] = 4] = \"s0\";\n    Register[Register[\"s1\"] = 5] = \"s1\";\n    // $6-$7 or $t0-$t1 (temporaries): caller saved general-purpose registers\n    Register[Register[\"t0\"] = 6] = \"t0\";\n    Register[Register[\"t1\"] = 7] = \"t1\";\n    // $8 or $v0 (return value)\n    Register[Register[\"v0\"] = 8] = \"v0\";\n})(Register || (Register = {}));\n\nvar PrimitiveReference = function (_ConstReference) {\n    inherits(PrimitiveReference, _ConstReference);\n\n    function PrimitiveReference(value) {\n        classCallCheck(this, PrimitiveReference);\n        return possibleConstructorReturn(this, _ConstReference.call(this, value));\n    }\n\n    PrimitiveReference.create = function create(value) {\n        if (value === undefined) {\n            return UNDEFINED_REFERENCE;\n        } else if (value === null) {\n            return NULL_REFERENCE;\n        } else if (value === true) {\n            return TRUE_REFERENCE;\n        } else if (value === false) {\n            return FALSE_REFERENCE;\n        } else if (typeof value === 'number') {\n            return new ValueReference(value);\n        } else {\n            return new StringReference(value);\n        }\n    };\n\n    PrimitiveReference.prototype.get = function get$$1(_key) {\n        return UNDEFINED_REFERENCE;\n    };\n\n    return PrimitiveReference;\n}(ConstReference);\n\nvar StringReference = function (_PrimitiveReference) {\n    inherits(StringReference, _PrimitiveReference);\n\n    function StringReference() {\n        classCallCheck(this, StringReference);\n\n        var _this2 = possibleConstructorReturn(this, _PrimitiveReference.apply(this, arguments));\n\n        _this2.lengthReference = null;\n        return _this2;\n    }\n\n    StringReference.prototype.get = function get$$1(key) {\n        if (key === 'length') {\n            var lengthReference = this.lengthReference;\n\n            if (lengthReference === null) {\n                lengthReference = this.lengthReference = new ValueReference(this.inner.length);\n            }\n            return lengthReference;\n        } else {\n            return _PrimitiveReference.prototype.get.call(this, key);\n        }\n    };\n\n    return StringReference;\n}(PrimitiveReference);\n\nvar ValueReference = function (_PrimitiveReference2) {\n    inherits(ValueReference, _PrimitiveReference2);\n\n    function ValueReference(value) {\n        classCallCheck(this, ValueReference);\n        return possibleConstructorReturn(this, _PrimitiveReference2.call(this, value));\n    }\n\n    return ValueReference;\n}(PrimitiveReference);\n\nvar UNDEFINED_REFERENCE = new ValueReference(undefined);\nvar NULL_REFERENCE = new ValueReference(null);\nvar TRUE_REFERENCE = new ValueReference(true);\nvar FALSE_REFERENCE = new ValueReference(false);\nvar ConditionalReference$1 = function () {\n    function ConditionalReference(inner) {\n        classCallCheck(this, ConditionalReference);\n\n        this.inner = inner;\n        this.tag = inner.tag;\n    }\n\n    ConditionalReference.prototype.value = function value() {\n        return this.toBool(this.inner.value());\n    };\n\n    ConditionalReference.prototype.toBool = function toBool(value) {\n        return !!value;\n    };\n\n    return ConditionalReference;\n}();\n\nvar ConcatReference = function (_CachedReference) {\n    inherits(ConcatReference, _CachedReference);\n\n    function ConcatReference(parts) {\n        classCallCheck(this, ConcatReference);\n\n        var _this = possibleConstructorReturn(this, _CachedReference.call(this));\n\n        _this.parts = parts;\n        _this.tag = combineTagged(parts);\n        return _this;\n    }\n\n    ConcatReference.prototype.compute = function compute() {\n        var parts = new Array();\n        for (var i = 0; i < this.parts.length; i++) {\n            var value = this.parts[i].value();\n            if (value !== null && value !== undefined) {\n                parts[i] = castToString(value);\n            }\n        }\n        if (parts.length > 0) {\n            return parts.join('');\n        }\n        return null;\n    };\n\n    return ConcatReference;\n}(CachedReference);\nfunction castToString(value) {\n    if (typeof value.toString !== 'function') {\n        return '';\n    }\n    return String(value);\n}\n\nfunction stackAssert(name, top) {\n    return \"Expected top of stack to be \" + name + \", was \" + String(top);\n}\n\nAPPEND_OPCODES.add(1 /* Helper */, function (vm, _ref) {\n    var handle = _ref.op1;\n\n    var stack = vm.stack;\n    var helper = vm.constants.resolveHandle(handle);\n    var args = stack.pop();\n    var value = helper(vm, args);\n    vm.loadValue(Register.v0, value);\n});\nAPPEND_OPCODES.add(4 /* GetVariable */, function (vm, _ref2) {\n    var symbol = _ref2.op1;\n\n    var expr = vm.referenceForSymbol(symbol);\n    vm.stack.push(expr);\n});\nAPPEND_OPCODES.add(2 /* SetVariable */, function (vm, _ref3) {\n    var symbol = _ref3.op1;\n\n    var expr = vm.stack.pop();\n    vm.scope().bindSymbol(symbol, expr);\n});\nAPPEND_OPCODES.add(3 /* SetBlock */, function (vm, _ref4) {\n    var symbol = _ref4.op1;\n\n    var handle = vm.stack.pop();\n    var scope = vm.stack.pop(); // FIXME(mmun): shouldn't need to cast this\n    var table = vm.stack.pop();\n    var block = table ? [handle, scope, table] : null;\n    vm.scope().bindBlock(symbol, block);\n});\nAPPEND_OPCODES.add(76 /* ResolveMaybeLocal */, function (vm, _ref5) {\n    var _name = _ref5.op1;\n\n    var name = vm.constants.getString(_name);\n    var locals = vm.scope().getPartialMap();\n    var ref = locals[name];\n    if (ref === undefined) {\n        ref = vm.getSelf().get(name);\n    }\n    vm.stack.push(ref);\n});\nAPPEND_OPCODES.add(17 /* RootScope */, function (vm, _ref6) {\n    var symbols = _ref6.op1,\n        bindCallerScope = _ref6.op2;\n\n    vm.pushRootScope(symbols, !!bindCallerScope);\n});\nAPPEND_OPCODES.add(5 /* GetProperty */, function (vm, _ref7) {\n    var _key = _ref7.op1;\n\n    var key = vm.constants.getString(_key);\n    var expr = vm.stack.pop();\n    vm.stack.push(expr.get(key));\n});\nAPPEND_OPCODES.add(6 /* GetBlock */, function (vm, _ref8) {\n    var _block = _ref8.op1;\n    var stack = vm.stack;\n\n    var block = vm.scope().getBlock(_block);\n    if (block) {\n        stack.push(block[2]);\n        stack.push(block[1]);\n        stack.push(block[0]);\n    } else {\n        stack.push(null);\n        stack.push(null);\n        stack.push(null);\n    }\n});\nAPPEND_OPCODES.add(7 /* HasBlock */, function (vm, _ref9) {\n    var _block = _ref9.op1;\n\n    var hasBlock = !!vm.scope().getBlock(_block);\n    vm.stack.push(hasBlock ? TRUE_REFERENCE : FALSE_REFERENCE);\n});\nAPPEND_OPCODES.add(8 /* HasBlockParams */, function (vm) {\n    // FIXME(mmun): should only need to push the symbol table\n    var table = vm.stack.pop();\n    false && debugAssert(table === null || table && (typeof table === 'undefined' ? 'undefined' : _typeof(table)) === 'object' && Array.isArray(table.parameters), stackAssert('Option<BlockSymbolTable>', table));\n\n    var hasBlockParams = table && table.parameters.length;\n    vm.stack.push(hasBlockParams ? TRUE_REFERENCE : FALSE_REFERENCE);\n});\nAPPEND_OPCODES.add(9 /* Concat */, function (vm, _ref10) {\n    var count = _ref10.op1;\n\n    var out = new Array(count);\n    for (var i = count; i > 0; i--) {\n        var offset = i - 1;\n        out[offset] = vm.stack.pop();\n    }\n    vm.stack.push(new ConcatReference(out));\n});\n\nvar Opcodes;\n(function (Opcodes) {\n    // Statements\n    Opcodes[Opcodes[\"Text\"] = 0] = \"Text\";\n    Opcodes[Opcodes[\"Append\"] = 1] = \"Append\";\n    Opcodes[Opcodes[\"Comment\"] = 2] = \"Comment\";\n    Opcodes[Opcodes[\"Modifier\"] = 3] = \"Modifier\";\n    Opcodes[Opcodes[\"Block\"] = 4] = \"Block\";\n    Opcodes[Opcodes[\"Component\"] = 5] = \"Component\";\n    Opcodes[Opcodes[\"OpenElement\"] = 6] = \"OpenElement\";\n    Opcodes[Opcodes[\"OpenSplattedElement\"] = 7] = \"OpenSplattedElement\";\n    Opcodes[Opcodes[\"FlushElement\"] = 8] = \"FlushElement\";\n    Opcodes[Opcodes[\"CloseElement\"] = 9] = \"CloseElement\";\n    Opcodes[Opcodes[\"StaticAttr\"] = 10] = \"StaticAttr\";\n    Opcodes[Opcodes[\"DynamicAttr\"] = 11] = \"DynamicAttr\";\n    Opcodes[Opcodes[\"AttrSplat\"] = 12] = \"AttrSplat\";\n    Opcodes[Opcodes[\"Yield\"] = 13] = \"Yield\";\n    Opcodes[Opcodes[\"Partial\"] = 14] = \"Partial\";\n    Opcodes[Opcodes[\"DynamicArg\"] = 15] = \"DynamicArg\";\n    Opcodes[Opcodes[\"StaticArg\"] = 16] = \"StaticArg\";\n    Opcodes[Opcodes[\"TrustingAttr\"] = 17] = \"TrustingAttr\";\n    Opcodes[Opcodes[\"Debugger\"] = 18] = \"Debugger\";\n    Opcodes[Opcodes[\"ClientSideStatement\"] = 19] = \"ClientSideStatement\";\n    // Expressions\n    Opcodes[Opcodes[\"Unknown\"] = 20] = \"Unknown\";\n    Opcodes[Opcodes[\"Get\"] = 21] = \"Get\";\n    Opcodes[Opcodes[\"MaybeLocal\"] = 22] = \"MaybeLocal\";\n    Opcodes[Opcodes[\"HasBlock\"] = 23] = \"HasBlock\";\n    Opcodes[Opcodes[\"HasBlockParams\"] = 24] = \"HasBlockParams\";\n    Opcodes[Opcodes[\"Undefined\"] = 25] = \"Undefined\";\n    Opcodes[Opcodes[\"Helper\"] = 26] = \"Helper\";\n    Opcodes[Opcodes[\"Concat\"] = 27] = \"Concat\";\n    Opcodes[Opcodes[\"ClientSideExpression\"] = 28] = \"ClientSideExpression\";\n})(Opcodes || (Opcodes = {}));\n\nfunction is(variant) {\n    return function (value) {\n        return Array.isArray(value) && value[0] === variant;\n    };\n}\n// Statements\n\n\n\n\n// Expressions\nvar isGet = is(Opcodes.Get);\nvar isMaybeLocal = is(Opcodes.MaybeLocal);\n\nvar Ops$1;\n(function (Ops) {\n    Ops[Ops[\"OpenComponentElement\"] = 0] = \"OpenComponentElement\";\n    Ops[Ops[\"DidCreateElement\"] = 1] = \"DidCreateElement\";\n    Ops[Ops[\"SetComponentAttrs\"] = 2] = \"SetComponentAttrs\";\n    Ops[Ops[\"DidRenderLayout\"] = 3] = \"DidRenderLayout\";\n    Ops[Ops[\"Debugger\"] = 4] = \"Debugger\";\n})(Ops$1 || (Ops$1 = {}));\n\nvar Ops$$1 = Opcodes;\nvar ATTRS_BLOCK = '&attrs';\nvar Compilers = function () {\n    function Compilers() {\n        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        classCallCheck(this, Compilers);\n\n        this.offset = offset;\n        this.names = dict();\n        this.funcs = [];\n    }\n\n    Compilers.prototype.add = function add(name, func) {\n        this.funcs.push(func);\n        this.names[name] = this.funcs.length - 1;\n    };\n\n    Compilers.prototype.compile = function compile(sexp, builder) {\n        var name = sexp[this.offset];\n        var index = this.names[name];\n        var func = this.funcs[index];\n        false && debugAssert(!!func, 'expected an implementation for ' + (this.offset === 0 ? Ops$$1[sexp[0]] : Ops$1[sexp[1]]));\n\n        func(sexp, builder);\n    };\n\n    return Compilers;\n}();\nvar _statementCompiler = void 0;\nfunction statementCompiler() {\n    if (_statementCompiler) {\n        return _statementCompiler;\n    }\n    var STATEMENTS = _statementCompiler = new Compilers();\n    STATEMENTS.add(Ops$$1.Text, function (sexp, builder) {\n        builder.text(sexp[1]);\n    });\n    STATEMENTS.add(Ops$$1.Comment, function (sexp, builder) {\n        builder.comment(sexp[1]);\n    });\n    STATEMENTS.add(Ops$$1.CloseElement, function (_sexp, builder) {\n        builder.closeElement();\n    });\n    STATEMENTS.add(Ops$$1.FlushElement, function (_sexp, builder) {\n        builder.flushElement();\n    });\n    STATEMENTS.add(Ops$$1.Modifier, function (sexp, builder) {\n        var lookup = builder.lookup,\n            referrer = builder.referrer;\n        var name = sexp[1],\n            params = sexp[2],\n            hash = sexp[3];\n\n        var specifier = lookup.lookupModifier(name, referrer);\n        if (specifier) {\n            builder.modifier(specifier, params, hash);\n        } else {\n            throw new Error('Compile Error ' + name + ' is not a modifier: Helpers may not be used in the element form.');\n        }\n    });\n    STATEMENTS.add(Ops$$1.StaticAttr, function (sexp, builder) {\n        var name = sexp[1],\n            value = sexp[2],\n            namespace = sexp[3];\n\n        builder.staticAttr(name, namespace, value);\n    });\n    STATEMENTS.add(Ops$$1.DynamicAttr, function (sexp, builder) {\n        dynamicAttr(sexp, false, builder);\n    });\n    STATEMENTS.add(Ops$$1.TrustingAttr, function (sexp, builder) {\n        dynamicAttr(sexp, true, builder);\n    });\n    STATEMENTS.add(Ops$$1.OpenElement, function (sexp, builder) {\n        builder.openPrimitiveElement(sexp[1]);\n    });\n    STATEMENTS.add(Ops$$1.OpenSplattedElement, function (sexp, builder) {\n        builder.setComponentAttrs(true);\n        builder.putComponentOperations();\n        builder.openElementWithOperations(sexp[1]);\n    });\n    STATEMENTS.add(Ops$$1.Component, function (sexp, builder) {\n        var tag = sexp[1],\n            _attrs = sexp[2],\n            args = sexp[3],\n            block = sexp[4];\n        var lookup = builder.lookup,\n            referrer = builder.referrer;\n\n        var handle = lookup.lookupComponentSpec(tag, referrer);\n        if (handle !== null) {\n            var capabilities = lookup.getCapabilities(handle);\n            var attrs = [[Ops$$1.ClientSideStatement, Ops$1.SetComponentAttrs, true]].concat(_attrs, [[Ops$$1.ClientSideStatement, Ops$1.SetComponentAttrs, false]]);\n            var attrsBlock = builder.inlineBlock({ statements: attrs, parameters: EMPTY_ARRAY });\n            var child = builder.template(block);\n            if (capabilities.dynamicLayout === false) {\n                var layout = lookup.getLayout(handle);\n                builder.pushComponentDefinition(handle);\n                builder.invokeStaticComponent(capabilities, layout, attrsBlock, null, args, false, child && child);\n            } else {\n                builder.pushComponentDefinition(handle);\n                builder.invokeComponent(attrsBlock, null, args, false, child && child);\n            }\n        } else {\n            throw new Error('Compile Error: Cannot find component ' + tag);\n        }\n    });\n    STATEMENTS.add(Ops$$1.Partial, function (sexp, builder) {\n        var name = sexp[1],\n            evalInfo = sexp[2];\n        var referrer = builder.referrer;\n\n        builder.startLabels();\n        builder.pushFrame();\n        builder.returnTo('END');\n        builder.expr(name);\n        builder.dup();\n        builder.enter(2);\n        builder.jumpUnless('ELSE');\n        builder.invokePartial(referrer, builder.evalSymbols(), evalInfo);\n        builder.popScope();\n        builder.popFrame();\n        builder.label('ELSE');\n        builder.exit();\n        builder.return();\n        builder.label('END');\n        builder.popFrame();\n        builder.stopLabels();\n    });\n    STATEMENTS.add(Ops$$1.Yield, function (sexp, builder) {\n        var to = sexp[1],\n            params = sexp[2];\n\n        builder.yield(to, params);\n    });\n    STATEMENTS.add(Ops$$1.AttrSplat, function (sexp, builder) {\n        var to = sexp[1];\n\n        builder.yield(to, []);\n        builder.didCreateElement(Register.s0);\n        builder.setComponentAttrs(false);\n    });\n    STATEMENTS.add(Ops$$1.Debugger, function (sexp, builder) {\n        var evalInfo = sexp[1];\n\n        builder.debugger(builder.evalSymbols(), evalInfo);\n    });\n    STATEMENTS.add(Ops$$1.ClientSideStatement, function (sexp, builder) {\n        CLIENT_SIDE.compile(sexp, builder);\n    });\n    STATEMENTS.add(Ops$$1.Append, function (sexp, builder) {\n        var value = sexp[1],\n            trusting = sexp[2];\n        var inlines = builder.macros.inlines;\n\n        var returned = inlines.compile(sexp, builder) || value;\n        if (returned === true) return;\n        var isGet$$1 = isGet(value);\n        var isMaybeLocal$$1 = isMaybeLocal(value);\n        if (trusting) {\n            builder.guardedAppend(value, true);\n        } else {\n            if (isGet$$1 || isMaybeLocal$$1) {\n                builder.guardedAppend(value, false);\n            } else {\n                builder.expr(value);\n                builder.dynamicContent(false);\n            }\n        }\n    });\n    STATEMENTS.add(Ops$$1.Block, function (sexp, builder) {\n        var name = sexp[1],\n            params = sexp[2],\n            hash = sexp[3],\n            _template = sexp[4],\n            _inverse = sexp[5];\n\n        var template = builder.template(_template);\n        var inverse = builder.template(_inverse);\n        var templateBlock = template && template;\n        var inverseBlock = inverse && inverse;\n        var blocks = builder.macros.blocks;\n\n        blocks.compile(name, params, hash, templateBlock, inverseBlock, builder);\n    });\n    var CLIENT_SIDE = new Compilers(1);\n    CLIENT_SIDE.add(Ops$1.OpenComponentElement, function (sexp, builder) {\n        builder.putComponentOperations();\n        builder.openElementWithOperations(sexp[2]);\n    });\n    CLIENT_SIDE.add(Ops$1.DidCreateElement, function (_sexp, builder) {\n        builder.didCreateElement(Register.s0);\n    });\n    CLIENT_SIDE.add(Ops$1.SetComponentAttrs, function (sexp, builder) {\n        builder.setComponentAttrs(sexp[2]);\n    });\n    CLIENT_SIDE.add(Ops$1.Debugger, function () {\n        // tslint:disable-next-line:no-debugger\n        debugger;\n    });\n    CLIENT_SIDE.add(Ops$1.DidRenderLayout, function (_sexp, builder) {\n        builder.didRenderLayout(Register.s0);\n    });\n    return STATEMENTS;\n}\nfunction dynamicAttr(sexp, trusting, builder) {\n    var name = sexp[1],\n        value = sexp[2],\n        namespace = sexp[3];\n\n    builder.expr(value);\n    if (namespace) {\n        builder.dynamicAttr(name, namespace, trusting);\n    } else {\n        builder.dynamicAttr(name, null, trusting);\n    }\n}\nvar _expressionCompiler = void 0;\nfunction expressionCompiler() {\n    if (_expressionCompiler) {\n        return _expressionCompiler;\n    }\n    var EXPRESSIONS = _expressionCompiler = new Compilers();\n    EXPRESSIONS.add(Ops$$1.Unknown, function (sexp, builder) {\n        var lookup = builder.lookup,\n            asPartial = builder.asPartial,\n            referrer = builder.referrer;\n\n        var name = sexp[1];\n        var specifier = lookup.lookupHelper(name, referrer);\n        if (specifier !== null) {\n            builder.helper(specifier, null, null);\n        } else if (asPartial) {\n            builder.resolveMaybeLocal(name);\n        } else {\n            builder.getVariable(0);\n            builder.getProperty(name);\n        }\n    });\n    EXPRESSIONS.add(Ops$$1.Concat, function (sexp, builder) {\n        var parts = sexp[1];\n        for (var i = 0; i < parts.length; i++) {\n            builder.expr(parts[i]);\n        }\n        builder.concat(parts.length);\n    });\n    EXPRESSIONS.add(Ops$$1.Helper, function (sexp, builder) {\n        var lookup = builder.lookup,\n            referrer = builder.referrer;\n        var name = sexp[1],\n            params = sexp[2],\n            hash = sexp[3];\n        // TODO: triage this in the WF compiler\n\n        if (name === 'component') {\n            false && debugAssert(params.length, 'SYNTAX ERROR: component helper requires at least one argument');\n\n            var definition = params[0],\n                restArgs = params.slice(1);\n\n            builder.curryComponent(definition, restArgs, hash, true);\n            return;\n        }\n        var specifier = lookup.lookupHelper(name, referrer);\n        if (specifier !== null) {\n            builder.helper(specifier, params, hash);\n        } else {\n            throw new Error('Compile Error: ' + name + ' is not a helper');\n        }\n    });\n    EXPRESSIONS.add(Ops$$1.Get, function (sexp, builder) {\n        var head = sexp[1],\n            path = sexp[2];\n\n        builder.getVariable(head);\n        for (var i = 0; i < path.length; i++) {\n            builder.getProperty(path[i]);\n        }\n    });\n    EXPRESSIONS.add(Ops$$1.MaybeLocal, function (sexp, builder) {\n        var path = sexp[1];\n\n        if (builder.asPartial) {\n            var head = path[0];\n            path = path.slice(1);\n            builder.resolveMaybeLocal(head);\n        } else {\n            builder.getVariable(0);\n        }\n        for (var i = 0; i < path.length; i++) {\n            builder.getProperty(path[i]);\n        }\n    });\n    EXPRESSIONS.add(Ops$$1.Undefined, function (_sexp, builder) {\n        return builder.pushPrimitiveReference(undefined);\n    });\n    EXPRESSIONS.add(Ops$$1.HasBlock, function (sexp, builder) {\n        builder.hasBlock(sexp[1]);\n    });\n    EXPRESSIONS.add(Ops$$1.HasBlockParams, function (sexp, builder) {\n        builder.hasBlockParams(sexp[1]);\n    });\n    return EXPRESSIONS;\n}\nvar Macros = function Macros() {\n    classCallCheck(this, Macros);\n\n    var _populateBuiltins = populateBuiltins(),\n        blocks = _populateBuiltins.blocks,\n        inlines = _populateBuiltins.inlines;\n\n    this.blocks = blocks;\n    this.inlines = inlines;\n};\nvar Blocks = function () {\n    function Blocks() {\n        classCallCheck(this, Blocks);\n\n        this.names = dict();\n        this.funcs = [];\n    }\n\n    Blocks.prototype.add = function add(name, func) {\n        this.funcs.push(func);\n        this.names[name] = this.funcs.length - 1;\n    };\n\n    Blocks.prototype.addMissing = function addMissing(func) {\n        this.missing = func;\n    };\n\n    Blocks.prototype.compile = function compile(name, params, hash, template, inverse, builder) {\n        var index = this.names[name];\n        if (index === undefined) {\n            false && debugAssert(!!this.missing, name + ' not found, and no catch-all block handler was registered');\n\n            var func = this.missing;\n            var handled = func(name, params, hash, template, inverse, builder);\n            false && debugAssert(!!handled, name + ' not found, and the catch-all block handler didn\\'t handle it');\n        } else {\n            var _func = this.funcs[index];\n            _func(params, hash, template, inverse, builder);\n        }\n    };\n\n    return Blocks;\n}();\nvar Inlines = function () {\n    function Inlines() {\n        classCallCheck(this, Inlines);\n\n        this.names = dict();\n        this.funcs = [];\n    }\n\n    Inlines.prototype.add = function add(name, func) {\n        this.funcs.push(func);\n        this.names[name] = this.funcs.length - 1;\n    };\n\n    Inlines.prototype.addMissing = function addMissing(func) {\n        this.missing = func;\n    };\n\n    Inlines.prototype.compile = function compile(sexp, builder) {\n        var value = sexp[1];\n        // TODO: Fix this so that expression macros can return\n        // things like components, so that {{component foo}}\n        // is the same as {{(component foo)}}\n        if (!Array.isArray(value)) return ['expr', value];\n        var name = void 0;\n        var params = void 0;\n        var hash = void 0;\n        if (value[0] === Ops$$1.Helper) {\n            name = value[1];\n            params = value[2];\n            hash = value[3];\n        } else if (value[0] === Ops$$1.Unknown) {\n            name = value[1];\n            params = hash = null;\n        } else {\n            return ['expr', value];\n        }\n        var index = this.names[name];\n        if (index === undefined && this.missing) {\n            var func = this.missing;\n            var returned = func(name, params, hash, builder);\n            return returned === false ? ['expr', value] : returned;\n        } else if (index !== undefined) {\n            var _func2 = this.funcs[index];\n            var _returned = _func2(name, params, hash, builder);\n            return _returned === false ? ['expr', value] : _returned;\n        } else {\n            return ['expr', value];\n        }\n    };\n\n    return Inlines;\n}();\nfunction populateBuiltins() {\n    var blocks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Blocks();\n    var inlines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Inlines();\n\n    blocks.add('if', function (params, _hash, template, inverse, builder) {\n        //        PutArgs\n        //        Test(Environment)\n        //        Enter(BEGIN, END)\n        // BEGIN: Noop\n        //        JumpUnless(ELSE)\n        //        Evaluate(default)\n        //        Jump(END)\n        // ELSE:  Noop\n        //        Evalulate(inverse)\n        // END:   Noop\n        //        Exit\n        if (!params || params.length !== 1) {\n            throw new Error('SYNTAX ERROR: #if requires a single argument');\n        }\n        builder.startLabels();\n        builder.pushFrame();\n        builder.returnTo('END');\n        builder.expr(params[0]);\n        builder.toBoolean();\n        builder.enter(1);\n        builder.jumpUnless('ELSE');\n        builder.invokeStaticBlock(template);\n        if (inverse) {\n            builder.jump('EXIT');\n            builder.label('ELSE');\n            builder.invokeStaticBlock(inverse);\n            builder.label('EXIT');\n            builder.exit();\n            builder.return();\n        } else {\n            builder.label('ELSE');\n            builder.exit();\n            builder.return();\n        }\n        builder.label('END');\n        builder.popFrame();\n        builder.stopLabels();\n    });\n    blocks.add('unless', function (params, _hash, template, inverse, builder) {\n        //        PutArgs\n        //        Test(Environment)\n        //        Enter(BEGIN, END)\n        // BEGIN: Noop\n        //        JumpUnless(ELSE)\n        //        Evaluate(default)\n        //        Jump(END)\n        // ELSE:  Noop\n        //        Evalulate(inverse)\n        // END:   Noop\n        //        Exit\n        if (!params || params.length !== 1) {\n            throw new Error('SYNTAX ERROR: #unless requires a single argument');\n        }\n        builder.startLabels();\n        builder.pushFrame();\n        builder.returnTo('END');\n        builder.expr(params[0]);\n        builder.toBoolean();\n        builder.enter(1);\n        builder.jumpIf('ELSE');\n        builder.invokeStaticBlock(template);\n        if (inverse) {\n            builder.jump('EXIT');\n            builder.label('ELSE');\n            builder.invokeStaticBlock(inverse);\n            builder.label('EXIT');\n            builder.exit();\n            builder.return();\n        } else {\n            builder.label('ELSE');\n            builder.exit();\n            builder.return();\n        }\n        builder.label('END');\n        builder.popFrame();\n        builder.stopLabels();\n    });\n    blocks.add('with', function (params, _hash, template, inverse, builder) {\n        //        PutArgs\n        //        Test(Environment)\n        //        Enter(BEGIN, END)\n        // BEGIN: Noop\n        //        JumpUnless(ELSE)\n        //        Evaluate(default)\n        //        Jump(END)\n        // ELSE:  Noop\n        //        Evalulate(inverse)\n        // END:   Noop\n        //        Exit\n        if (!params || params.length !== 1) {\n            throw new Error('SYNTAX ERROR: #with requires a single argument');\n        }\n        builder.startLabels();\n        builder.pushFrame();\n        builder.returnTo('END');\n        builder.expr(params[0]);\n        builder.dup();\n        builder.toBoolean();\n        builder.enter(2);\n        builder.jumpUnless('ELSE');\n        builder.invokeStaticBlock(template, 1);\n        if (inverse) {\n            builder.jump('EXIT');\n            builder.label('ELSE');\n            builder.invokeStaticBlock(inverse);\n            builder.label('EXIT');\n            builder.exit();\n            builder.return();\n        } else {\n            builder.label('ELSE');\n            builder.exit();\n            builder.return();\n        }\n        builder.label('END');\n        builder.popFrame();\n        builder.stopLabels();\n    });\n    blocks.add('each', function (params, hash, template, inverse, builder) {\n        //         Enter(BEGIN, END)\n        // BEGIN:  Noop\n        //         PutArgs\n        //         PutIterable\n        //         JumpUnless(ELSE)\n        //         EnterList(BEGIN2, END2)\n        // ITER:   Noop\n        //         NextIter(BREAK)\n        // BEGIN2: Noop\n        //         PushChildScope\n        //         Evaluate(default)\n        //         PopScope\n        // END2:   Noop\n        //         Exit\n        //         Jump(ITER)\n        // BREAK:  Noop\n        //         ExitList\n        //         Jump(END)\n        // ELSE:   Noop\n        //         Evalulate(inverse)\n        // END:    Noop\n        //         Exit\n        builder.startLabels();\n        builder.pushFrame();\n        builder.returnTo('END');\n        if (hash && hash[0][0] === 'key') {\n            builder.expr(hash[1][0]);\n        } else {\n            builder.pushPrimitiveReference(null);\n        }\n        builder.expr(params[0]);\n        builder.enter(2);\n        builder.putIterator();\n        builder.jumpUnless('ELSE');\n        builder.pushFrame();\n        builder.returnTo('ITER');\n        builder.dup(Register.fp, 1);\n        builder.enterList('BODY');\n        builder.label('ITER');\n        builder.iterate('BREAK');\n        builder.label('BODY');\n        builder.invokeStaticBlock(template, 2);\n        builder.pop(2);\n        builder.exit();\n        builder.return();\n        builder.label('BREAK');\n        builder.exitList();\n        builder.popFrame();\n        if (inverse) {\n            builder.jump('EXIT');\n            builder.label('ELSE');\n            builder.invokeStaticBlock(inverse);\n            builder.label('EXIT');\n            builder.exit();\n            builder.return();\n        } else {\n            builder.label('ELSE');\n            builder.exit();\n            builder.return();\n        }\n        builder.label('END');\n        builder.popFrame();\n        builder.stopLabels();\n    });\n    blocks.add('in-element', function (params, hash, template, _inverse, builder) {\n        if (!params || params.length !== 1) {\n            throw new Error('SYNTAX ERROR: #in-element requires a single argument');\n        }\n        builder.startLabels();\n        builder.pushFrame();\n        builder.returnTo('END');\n        var keys = hash[0],\n            values = hash[1];\n\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (key === 'nextSibling' || key === 'guid') {\n                builder.expr(values[i]);\n            } else {\n                throw new Error('SYNTAX ERROR: #in-element does not take a `' + keys[0] + '` option');\n            }\n        }\n        builder.expr(params[0]);\n        builder.dup();\n        builder.enter(4);\n        builder.jumpUnless('ELSE');\n        builder.pushRemoteElement();\n        builder.invokeStaticBlock(template);\n        builder.popRemoteElement();\n        builder.label('ELSE');\n        builder.exit();\n        builder.return();\n        builder.label('END');\n        builder.popFrame();\n        builder.stopLabels();\n    });\n    blocks.add('-with-dynamic-vars', function (_params, hash, template, _inverse, builder) {\n        if (hash) {\n            var names = hash[0],\n                expressions = hash[1];\n\n            builder.compileParams(expressions);\n            builder.pushDynamicScope();\n            builder.bindDynamicScope(names);\n            builder.invokeStaticBlock(template);\n            builder.popDynamicScope();\n        } else {\n            builder.invokeStaticBlock(template);\n        }\n    });\n    blocks.add('component', function (_params, hash, template, inverse, builder) {\n        false && debugAssert(_params && _params.length, 'SYNTAX ERROR: #component requires at least one argument');\n\n        var definition = _params[0],\n            params = _params.slice(1);\n\n        builder.dynamicComponent(definition, params, hash, true, template, inverse);\n    });\n    inlines.add('component', function (_name, _params, hash, builder) {\n        false && debugAssert(_params && _params.length, 'SYNTAX ERROR: component helper requires at least one argument');\n\n        var definition = _params[0],\n            params = _params.slice(1);\n\n        builder.dynamicComponent(definition, params, hash, true, null, null);\n        return true;\n    });\n    return { blocks: blocks, inlines: inlines };\n}\n\nvar CompilableTemplate = function () {\n    function CompilableTemplate(statements, containingLayout, options, symbolTable) {\n        classCallCheck(this, CompilableTemplate);\n\n        this.statements = statements;\n        this.containingLayout = containingLayout;\n        this.options = options;\n        this.symbolTable = symbolTable;\n        this.compiled = null;\n        this.statementCompiler = statementCompiler();\n    }\n\n    CompilableTemplate.topLevel = function topLevel(block, options) {\n        return new CompilableTemplate(block.statements, { block: block, referrer: options.referrer }, options, { referrer: options.referrer, hasEval: block.hasEval, symbols: block.symbols });\n    };\n\n    CompilableTemplate.prototype.compile = function compile() {\n        var compiled = this.compiled;\n\n        if (compiled !== null) return compiled;\n        var options = this.options,\n            statements = this.statements,\n            containingLayout = this.containingLayout;\n        var referrer = containingLayout.referrer;\n        var program = options.program,\n            lookup = options.lookup,\n            macros = options.macros,\n            asPartial = options.asPartial,\n            Builder = options.Builder;\n\n        var builder = new Builder(program, lookup, referrer, macros, containingLayout, asPartial);\n        for (var i = 0; i < statements.length; i++) {\n            this.statementCompiler.compile(statements[i], builder);\n        }\n        var handle = builder.commit(program.heap);\n        return this.compiled = handle;\n    };\n\n    return CompilableTemplate;\n}();\n\nvar ComponentBuilder = function () {\n    function ComponentBuilder(builder) {\n        classCallCheck(this, ComponentBuilder);\n\n        this.builder = builder;\n    }\n\n    ComponentBuilder.prototype.static = function _static(handle, args) {\n        var params = args[0],\n            hash = args[1],\n            _default = args[2],\n            inverse = args[3];\n        var builder = this.builder;\n        var lookup = builder.lookup;\n\n        if (handle !== null) {\n            var capabilities = lookup.getCapabilities(handle);\n            if (capabilities.dynamicLayout === false) {\n                var layout = lookup.getLayout(handle);\n                builder.pushComponentDefinition(handle);\n                builder.invokeStaticComponent(capabilities, layout, null, params, hash, false, _default, inverse);\n            } else {\n                builder.pushComponentDefinition(handle);\n                builder.invokeComponent(null, params, hash, false, _default, inverse);\n            }\n        }\n    };\n\n    return ComponentBuilder;\n}();\n\nvar ARG_SHIFT = 8;\nvar MAX_SIZE = 65535;\nvar TYPE_SIZE = 255;\nvar TYPE_MASK = 255;\nvar OPERAND_LEN_MASK = 768;\nvar InstructionEncoder = function () {\n    function InstructionEncoder(buffer) {\n        classCallCheck(this, InstructionEncoder);\n\n        this.buffer = buffer;\n        this.typePos = 0;\n        this.size = 0;\n    }\n\n    InstructionEncoder.prototype.encode = function encode(type) {\n        var _this = this;\n\n        if (type > TYPE_SIZE) {\n            throw new Error('Opcode type over 8-bits. Got ' + type + '.');\n        }\n\n        for (var _len = arguments.length, operands = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            operands[_key - 1] = arguments[_key];\n        }\n\n        this.buffer.push(type | operands.length << ARG_SHIFT);\n        this.typePos = this.buffer.length - 1;\n        operands.forEach(function (op) {\n            if (op > MAX_SIZE) {\n                throw new Error('Operand over 16-bits. Got ' + op + '.');\n            }\n            _this.buffer.push(op);\n        });\n        this.size = this.buffer.length;\n    };\n\n    InstructionEncoder.prototype.compact = function compact(program) {\n        return String.fromCharCode.apply(String, program);\n    };\n\n    InstructionEncoder.prototype.patch = function patch(position, operand) {\n        if (this.buffer[position + 1] === -1) {\n            this.buffer[position + 1] = operand;\n        } else {\n            throw new Error('Trying to patch operand in populated slot instead of a reserved slot.');\n        }\n    };\n\n    return InstructionEncoder;\n}();\n\nvar Labels = function () {\n    function Labels() {\n        classCallCheck(this, Labels);\n\n        this.labels = dict();\n        this.targets = [];\n    }\n\n    Labels.prototype.label = function label(name, index) {\n        this.labels[name] = index;\n    };\n\n    Labels.prototype.target = function target(at, Target, _target) {\n        this.targets.push({ at: at, Target: Target, target: _target });\n    };\n\n    Labels.prototype.patch = function patch(encoder) {\n        var targets = this.targets,\n            labels = this.labels;\n\n        for (var i = 0; i < targets.length; i++) {\n            var _targets$i = targets[i],\n                at = _targets$i.at,\n                target = _targets$i.target;\n\n            var address = labels[target] - at;\n            encoder.patch(at, address);\n        }\n    };\n\n    return Labels;\n}();\n\nvar OpcodeBuilder = function () {\n    function OpcodeBuilder(program, lookup, referrer, macros, containingLayout, asPartial) {\n        classCallCheck(this, OpcodeBuilder);\n\n        this.program = program;\n        this.lookup = lookup;\n        this.referrer = referrer;\n        this.macros = macros;\n        this.containingLayout = containingLayout;\n        this.asPartial = asPartial;\n        this.encoder = new InstructionEncoder([]);\n        this.labelsStack = new Stack();\n        this.isComponentAttrs = false;\n        this.component = new ComponentBuilder(this);\n        this.constants = program.constants;\n        this.expressionCompiler = expressionCompiler();\n    }\n\n    OpcodeBuilder.prototype.expr = function expr(expression) {\n        if (Array.isArray(expression)) {\n            this.expressionCompiler.compile(expression, this);\n        } else {\n            this.pushPrimitiveReference(expression);\n        }\n    };\n\n    OpcodeBuilder.prototype.upvars = function upvars(count) {\n        return fillNulls(count);\n    };\n\n    OpcodeBuilder.prototype.reserve = function reserve(name) {\n        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n        var reservedOperands = [];\n        for (var i = 0; i < size; i++) {\n            reservedOperands[i] = -1;\n        }\n        this.push.apply(this, [name].concat(reservedOperands));\n    };\n\n    OpcodeBuilder.prototype.push = function push(name) {\n        var encoder = this.encoder;\n\n        for (var _len = arguments.length, ops = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            ops[_key - 1] = arguments[_key];\n        }\n\n        encoder.encode.apply(encoder, [name].concat(ops));\n    };\n\n    OpcodeBuilder.prototype.commit = function commit(heap) {\n        this.push(20 /* Return */);\n        var buffer = this.encoder.buffer;\n        // TODO: change the whole malloc API and do something more efficient\n\n        var handle = heap.malloc();\n        for (var i = 0; i < buffer.length; i++) {\n            heap.push(buffer[i]);\n        }\n        heap.finishMalloc(handle, this.containingLayout.block.symbols.length);\n        return handle;\n    };\n\n    OpcodeBuilder.prototype.setComponentAttrs = function setComponentAttrs(enabled) {\n        this.isComponentAttrs = enabled;\n    };\n    // args\n\n\n    OpcodeBuilder.prototype.pushArgs = function pushArgs(names, flags) {\n        var serialized = this.constants.stringArray(names);\n        this.push(61 /* PushArgs */, serialized, flags);\n    };\n    // helpers\n\n\n    OpcodeBuilder.prototype.startLabels = function startLabels() {\n        this.labelsStack.push(new Labels());\n    };\n\n    OpcodeBuilder.prototype.stopLabels = function stopLabels() {\n        var label = this.labelsStack.pop();\n        label.patch(this.encoder);\n    };\n    // components\n\n\n    OpcodeBuilder.prototype.pushComponentDefinition = function pushComponentDefinition(handle) {\n        this.push(59 /* PushComponentDefinition */, this.constants.handle(handle));\n    };\n\n    OpcodeBuilder.prototype.pushDynamicComponentManager = function pushDynamicComponentManager(referrer) {\n        this.push(60 /* PushDynamicComponentManager */, this.constants.serializable(referrer));\n    };\n\n    OpcodeBuilder.prototype.prepareArgs = function prepareArgs(state) {\n        this.push(63 /* PrepareArgs */, state);\n    };\n\n    OpcodeBuilder.prototype.createComponent = function createComponent(state, hasDefault, hasInverse) {\n        var flag = (hasDefault === true ? 1 : 0) | (hasInverse === true ? 1 : 0) << 1;\n        this.push(64 /* CreateComponent */, flag, state);\n    };\n\n    OpcodeBuilder.prototype.registerComponentDestructor = function registerComponentDestructor(state) {\n        this.push(65 /* RegisterComponentDestructor */, state);\n    };\n\n    OpcodeBuilder.prototype.beginComponentTransaction = function beginComponentTransaction() {\n        this.push(71 /* BeginComponentTransaction */);\n    };\n\n    OpcodeBuilder.prototype.commitComponentTransaction = function commitComponentTransaction() {\n        this.push(72 /* CommitComponentTransaction */);\n    };\n\n    OpcodeBuilder.prototype.putComponentOperations = function putComponentOperations() {\n        this.push(66 /* PutComponentOperations */);\n    };\n\n    OpcodeBuilder.prototype.getComponentSelf = function getComponentSelf(state) {\n        this.push(67 /* GetComponentSelf */, state);\n    };\n\n    OpcodeBuilder.prototype.getComponentTagName = function getComponentTagName(state) {\n        this.push(68 /* GetComponentTagName */, state);\n    };\n\n    OpcodeBuilder.prototype.getComponentLayout = function getComponentLayout(state) {\n        this.push(69 /* GetComponentLayout */, state);\n    };\n\n    OpcodeBuilder.prototype.invokeComponentLayout = function invokeComponentLayout() {\n        this.push(70 /* InvokeComponentLayout */);\n    };\n\n    OpcodeBuilder.prototype.didCreateElement = function didCreateElement(state) {\n        this.push(73 /* DidCreateElement */, state);\n    };\n\n    OpcodeBuilder.prototype.didRenderLayout = function didRenderLayout(state) {\n        this.push(74 /* DidRenderLayout */, state);\n    };\n    // partial\n\n\n    OpcodeBuilder.prototype.invokePartial = function invokePartial(referrer, symbols, evalInfo) {\n        var _meta = this.constants.serializable(referrer);\n        var _symbols = this.constants.stringArray(symbols);\n        var _evalInfo = this.constants.array(evalInfo);\n        this.push(75 /* InvokePartial */, _meta, _symbols, _evalInfo);\n    };\n\n    OpcodeBuilder.prototype.resolveMaybeLocal = function resolveMaybeLocal(name) {\n        this.push(76 /* ResolveMaybeLocal */, this.string(name));\n    };\n    // debugger\n\n\n    OpcodeBuilder.prototype.debugger = function _debugger(symbols, evalInfo) {\n        this.push(77 /* Debugger */, this.constants.stringArray(symbols), this.constants.array(evalInfo));\n    };\n    // content\n\n\n    OpcodeBuilder.prototype.dynamicContent = function dynamicContent(isTrusting) {\n        this.push(24 /* DynamicContent */, isTrusting ? 1 : 0);\n    };\n    // dom\n\n\n    OpcodeBuilder.prototype.text = function text(_text) {\n        this.push(22 /* Text */, this.constants.string(_text));\n    };\n\n    OpcodeBuilder.prototype.openPrimitiveElement = function openPrimitiveElement(tag) {\n        this.push(25 /* OpenElement */, this.constants.string(tag));\n    };\n\n    OpcodeBuilder.prototype.openElementWithOperations = function openElementWithOperations(tag) {\n        this.push(26 /* OpenElementWithOperations */, this.constants.string(tag));\n    };\n\n    OpcodeBuilder.prototype.openDynamicElement = function openDynamicElement() {\n        this.push(27 /* OpenDynamicElement */);\n    };\n\n    OpcodeBuilder.prototype.flushElement = function flushElement() {\n        this.push(31 /* FlushElement */);\n    };\n\n    OpcodeBuilder.prototype.closeElement = function closeElement() {\n        this.push(32 /* CloseElement */);\n    };\n\n    OpcodeBuilder.prototype.staticAttr = function staticAttr(_name, _namespace, _value) {\n        var name = this.constants.string(_name);\n        var namespace = _namespace ? this.constants.string(_namespace) : 0;\n        if (this.isComponentAttrs) {\n            this.pushPrimitiveReference(_value);\n            this.push(30 /* ComponentAttr */, name, 1, namespace);\n        } else {\n            var value = this.constants.string(_value);\n            this.push(28 /* StaticAttr */, name, value, namespace);\n        }\n    };\n\n    OpcodeBuilder.prototype.dynamicAttr = function dynamicAttr(_name, _namespace, trusting) {\n        var name = this.constants.string(_name);\n        var namespace = _namespace ? this.constants.string(_namespace) : 0;\n        if (this.isComponentAttrs) {\n            this.push(30 /* ComponentAttr */, name, trusting === true ? 1 : 0, namespace);\n        } else {\n            this.push(29 /* DynamicAttr */, name, trusting === true ? 1 : 0, namespace);\n        }\n    };\n\n    OpcodeBuilder.prototype.comment = function comment(_comment) {\n        var comment = this.constants.string(_comment);\n        this.push(23 /* Comment */, comment);\n    };\n\n    OpcodeBuilder.prototype.modifier = function modifier(specifier, params, hash) {\n        this.pushFrame();\n        this.compileArgs(params, hash, null, true);\n        this.push(33 /* Modifier */, this.constants.handle(specifier));\n        this.popFrame();\n    };\n    // lists\n\n\n    OpcodeBuilder.prototype.putIterator = function putIterator() {\n        this.push(55 /* PutIterator */);\n    };\n\n    OpcodeBuilder.prototype.enterList = function enterList(start) {\n        this.reserve(53 /* EnterList */);\n        this.labels.target(this.pos, 53 /* EnterList */, start);\n    };\n\n    OpcodeBuilder.prototype.exitList = function exitList() {\n        this.push(54 /* ExitList */);\n    };\n\n    OpcodeBuilder.prototype.iterate = function iterate(breaks) {\n        this.reserve(56 /* Iterate */);\n        this.labels.target(this.pos, 56 /* Iterate */, breaks);\n    };\n    // expressions\n\n\n    OpcodeBuilder.prototype.setVariable = function setVariable(symbol) {\n        this.push(2 /* SetVariable */, symbol);\n    };\n\n    OpcodeBuilder.prototype.setBlock = function setBlock(symbol) {\n        this.push(3 /* SetBlock */, symbol);\n    };\n\n    OpcodeBuilder.prototype.getVariable = function getVariable(symbol) {\n        this.push(4 /* GetVariable */, symbol);\n    };\n\n    OpcodeBuilder.prototype.getProperty = function getProperty(key) {\n        this.push(5 /* GetProperty */, this.string(key));\n    };\n\n    OpcodeBuilder.prototype.getBlock = function getBlock(symbol) {\n        this.push(6 /* GetBlock */, symbol);\n    };\n\n    OpcodeBuilder.prototype.hasBlock = function hasBlock(symbol) {\n        this.push(7 /* HasBlock */, symbol);\n    };\n\n    OpcodeBuilder.prototype.hasBlockParams = function hasBlockParams(to) {\n        this.getBlock(to);\n        this.resolveBlock();\n        this.push(8 /* HasBlockParams */);\n    };\n\n    OpcodeBuilder.prototype.concat = function concat(size) {\n        this.push(9 /* Concat */, size);\n    };\n\n    OpcodeBuilder.prototype.load = function load(register) {\n        this.push(15 /* Load */, register);\n    };\n\n    OpcodeBuilder.prototype.fetch = function fetch(register) {\n        this.push(16 /* Fetch */, register);\n    };\n\n    OpcodeBuilder.prototype.dup = function dup() {\n        var register = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Register.sp;\n        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n        return this.push(13 /* Dup */, register, offset);\n    };\n\n    OpcodeBuilder.prototype.pop = function pop() {\n        var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n        return this.push(14 /* Pop */, count);\n    };\n    // vm\n\n\n    OpcodeBuilder.prototype.pushRemoteElement = function pushRemoteElement() {\n        this.push(34 /* PushRemoteElement */);\n    };\n\n    OpcodeBuilder.prototype.popRemoteElement = function popRemoteElement() {\n        this.push(35 /* PopRemoteElement */);\n    };\n\n    OpcodeBuilder.prototype.label = function label(name) {\n        this.labels.label(name, this.nextPos);\n    };\n\n    OpcodeBuilder.prototype.pushRootScope = function pushRootScope(symbols, bindCallerScope) {\n        this.push(17 /* RootScope */, symbols, bindCallerScope ? 1 : 0);\n    };\n\n    OpcodeBuilder.prototype.pushChildScope = function pushChildScope() {\n        this.push(18 /* ChildScope */);\n    };\n\n    OpcodeBuilder.prototype.popScope = function popScope() {\n        this.push(19 /* PopScope */);\n    };\n\n    OpcodeBuilder.prototype.returnTo = function returnTo(label) {\n        this.reserve(21 /* ReturnTo */);\n        this.labels.target(this.pos, 21 /* ReturnTo */, label);\n    };\n\n    OpcodeBuilder.prototype.pushDynamicScope = function pushDynamicScope() {\n        this.push(37 /* PushDynamicScope */);\n    };\n\n    OpcodeBuilder.prototype.popDynamicScope = function popDynamicScope() {\n        this.push(38 /* PopDynamicScope */);\n    };\n\n    OpcodeBuilder.prototype.primitive = function primitive(_primitive) {\n        var type = 0;\n        var primitive = void 0;\n        switch (typeof _primitive === 'undefined' ? 'undefined' : _typeof(_primitive)) {\n            case 'number':\n                if (_primitive % 1 === 0) {\n                    if (_primitive > -1) {\n                        primitive = _primitive;\n                    } else {\n                        primitive = this.negative(_primitive);\n                        type = 4 /* NEGATIVE */;\n                    }\n                } else {\n                    primitive = this.float(_primitive);\n                    type = 1 /* FLOAT */;\n                }\n                break;\n            case 'string':\n                primitive = this.string(_primitive);\n                type = 2 /* STRING */;\n                break;\n            case 'boolean':\n                primitive = _primitive | 0;\n                type = 3 /* BOOLEAN_OR_VOID */;\n                break;\n            case 'object':\n                // assume null\n                primitive = 2;\n                type = 3 /* BOOLEAN_OR_VOID */;\n                break;\n            case 'undefined':\n                primitive = 3;\n                type = 3 /* BOOLEAN_OR_VOID */;\n                break;\n            default:\n                throw new Error('Invalid primitive passed to pushPrimitive');\n        }\n        this.push(11 /* Primitive */, primitive << 3 | type);\n    };\n\n    OpcodeBuilder.prototype.float = function float(num) {\n        return this.constants.float(num);\n    };\n\n    OpcodeBuilder.prototype.negative = function negative(num) {\n        return this.constants.negative(num);\n    };\n\n    OpcodeBuilder.prototype.pushPrimitiveReference = function pushPrimitiveReference(primitive) {\n        this.primitive(primitive);\n        this.primitiveReference();\n    };\n\n    OpcodeBuilder.prototype.primitiveReference = function primitiveReference() {\n        this.push(12 /* PrimitiveReference */);\n    };\n\n    OpcodeBuilder.prototype.helper = function helper(_helper, params, hash) {\n        this.pushFrame();\n        this.compileArgs(params, hash, null, true);\n        this.push(1 /* Helper */, this.constants.handle(_helper));\n        this.popFrame();\n        this.fetch(Register.v0);\n    };\n\n    OpcodeBuilder.prototype.bindDynamicScope = function bindDynamicScope(_names) {\n        this.push(36 /* BindDynamicScope */, this.names(_names));\n    };\n\n    OpcodeBuilder.prototype.enter = function enter(args) {\n        this.push(50 /* Enter */, args);\n    };\n\n    OpcodeBuilder.prototype.exit = function exit() {\n        this.push(51 /* Exit */);\n    };\n\n    OpcodeBuilder.prototype.return = function _return() {\n        this.push(20 /* Return */);\n    };\n\n    OpcodeBuilder.prototype.pushFrame = function pushFrame() {\n        this.push(48 /* PushFrame */);\n    };\n\n    OpcodeBuilder.prototype.popFrame = function popFrame() {\n        this.push(49 /* PopFrame */);\n    };\n\n    OpcodeBuilder.prototype.invokeVirtual = function invokeVirtual() {\n        this.push(42 /* InvokeVirtual */);\n    };\n\n    OpcodeBuilder.prototype.invokeYield = function invokeYield() {\n        this.push(44 /* InvokeYield */);\n    };\n\n    OpcodeBuilder.prototype.toBoolean = function toBoolean() {\n        this.push(52 /* ToBoolean */);\n    };\n\n    OpcodeBuilder.prototype.jump = function jump(target) {\n        this.reserve(45 /* Jump */);\n        this.labels.target(this.pos, 45 /* Jump */, target);\n    };\n\n    OpcodeBuilder.prototype.jumpIf = function jumpIf(target) {\n        this.reserve(46 /* JumpIf */);\n        this.labels.target(this.pos, 46 /* JumpIf */, target);\n    };\n\n    OpcodeBuilder.prototype.jumpUnless = function jumpUnless(target) {\n        this.reserve(47 /* JumpUnless */);\n        this.labels.target(this.pos, 47 /* JumpUnless */, target);\n    };\n    // internal helpers\n\n\n    OpcodeBuilder.prototype.string = function string(_string) {\n        return this.constants.string(_string);\n    };\n\n    OpcodeBuilder.prototype.names = function names(_names) {\n        var names = [];\n        for (var i = 0; i < _names.length; i++) {\n            var n = _names[i];\n            names[i] = this.constants.string(n);\n        }\n        return this.constants.array(names);\n    };\n\n    OpcodeBuilder.prototype.symbols = function symbols(_symbols2) {\n        return this.constants.array(_symbols2);\n    };\n    // convenience methods\n\n\n    OpcodeBuilder.prototype.inlineBlock = function inlineBlock(block) {\n        var parameters = block.parameters,\n            statements = block.statements;\n\n        var symbolTable = { parameters: parameters, referrer: this.containingLayout.referrer };\n        var options = {\n            program: this.program,\n            macros: this.macros,\n            Builder: this.constructor,\n            lookup: this.lookup,\n            asPartial: this.asPartial,\n            referrer: this.referrer\n        };\n        return new CompilableTemplate(statements, this.containingLayout, options, symbolTable);\n    };\n\n    OpcodeBuilder.prototype.evalSymbols = function evalSymbols() {\n        var block = this.containingLayout.block;\n\n        return block.hasEval ? block.symbols : null;\n    };\n\n    OpcodeBuilder.prototype.compileParams = function compileParams(params) {\n        if (!params) return 0;\n        for (var i = 0; i < params.length; i++) {\n            this.expr(params[i]);\n        }\n        return params.length;\n    };\n\n    OpcodeBuilder.prototype.compileArgs = function compileArgs(params, hash, blocks, synthetic) {\n        if (blocks) {\n            this.pushYieldableBlock(blocks.main);\n            this.pushYieldableBlock(blocks.else);\n            this.pushYieldableBlock(blocks.attrs);\n        }\n        var count = this.compileParams(params);\n        var flags = count << 4;\n        if (synthetic) flags |= 8;\n        if (blocks) {\n            flags |= 7;\n        }\n        var names = EMPTY_ARRAY;\n        if (hash) {\n            names = hash[0];\n            var val = hash[1];\n            for (var i = 0; i < val.length; i++) {\n                this.expr(val[i]);\n            }\n        }\n        this.pushArgs(names, flags);\n    };\n\n    OpcodeBuilder.prototype.invokeStaticBlock = function invokeStaticBlock(block) {\n        var callerCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var parameters = block.symbolTable.parameters;\n\n        var calleeCount = parameters.length;\n        var count = Math.min(callerCount, calleeCount);\n        this.pushFrame();\n        if (count) {\n            this.pushChildScope();\n            for (var i = 0; i < count; i++) {\n                this.dup(Register.fp, callerCount - i);\n                this.setVariable(parameters[i]);\n            }\n        }\n        this.pushBlock(block);\n        this.resolveBlock();\n        this.invokeVirtual();\n        if (count) {\n            this.popScope();\n        }\n        this.popFrame();\n    };\n\n    OpcodeBuilder.prototype.guardedAppend = function guardedAppend(expression, trusting) {\n        this.startLabels();\n        this.pushFrame();\n        this.returnTo('END');\n        this.expr(expression);\n        this.dup();\n        this.isComponent();\n        this.enter(2);\n        this.jumpUnless('ELSE');\n        this.pushDynamicComponentManager(this.referrer);\n        this.invokeComponent(null, null, null, false, null, null);\n        this.exit();\n        this.return();\n        this.label('ELSE');\n        this.dynamicContent(trusting);\n        this.exit();\n        this.return();\n        this.label('END');\n        this.popFrame();\n        this.stopLabels();\n    };\n\n    OpcodeBuilder.prototype.yield = function _yield(to, params) {\n        this.compileArgs(params, null, null, false);\n        this.getBlock(to);\n        this.resolveBlock();\n        this.invokeYield();\n        this.popScope();\n        this.popFrame();\n    };\n\n    OpcodeBuilder.prototype.invokeComponent = function invokeComponent(attrs, params, hash, synthetic, block) {\n        var inverse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n        var layout = arguments[6];\n\n        this.fetch(Register.s0);\n        this.dup(Register.sp, 1);\n        this.load(Register.s0);\n        this.pushFrame();\n        var blocks = { main: block, else: inverse, attrs: attrs };\n        this.compileArgs(params, hash, blocks, synthetic);\n        this.prepareArgs(Register.s0);\n        this.beginComponentTransaction();\n        this.pushDynamicScope();\n        this.createComponent(Register.s0, block !== null, inverse !== null);\n        this.registerComponentDestructor(Register.s0);\n        this.getComponentSelf(Register.s0);\n        if (layout) {\n            this.pushSymbolTable(layout.symbolTable);\n            this.pushLayout(layout);\n            this.resolveLayout();\n        } else {\n            this.getComponentLayout(Register.s0);\n        }\n        this.invokeComponentLayout();\n        this.didRenderLayout(Register.s0);\n        this.popFrame();\n        this.popScope();\n        this.popDynamicScope();\n        this.commitComponentTransaction();\n        this.load(Register.s0);\n    };\n\n    OpcodeBuilder.prototype.invokeStaticComponent = function invokeStaticComponent(capabilities, layout, attrs, params, hash, synthetic, block) {\n        var inverse = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n        var symbolTable = layout.symbolTable;\n\n        var bailOut = symbolTable.hasEval || capabilities.prepareArgs;\n        if (bailOut) {\n            this.invokeComponent(attrs, params, hash, synthetic, block, inverse, layout);\n            return;\n        }\n        this.fetch(Register.s0);\n        this.dup(Register.sp, 1);\n        this.load(Register.s0);\n        var symbols = symbolTable.symbols;\n\n        if (capabilities.createArgs) {\n            this.pushFrame();\n            this.compileArgs(null, hash, null, synthetic);\n        }\n        this.beginComponentTransaction();\n        this.pushDynamicScope();\n        this.createComponent(Register.s0, block !== null, inverse !== null);\n        if (capabilities.createArgs) {\n            this.popFrame();\n        }\n        this.registerComponentDestructor(Register.s0);\n        var bindings = [];\n        this.getComponentSelf(Register.s0);\n        bindings.push({ symbol: 0, isBlock: false });\n        for (var i = 0; i < symbols.length; i++) {\n            var symbol = symbols[i];\n            switch (symbol.charAt(0)) {\n                case '&':\n                    var callerBlock = null;\n                    if (symbol === '&default') {\n                        callerBlock = block;\n                    } else if (symbol === '&inverse') {\n                        callerBlock = inverse;\n                    } else if (symbol === ATTRS_BLOCK) {\n                        callerBlock = attrs;\n                    } else {\n                        throw unreachable();\n                    }\n                    if (callerBlock) {\n                        this.pushYieldableBlock(callerBlock);\n                        bindings.push({ symbol: i + 1, isBlock: true });\n                    } else {\n                        this.pushYieldableBlock(null);\n                        bindings.push({ symbol: i + 1, isBlock: true });\n                    }\n                    break;\n                case '@':\n                    if (!hash) {\n                        break;\n                    }\n                    var keys = hash[0],\n                        values = hash[1];\n\n                    var lookupName = symbol;\n                    if (synthetic) {\n                        lookupName = symbol.slice(1);\n                    }\n                    var index = keys.indexOf(lookupName);\n                    if (index !== -1) {\n                        this.expr(values[index]);\n                        bindings.push({ symbol: i + 1, isBlock: false });\n                    }\n                    break;\n            }\n        }\n        this.pushRootScope(symbols.length + 1, !!(block || inverse || attrs));\n        for (var _i = bindings.length - 1; _i >= 0; _i--) {\n            var _bindings$_i = bindings[_i],\n                _symbol = _bindings$_i.symbol,\n                isBlock = _bindings$_i.isBlock;\n\n            if (isBlock) {\n                this.setBlock(_symbol);\n            } else {\n                this.setVariable(_symbol);\n            }\n        }\n        this.pushFrame();\n        this.invokeStatic(layout);\n        this.didRenderLayout(Register.s0);\n        this.popFrame();\n        this.popScope();\n        this.popDynamicScope();\n        this.commitComponentTransaction();\n        this.load(Register.s0);\n    };\n\n    OpcodeBuilder.prototype.dynamicComponent = function dynamicComponent(definition, /* TODO: attrs: Option<RawInlineBlock>, */params, hash, synthetic, block) {\n        var inverse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n\n        this.startLabels();\n        this.pushFrame();\n        this.returnTo('END');\n        this.expr(definition);\n        this.dup();\n        this.enter(2);\n        this.jumpUnless('ELSE');\n        this.pushDynamicComponentManager(this.referrer);\n        this.invokeComponent(null, params, hash, synthetic, block, inverse);\n        this.label('ELSE');\n        this.exit();\n        this.return();\n        this.label('END');\n        this.popFrame();\n        this.stopLabels();\n    };\n\n    OpcodeBuilder.prototype.isComponent = function isComponent() {\n        this.push(57 /* IsComponent */);\n    };\n\n    OpcodeBuilder.prototype.curryComponent = function curryComponent(definition, /* TODO: attrs: Option<RawInlineBlock>, */params, hash, synthetic) {\n        var referrer = this.referrer;\n        this.pushFrame();\n        this.compileArgs(params, hash, null, synthetic);\n        this.expr(definition);\n        this.push(58 /* CurryComponent */, this.constants.serializable(referrer));\n        this.popFrame();\n        this.fetch(Register.v0);\n    };\n\n    OpcodeBuilder.prototype.pushSymbolTable = function pushSymbolTable(table) {\n        if (table) {\n            var constant = this.constants.table(table);\n            this.push(41 /* PushSymbolTable */, constant);\n        } else {\n            this.primitive(null);\n        }\n    };\n\n    OpcodeBuilder.prototype.pushBlockScope = function pushBlockScope() {\n        this.push(40 /* PushBlockScope */);\n    };\n\n    OpcodeBuilder.prototype.pushYieldableBlock = function pushYieldableBlock(block) {\n        this.pushSymbolTable(block && block.symbolTable);\n        this.pushBlockScope();\n        this.pushBlock(block);\n    };\n\n    OpcodeBuilder.prototype.template = function template(block) {\n        if (!block) return null;\n        return this.inlineBlock(block);\n    };\n\n    createClass(OpcodeBuilder, [{\n        key: 'pos',\n        get: function get$$1() {\n            return this.encoder.typePos;\n        }\n    }, {\n        key: 'nextPos',\n        get: function get$$1() {\n            return this.encoder.size;\n        }\n    }, {\n        key: 'labels',\n        get: function get$$1() {\n            return this.labelsStack.current;\n        }\n    }]);\n    return OpcodeBuilder;\n}();\n\nvar LazyOpcodeBuilder = function (_OpcodeBuilder) {\n    inherits(LazyOpcodeBuilder, _OpcodeBuilder);\n\n    function LazyOpcodeBuilder() {\n        classCallCheck(this, LazyOpcodeBuilder);\n        return possibleConstructorReturn(this, _OpcodeBuilder.apply(this, arguments));\n    }\n\n    LazyOpcodeBuilder.prototype.pushBlock = function pushBlock(block) {\n        if (block) {\n            this.pushOther(block);\n        } else {\n            this.primitive(null);\n        }\n    };\n\n    LazyOpcodeBuilder.prototype.resolveBlock = function resolveBlock() {\n        this.push(39 /* CompileBlock */);\n    };\n\n    LazyOpcodeBuilder.prototype.pushLayout = function pushLayout(layout) {\n        if (layout) {\n            this.pushOther(layout);\n        } else {\n            this.primitive(null);\n        }\n    };\n\n    LazyOpcodeBuilder.prototype.resolveLayout = function resolveLayout() {\n        this.push(39 /* CompileBlock */);\n    };\n\n    LazyOpcodeBuilder.prototype.invokeStatic = function invokeStatic(compilable) {\n        this.pushOther(compilable);\n        this.push(39 /* CompileBlock */);\n        this.push(42 /* InvokeVirtual */);\n    };\n\n    LazyOpcodeBuilder.prototype.pushOther = function pushOther(value) {\n        this.push(10 /* Constant */, this.other(value));\n    };\n\n    LazyOpcodeBuilder.prototype.other = function other(value) {\n        return this.constants.other(value);\n    };\n\n    return LazyOpcodeBuilder;\n}(OpcodeBuilder);\nvar EagerOpcodeBuilder = function (_OpcodeBuilder2) {\n    inherits(EagerOpcodeBuilder, _OpcodeBuilder2);\n\n    function EagerOpcodeBuilder() {\n        classCallCheck(this, EagerOpcodeBuilder);\n        return possibleConstructorReturn(this, _OpcodeBuilder2.apply(this, arguments));\n    }\n\n    EagerOpcodeBuilder.prototype.pushBlock = function pushBlock(block) {\n        var handle = block ? block.compile() : null;\n        this.primitive(handle);\n    };\n\n    EagerOpcodeBuilder.prototype.resolveBlock = function resolveBlock() {\n        return;\n    };\n\n    EagerOpcodeBuilder.prototype.pushLayout = function pushLayout(layout) {\n        if (layout) {\n            this.primitive(layout.compile());\n        } else {\n            this.primitive(null);\n        }\n    };\n\n    EagerOpcodeBuilder.prototype.resolveLayout = function resolveLayout() {};\n\n    EagerOpcodeBuilder.prototype.invokeStatic = function invokeStatic(compilable) {\n        var handle = compilable.compile();\n        this.push(43 /* InvokeStatic */, handle);\n    };\n\n    return EagerOpcodeBuilder;\n}(OpcodeBuilder);\n\nvar Arguments = function () {\n    function Arguments() {\n        classCallCheck(this, Arguments);\n\n        this.stack = null;\n        this.positional = new PositionalArguments();\n        this.named = new NamedArguments();\n        this.blocks = new BlockArguments();\n    }\n\n    Arguments.prototype.setup = function setup(stack, names, blockNames, positionalCount, synthetic) {\n        this.stack = stack;\n        /*\n               | ... | blocks      | positional  | named |\n               | ... | b0    b1    | p0 p1 p2 p3 | n0 n1 |\n         index | ... | 4/5/6 7/8/9 | 10 11 12 13 | 14 15 |\n                       ^             ^             ^  ^\n                     bbase         pbase       nbase  sp\n        */\n        var named = this.named;\n        var namedCount = names.length;\n        var namedBase = stack.sp - namedCount + 1;\n        named.setup(stack, namedBase, namedCount, names, synthetic);\n        var positional = this.positional;\n        var positionalBase = namedBase - positionalCount;\n        positional.setup(stack, positionalBase, positionalCount);\n        var blocks = this.blocks;\n        var blocksCount = blockNames.length;\n        var blocksBase = positionalBase - blocksCount * 3;\n        blocks.setup(stack, blocksBase, blocksCount, blockNames);\n    };\n\n    Arguments.prototype.at = function at(pos) {\n        return this.positional.at(pos);\n    };\n\n    Arguments.prototype.realloc = function realloc(offset) {\n        if (offset > 0) {\n            var positional = this.positional,\n                named = this.named,\n                stack = this.stack;\n\n            var newBase = positional.base + offset;\n            var length = positional.length + named.length;\n            for (var i = length - 1; i >= 0; i--) {\n                stack.set(stack.get(i, positional.base), i, newBase);\n            }\n            positional.base += offset;\n            named.base += offset;\n            stack.sp += offset;\n        }\n    };\n\n    Arguments.prototype.capture = function capture() {\n        var positional = this.positional.length === 0 ? EMPTY_POSITIONAL : this.positional.capture();\n        var named = this.named.length === 0 ? EMPTY_NAMED : this.named.capture();\n        return {\n            tag: this.tag,\n            length: this.length,\n            positional: positional,\n            named: named\n        };\n    };\n\n    Arguments.prototype.clear = function clear() {\n        var stack = this.stack,\n            length = this.length;\n\n        stack.pop(length);\n    };\n\n    createClass(Arguments, [{\n        key: 'tag',\n        get: function get$$1() {\n            return combineTagged([this.positional, this.named]);\n        }\n    }, {\n        key: 'base',\n        get: function get$$1() {\n            return this.blocks.base;\n        }\n    }, {\n        key: 'length',\n        get: function get$$1() {\n            return this.positional.length + this.named.length + this.blocks.length * 3;\n        }\n    }]);\n    return Arguments;\n}();\nvar PositionalArguments = function () {\n    function PositionalArguments() {\n        classCallCheck(this, PositionalArguments);\n\n        this.base = 0;\n        this.length = 0;\n        this.stack = null;\n        this._tag = null;\n        this._references = null;\n    }\n\n    PositionalArguments.prototype.setup = function setup(stack, base, length) {\n        this.stack = stack;\n        this.base = base;\n        this.length = length;\n        if (length === 0) {\n            this._tag = CONSTANT_TAG;\n            this._references = EMPTY_ARRAY;\n        } else {\n            this._tag = null;\n            this._references = null;\n        }\n    };\n\n    PositionalArguments.prototype.at = function at(position) {\n        var base = this.base,\n            length = this.length,\n            stack = this.stack;\n\n        if (position < 0 || position >= length) {\n            return UNDEFINED_REFERENCE;\n        }\n        return stack.get(position, base);\n    };\n\n    PositionalArguments.prototype.capture = function capture() {\n        return new CapturedPositionalArguments(this.tag, this.references);\n    };\n\n    PositionalArguments.prototype.prepend = function prepend(other) {\n        var additions = other.length;\n        if (additions > 0) {\n            var base = this.base,\n                length = this.length,\n                stack = this.stack;\n\n            this.base = base = base - additions;\n            this.length = length + additions;\n            for (var i = 0; i < additions; i++) {\n                stack.set(other.at(i), i, base);\n            }\n            this._tag = null;\n            this._references = null;\n        }\n    };\n\n    createClass(PositionalArguments, [{\n        key: 'tag',\n        get: function get$$1() {\n            var tag = this._tag;\n            if (!tag) {\n                tag = this._tag = combineTagged(this.references);\n            }\n            return tag;\n        }\n    }, {\n        key: 'references',\n        get: function get$$1() {\n            var references = this._references;\n            if (!references) {\n                var stack = this.stack,\n                    base = this.base,\n                    length = this.length;\n\n                references = this._references = stack.slice(base, base + length);\n            }\n            return references;\n        }\n    }]);\n    return PositionalArguments;\n}();\n\nvar CapturedPositionalArguments = function () {\n    function CapturedPositionalArguments(tag, references) {\n        var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : references.length;\n        classCallCheck(this, CapturedPositionalArguments);\n\n        this.tag = tag;\n        this.references = references;\n        this.length = length;\n    }\n\n    CapturedPositionalArguments.empty = function empty() {\n        return new CapturedPositionalArguments(CONSTANT_TAG, EMPTY_ARRAY, 0);\n    };\n\n    CapturedPositionalArguments.prototype.at = function at(position) {\n        return this.references[position];\n    };\n\n    CapturedPositionalArguments.prototype.value = function value() {\n        return this.references.map(this.valueOf);\n    };\n\n    CapturedPositionalArguments.prototype.get = function get$$1(name) {\n        var references = this.references,\n            length = this.length;\n\n        if (name === 'length') {\n            return PrimitiveReference.create(length);\n        } else {\n            var idx = parseInt(name, 10);\n            if (idx < 0 || idx >= length) {\n                return UNDEFINED_REFERENCE;\n            } else {\n                return references[idx];\n            }\n        }\n    };\n\n    CapturedPositionalArguments.prototype.valueOf = function valueOf(reference) {\n        return reference.value();\n    };\n\n    return CapturedPositionalArguments;\n}();\n\nvar NamedArguments = function () {\n    function NamedArguments() {\n        classCallCheck(this, NamedArguments);\n\n        this.base = 0;\n        this.length = 0;\n        this._tag = null;\n        this._references = null;\n        this._names = EMPTY_ARRAY;\n        this._atNames = EMPTY_ARRAY;\n    }\n\n    NamedArguments.prototype.setup = function setup(stack, base, length, names, synthetic) {\n        this.stack = stack;\n        this.base = base;\n        this.length = length;\n        if (length === 0) {\n            this._tag = CONSTANT_TAG;\n            this._references = EMPTY_ARRAY;\n            this._names = EMPTY_ARRAY;\n            this._atNames = EMPTY_ARRAY;\n        } else {\n            this._tag = null;\n            this._references = null;\n            if (synthetic) {\n                this._names = names;\n                this._atNames = null;\n            } else {\n                this._names = null;\n                this._atNames = names;\n            }\n        }\n    };\n\n    NamedArguments.prototype.has = function has(name) {\n        return this.names.indexOf(name) !== -1;\n    };\n\n    NamedArguments.prototype.get = function get$$1(name) {\n        var synthetic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var base = this.base,\n            stack = this.stack;\n\n        var names = synthetic ? this.names : this.atNames;\n        var idx = names.indexOf(name);\n        if (idx === -1) {\n            return UNDEFINED_REFERENCE;\n        }\n        return stack.get(idx, base);\n    };\n\n    NamedArguments.prototype.capture = function capture() {\n        return new CapturedNamedArguments(this.tag, this.names, this.references);\n    };\n\n    NamedArguments.prototype.merge = function merge(other) {\n        var extras = other.length;\n\n        if (extras > 0) {\n            var names = this.names,\n                length = this.length,\n                stack = this.stack;\n            var extraNames = other.names;\n\n            if (Object.isFrozen(names) && names.length === 0) {\n                names = [];\n            }\n            for (var i = 0; i < extras; i++) {\n                var name = extraNames[i];\n                var idx = names.indexOf(name);\n                if (idx === -1) {\n                    length = names.push(name);\n                    stack.push(other.references[i]);\n                }\n            }\n            this.length = length;\n            this._tag = null;\n            this._references = null;\n            this._names = names;\n            this._atNames = null;\n        }\n    };\n\n    NamedArguments.prototype.toSyntheticName = function toSyntheticName(name) {\n        return name.slice(1);\n    };\n\n    NamedArguments.prototype.toAtName = function toAtName(name) {\n        return '@' + name;\n    };\n\n    createClass(NamedArguments, [{\n        key: 'tag',\n        get: function get$$1() {\n            return combineTagged(this.references);\n        }\n    }, {\n        key: 'names',\n        get: function get$$1() {\n            var names = this._names;\n            if (!names) {\n                names = this._names = this._atNames.map(this.toSyntheticName);\n            }\n            return names;\n        }\n    }, {\n        key: 'atNames',\n        get: function get$$1() {\n            var atNames = this._atNames;\n            if (!atNames) {\n                atNames = this._atNames = this._names.map(this.toAtName);\n            }\n            return atNames;\n        }\n    }, {\n        key: 'references',\n        get: function get$$1() {\n            var references = this._references;\n            if (!references) {\n                var base = this.base,\n                    length = this.length,\n                    stack = this.stack;\n\n                references = this._references = stack.slice(base, base + length);\n            }\n            return references;\n        }\n    }]);\n    return NamedArguments;\n}();\n\nvar CapturedNamedArguments = function () {\n    function CapturedNamedArguments(tag, names, references) {\n        classCallCheck(this, CapturedNamedArguments);\n\n        this.tag = tag;\n        this.names = names;\n        this.references = references;\n        this.length = names.length;\n        this._map = null;\n    }\n\n    CapturedNamedArguments.prototype.has = function has(name) {\n        return this.names.indexOf(name) !== -1;\n    };\n\n    CapturedNamedArguments.prototype.get = function get$$1(name) {\n        var names = this.names,\n            references = this.references;\n\n        var idx = names.indexOf(name);\n        if (idx === -1) {\n            return UNDEFINED_REFERENCE;\n        } else {\n            return references[idx];\n        }\n    };\n\n    CapturedNamedArguments.prototype.value = function value() {\n        var names = this.names,\n            references = this.references;\n\n        var out = dict();\n        for (var i = 0; i < names.length; i++) {\n            var name = names[i];\n            out[name] = references[i].value();\n        }\n        return out;\n    };\n\n    createClass(CapturedNamedArguments, [{\n        key: 'map',\n        get: function get$$1() {\n            var map$$1 = this._map;\n            if (!map$$1) {\n                var names = this.names,\n                    references = this.references;\n\n                map$$1 = this._map = dict();\n                for (var i = 0; i < names.length; i++) {\n                    var name = names[i];\n                    map$$1[name] = references[i];\n                }\n            }\n            return map$$1;\n        }\n    }]);\n    return CapturedNamedArguments;\n}();\n\nvar BlockArguments = function () {\n    function BlockArguments() {\n        classCallCheck(this, BlockArguments);\n\n        this.internalValues = null;\n        this.internalTag = null;\n        this.names = EMPTY_ARRAY;\n        this.length = 0;\n        this.base = 0;\n    }\n\n    BlockArguments.prototype.setup = function setup(stack, base, length, names) {\n        this.stack = stack;\n        this.names = names;\n        this.base = base;\n        this.length = length;\n        if (length === 0) {\n            this.internalTag = CONSTANT_TAG;\n            this.internalValues = EMPTY_ARRAY;\n        } else {\n            this.internalTag = null;\n            this.internalValues = null;\n        }\n    };\n\n    BlockArguments.prototype.has = function has(name) {\n        return this.names.indexOf(name) !== -1;\n    };\n\n    BlockArguments.prototype.get = function get$$1(name) {\n        var base = this.base,\n            stack = this.stack,\n            names = this.names;\n\n        var idx = names.indexOf(name);\n        if (names.indexOf(name) === -1) {\n            return null;\n        }\n        var table = stack.get(idx * 3, base);\n        var scope = stack.get(idx * 3 + 1, base); // FIXME(mmun): shouldn't need to cast this\n        var handle = stack.get(idx * 3 + 2, base);\n        return handle === null ? null : [handle, scope, table];\n    };\n\n    BlockArguments.prototype.capture = function capture() {\n        return new CapturedBlockArguments(this.names, this.values);\n    };\n\n    createClass(BlockArguments, [{\n        key: 'values',\n        get: function get$$1() {\n            var values = this.internalValues;\n            if (!values) {\n                var base = this.base,\n                    length = this.length,\n                    stack = this.stack;\n\n                values = this.internalValues = stack.slice(base, base + length * 3);\n            }\n            return values;\n        }\n    }]);\n    return BlockArguments;\n}();\n\nvar CapturedBlockArguments = function () {\n    function CapturedBlockArguments(names, values) {\n        classCallCheck(this, CapturedBlockArguments);\n\n        this.names = names;\n        this.values = values;\n        this.length = names.length;\n    }\n\n    CapturedBlockArguments.prototype.has = function has(name) {\n        return this.names.indexOf(name) !== -1;\n    };\n\n    CapturedBlockArguments.prototype.get = function get$$1(name) {\n        var idx = this.names.indexOf(name);\n        if (idx === -1) return null;\n        return [this.values[idx * 3 + 2], this.values[idx * 3 + 1], this.values[idx * 3]];\n    };\n\n    return CapturedBlockArguments;\n}();\n\nvar EMPTY_NAMED = new CapturedNamedArguments(CONSTANT_TAG, EMPTY_ARRAY, EMPTY_ARRAY);\nvar EMPTY_POSITIONAL = new CapturedPositionalArguments(CONSTANT_TAG, EMPTY_ARRAY);\nvar EMPTY_ARGS = { tag: CONSTANT_TAG, length: 0, positional: EMPTY_POSITIONAL, named: EMPTY_NAMED };\n\nvar CURRIED_COMPONENT_DEFINITION_BRAND = 'CURRIED COMPONENT DEFINITION [id=6f00feb9-a0ef-4547-99ea-ac328f80acea]';\nfunction isCurriedComponentDefinition(definition) {\n    return !!(definition && definition[CURRIED_COMPONENT_DEFINITION_BRAND]);\n}\n\nvar CurriedComponentDefinition = function () {\n    /** @internal */\n    function CurriedComponentDefinition(inner, args) {\n        classCallCheck(this, CurriedComponentDefinition);\n\n        this.inner = inner;\n        this.args = args;\n        this[CURRIED_COMPONENT_DEFINITION_BRAND] = true;\n    }\n\n    CurriedComponentDefinition.prototype.unwrap = function unwrap(args) {\n        args.realloc(this.offset);\n        var definition = this;\n        while (true) {\n            var _definition = definition,\n                curriedArgs = _definition.args,\n                inner = _definition.inner;\n\n            if (curriedArgs) {\n                args.positional.prepend(curriedArgs.positional);\n                args.named.merge(curriedArgs.named);\n            }\n            if (!isCurriedComponentDefinition(inner)) {\n                return inner;\n            }\n            definition = inner;\n        }\n    };\n    /** @internal */\n\n\n    createClass(CurriedComponentDefinition, [{\n        key: 'offset',\n        get: function get$$1() {\n            var inner = this.inner,\n                args = this.args;\n\n            var length = args ? args.positional.length : 0;\n            return isCurriedComponentDefinition(inner) ? length + inner.offset : length;\n        }\n    }]);\n    return CurriedComponentDefinition;\n}();\n\nvar IsCurriedComponentDefinitionReference = function (_ConditionalReference) {\n    inherits(IsCurriedComponentDefinitionReference, _ConditionalReference);\n\n    function IsCurriedComponentDefinitionReference() {\n        classCallCheck(this, IsCurriedComponentDefinitionReference);\n        return possibleConstructorReturn(this, _ConditionalReference.apply(this, arguments));\n    }\n\n    IsCurriedComponentDefinitionReference.create = function create(inner) {\n        return new IsCurriedComponentDefinitionReference(inner);\n    };\n\n    IsCurriedComponentDefinitionReference.prototype.toBool = function toBool(value) {\n        return isCurriedComponentDefinition(value);\n    };\n\n    return IsCurriedComponentDefinitionReference;\n}(ConditionalReference$1);\nAPPEND_OPCODES.add(24 /* DynamicContent */, function (vm, _ref) {\n    var isTrusting = _ref.op1;\n\n    var reference = vm.stack.pop();\n    var value = reference.value();\n    var content = void 0;\n    if (isTrusting) {\n        content = vm.elements().appendTrustingDynamicContent(value);\n    } else {\n        content = vm.elements().appendCautiousDynamicContent(value);\n    }\n    if (!isConst(reference)) {\n        vm.updateWith(new UpdateDynamicContentOpcode(reference, content));\n    }\n});\n\nvar UpdateDynamicContentOpcode = function (_UpdatingOpcode) {\n    inherits(UpdateDynamicContentOpcode, _UpdatingOpcode);\n\n    function UpdateDynamicContentOpcode(reference, content) {\n        classCallCheck(this, UpdateDynamicContentOpcode);\n\n        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode.call(this));\n\n        _this2.reference = reference;\n        _this2.content = content;\n        _this2.tag = reference.tag;\n        return _this2;\n    }\n\n    UpdateDynamicContentOpcode.prototype.evaluate = function evaluate(vm) {\n        var content = this.content,\n            reference = this.reference;\n\n        content.update(vm.env, reference.value());\n    };\n\n    return UpdateDynamicContentOpcode;\n}(UpdatingOpcode);\n\nAPPEND_OPCODES.add(18 /* ChildScope */, function (vm) {\n    return vm.pushChildScope();\n});\nAPPEND_OPCODES.add(19 /* PopScope */, function (vm) {\n    return vm.popScope();\n});\nAPPEND_OPCODES.add(37 /* PushDynamicScope */, function (vm) {\n    return vm.pushDynamicScope();\n});\nAPPEND_OPCODES.add(38 /* PopDynamicScope */, function (vm) {\n    return vm.popDynamicScope();\n});\nAPPEND_OPCODES.add(10 /* Constant */, function (vm, _ref) {\n    var other = _ref.op1;\n\n    vm.stack.push(vm.constants.getOther(other));\n});\nAPPEND_OPCODES.add(11 /* Primitive */, function (vm, _ref2) {\n    var primitive = _ref2.op1;\n\n    var stack = vm.stack;\n    var flag = primitive & 7; // 111\n    var value = primitive >> 3;\n    switch (flag) {\n        case 0 /* NUMBER */:\n            stack.push(value);\n            break;\n        case 1 /* FLOAT */:\n            stack.push(vm.constants.getFloat(value));\n            break;\n        case 2 /* STRING */:\n            stack.push(vm.constants.getString(value));\n            break;\n        case 3 /* BOOLEAN_OR_VOID */:\n            switch (value) {\n                case 0:\n                    stack.push(false);\n                    break;\n                case 1:\n                    stack.push(true);\n                    break;\n                case 2:\n                    stack.push(null);\n                    break;\n                case 3:\n                    stack.push(undefined);\n                    break;\n            }\n            break;\n        case 4 /* NEGATIVE */:\n            stack.push(vm.constants.getNegative(value));\n            break;\n    }\n});\nAPPEND_OPCODES.add(12 /* PrimitiveReference */, function (vm) {\n    var stack = vm.stack;\n    stack.push(PrimitiveReference.create(stack.pop()));\n});\nAPPEND_OPCODES.add(13 /* Dup */, function (vm, _ref3) {\n    var register = _ref3.op1,\n        offset = _ref3.op2;\n\n    var position = vm.fetchValue(register) - offset;\n    vm.stack.dup(position);\n});\nAPPEND_OPCODES.add(14 /* Pop */, function (vm, _ref4) {\n    var count = _ref4.op1;\n\n    vm.stack.pop(count);\n});\nAPPEND_OPCODES.add(15 /* Load */, function (vm, _ref5) {\n    var register = _ref5.op1;\n\n    vm.load(register);\n});\nAPPEND_OPCODES.add(16 /* Fetch */, function (vm, _ref6) {\n    var register = _ref6.op1;\n\n    vm.fetch(register);\n});\nAPPEND_OPCODES.add(36 /* BindDynamicScope */, function (vm, _ref7) {\n    var _names = _ref7.op1;\n\n    var names = vm.constants.getArray(_names);\n    vm.bindDynamicScope(names);\n});\nAPPEND_OPCODES.add(48 /* PushFrame */, function (vm) {\n    vm.pushFrame();\n});\nAPPEND_OPCODES.add(49 /* PopFrame */, function (vm) {\n    vm.popFrame();\n});\nAPPEND_OPCODES.add(50 /* Enter */, function (vm, _ref8) {\n    var args = _ref8.op1;\n\n    vm.enter(args);\n});\nAPPEND_OPCODES.add(51 /* Exit */, function (vm) {\n    vm.exit();\n});\nAPPEND_OPCODES.add(41 /* PushSymbolTable */, function (vm, _ref9) {\n    var _table = _ref9.op1;\n\n    var stack = vm.stack;\n    stack.push(vm.constants.getSymbolTable(_table));\n});\nAPPEND_OPCODES.add(40 /* PushBlockScope */, function (vm) {\n    var stack = vm.stack;\n    stack.push(vm.scope());\n});\nAPPEND_OPCODES.add(39 /* CompileBlock */, function (vm) {\n    var stack = vm.stack;\n    var block = stack.pop();\n    stack.push(block ? block.compile() : null);\n});\nAPPEND_OPCODES.add(42 /* InvokeVirtual */, function (vm) {\n    vm.call(vm.stack.pop());\n});\nAPPEND_OPCODES.add(43 /* InvokeStatic */, function (vm, _ref10) {\n    var handle = _ref10.op1;\n\n    vm.call(handle);\n});\nAPPEND_OPCODES.add(44 /* InvokeYield */, function (vm) {\n    var stack = vm.stack;\n\n    var handle = stack.pop();\n    var scope = stack.pop(); // FIXME(mmun): shouldn't need to cast this\n    var table = stack.pop();\n    false && debugAssert(table === null || table && (typeof table === 'undefined' ? 'undefined' : _typeof(table)) === 'object' && Array.isArray(table.parameters), stackAssert('Option<BlockSymbolTable>', table));\n\n    var args = stack.pop();\n    if (table === null) {\n        // To balance the pop{Frame,Scope}\n        vm.pushFrame();\n        vm.pushScope(scope); // Could be null but it doesnt matter as it is immediatelly popped.\n        return;\n    }\n    var invokingScope = scope;\n    // If necessary, create a child scope\n    {\n        var locals = table.parameters;\n        var localsCount = locals.length;\n        if (localsCount > 0) {\n            invokingScope = invokingScope.child();\n            for (var i = 0; i < localsCount; i++) {\n                invokingScope.bindSymbol(locals[i], args.at(i));\n            }\n        }\n    }\n    vm.pushFrame();\n    vm.pushScope(invokingScope);\n    vm.call(handle);\n});\nAPPEND_OPCODES.add(45 /* Jump */, function (vm, _ref11) {\n    var target = _ref11.op1;\n\n    vm.goto(target);\n});\nAPPEND_OPCODES.add(46 /* JumpIf */, function (vm, _ref12) {\n    var target = _ref12.op1;\n\n    var reference = vm.stack.pop();\n    if (isConst(reference)) {\n        if (reference.value()) {\n            vm.goto(target);\n        }\n    } else {\n        var cache = new ReferenceCache(reference);\n        if (cache.peek()) {\n            vm.goto(target);\n        }\n        vm.updateWith(new Assert(cache));\n    }\n});\nAPPEND_OPCODES.add(47 /* JumpUnless */, function (vm, _ref13) {\n    var target = _ref13.op1;\n\n    var reference = vm.stack.pop();\n    if (isConst(reference)) {\n        if (!reference.value()) {\n            vm.goto(target);\n        }\n    } else {\n        var cache = new ReferenceCache(reference);\n        if (!cache.peek()) {\n            vm.goto(target);\n        }\n        vm.updateWith(new Assert(cache));\n    }\n});\nAPPEND_OPCODES.add(20 /* Return */, function (vm) {\n    vm.return();\n});\nAPPEND_OPCODES.add(21 /* ReturnTo */, function (vm, _ref14) {\n    var relative = _ref14.op1;\n\n    vm.returnTo(relative);\n});\nAPPEND_OPCODES.add(52 /* ToBoolean */, function (vm) {\n    var env = vm.env,\n        stack = vm.stack;\n\n    stack.push(env.toConditionalReference(stack.pop()));\n});\nvar Assert = function (_UpdatingOpcode) {\n    inherits(Assert, _UpdatingOpcode);\n\n    function Assert(cache) {\n        classCallCheck(this, Assert);\n\n        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));\n\n        _this.type = 'assert';\n        _this.tag = cache.tag;\n        _this.cache = cache;\n        return _this;\n    }\n\n    Assert.prototype.evaluate = function evaluate(vm) {\n        var cache = this.cache;\n\n        if (isModified(cache.revalidate())) {\n            vm.throw();\n        }\n    };\n\n    return Assert;\n}(UpdatingOpcode);\nvar JumpIfNotModifiedOpcode = function (_UpdatingOpcode2) {\n    inherits(JumpIfNotModifiedOpcode, _UpdatingOpcode2);\n\n    function JumpIfNotModifiedOpcode(tag, target) {\n        classCallCheck(this, JumpIfNotModifiedOpcode);\n\n        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));\n\n        _this2.target = target;\n        _this2.type = 'jump-if-not-modified';\n        _this2.tag = tag;\n        _this2.lastRevision = tag.value();\n        return _this2;\n    }\n\n    JumpIfNotModifiedOpcode.prototype.evaluate = function evaluate(vm) {\n        var tag = this.tag,\n            target = this.target,\n            lastRevision = this.lastRevision;\n\n        if (!vm.alwaysRevalidate && tag.validate(lastRevision)) {\n            vm.goto(target);\n        }\n    };\n\n    JumpIfNotModifiedOpcode.prototype.didModify = function didModify() {\n        this.lastRevision = this.tag.value();\n    };\n\n    return JumpIfNotModifiedOpcode;\n}(UpdatingOpcode);\nvar DidModifyOpcode = function (_UpdatingOpcode3) {\n    inherits(DidModifyOpcode, _UpdatingOpcode3);\n\n    function DidModifyOpcode(target) {\n        classCallCheck(this, DidModifyOpcode);\n\n        var _this3 = possibleConstructorReturn(this, _UpdatingOpcode3.call(this));\n\n        _this3.target = target;\n        _this3.type = 'did-modify';\n        _this3.tag = CONSTANT_TAG;\n        return _this3;\n    }\n\n    DidModifyOpcode.prototype.evaluate = function evaluate() {\n        this.target.didModify();\n    };\n\n    return DidModifyOpcode;\n}(UpdatingOpcode);\nvar LabelOpcode = function () {\n    function LabelOpcode(label) {\n        classCallCheck(this, LabelOpcode);\n\n        this.tag = CONSTANT_TAG;\n        this.type = 'label';\n        this.label = null;\n        this.prev = null;\n        this.next = null;\n        initializeGuid(this);\n        this.label = label;\n    }\n\n    LabelOpcode.prototype.evaluate = function evaluate() {};\n\n    LabelOpcode.prototype.inspect = function inspect() {\n        return this.label + ' [' + this._guid + ']';\n    };\n\n    return LabelOpcode;\n}();\n\nAPPEND_OPCODES.add(22 /* Text */, function (vm, _ref) {\n    var text = _ref.op1;\n\n    vm.elements().appendText(vm.constants.getString(text));\n});\nAPPEND_OPCODES.add(26 /* OpenElementWithOperations */, function (vm, _ref2) {\n    var tag = _ref2.op1;\n\n    var tagName = vm.constants.getString(tag);\n    vm.elements().openElement(tagName);\n});\nAPPEND_OPCODES.add(23 /* Comment */, function (vm, _ref3) {\n    var text = _ref3.op1;\n\n    vm.elements().appendComment(vm.constants.getString(text));\n});\nAPPEND_OPCODES.add(25 /* OpenElement */, function (vm, _ref4) {\n    var tag = _ref4.op1;\n\n    vm.elements().openElement(vm.constants.getString(tag));\n});\nAPPEND_OPCODES.add(27 /* OpenDynamicElement */, function (vm) {\n    var tagName = vm.stack.pop().value();\n    vm.elements().openElement(tagName);\n});\nAPPEND_OPCODES.add(34 /* PushRemoteElement */, function (vm) {\n    var elementRef = vm.stack.pop();\n    var nextSiblingRef = vm.stack.pop();\n    var guidRef = vm.stack.pop();\n    var element = void 0;\n    var nextSibling = void 0;\n    var guid = guidRef.value();\n    if (isConst(elementRef)) {\n        element = elementRef.value();\n    } else {\n        var cache = new ReferenceCache(elementRef);\n        element = cache.peek();\n        vm.updateWith(new Assert(cache));\n    }\n    if (isConst(nextSiblingRef)) {\n        nextSibling = nextSiblingRef.value();\n    } else {\n        var _cache = new ReferenceCache(nextSiblingRef);\n        nextSibling = _cache.peek();\n        vm.updateWith(new Assert(_cache));\n    }\n    vm.elements().pushRemoteElement(element, guid, nextSibling);\n});\nAPPEND_OPCODES.add(35 /* PopRemoteElement */, function (vm) {\n    vm.elements().popRemoteElement();\n});\nAPPEND_OPCODES.add(31 /* FlushElement */, function (vm) {\n    var operations = vm.fetchValue(Register.t0);\n    if (operations) {\n        operations.flush(vm);\n        vm.loadValue(Register.t0, null);\n    }\n    vm.elements().flushElement();\n});\nAPPEND_OPCODES.add(32 /* CloseElement */, function (vm) {\n    vm.elements().closeElement();\n});\nAPPEND_OPCODES.add(33 /* Modifier */, function (vm, _ref5) {\n    var handle = _ref5.op1;\n\n    var manager = vm.constants.resolveHandle(handle);\n    var stack = vm.stack;\n    var args = stack.pop();\n\n    var _vm$elements = vm.elements(),\n        element = _vm$elements.constructing,\n        updateOperations = _vm$elements.updateOperations;\n\n    var dynamicScope = vm.dynamicScope();\n    var modifier = manager.create(element, args, dynamicScope, updateOperations);\n    vm.env.scheduleInstallModifier(modifier, manager);\n    var destructor = manager.getDestructor(modifier);\n    if (destructor) {\n        vm.newDestroyable(destructor);\n    }\n    var tag = manager.getTag(modifier);\n    if (!isConstTag(tag)) {\n        vm.updateWith(new UpdateModifierOpcode(tag, manager, modifier));\n    }\n});\nvar UpdateModifierOpcode = function (_UpdatingOpcode) {\n    inherits(UpdateModifierOpcode, _UpdatingOpcode);\n\n    function UpdateModifierOpcode(tag, manager, modifier) {\n        classCallCheck(this, UpdateModifierOpcode);\n\n        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));\n\n        _this.tag = tag;\n        _this.manager = manager;\n        _this.modifier = modifier;\n        _this.type = 'update-modifier';\n        _this.lastUpdated = tag.value();\n        return _this;\n    }\n\n    UpdateModifierOpcode.prototype.evaluate = function evaluate(vm) {\n        var manager = this.manager,\n            modifier = this.modifier,\n            tag = this.tag,\n            lastUpdated = this.lastUpdated;\n\n        if (!tag.validate(lastUpdated)) {\n            vm.env.scheduleUpdateModifier(modifier, manager);\n            this.lastUpdated = tag.value();\n        }\n    };\n\n    return UpdateModifierOpcode;\n}(UpdatingOpcode);\nAPPEND_OPCODES.add(28 /* StaticAttr */, function (vm, _ref6) {\n    var _name = _ref6.op1,\n        _value = _ref6.op2,\n        _namespace = _ref6.op3;\n\n    var name = vm.constants.getString(_name);\n    var value = vm.constants.getString(_value);\n    var namespace = _namespace ? vm.constants.getString(_namespace) : null;\n    vm.elements().setStaticAttribute(name, value, namespace);\n});\nAPPEND_OPCODES.add(29 /* DynamicAttr */, function (vm, _ref7) {\n    var _name = _ref7.op1,\n        trusting = _ref7.op2,\n        _namespace = _ref7.op3;\n\n    var name = vm.constants.getString(_name);\n    var reference = vm.stack.pop();\n    var value = reference.value();\n    var namespace = _namespace ? vm.constants.getString(_namespace) : null;\n    var attribute = vm.elements().setDynamicAttribute(name, value, !!trusting, namespace);\n    if (!isConst(reference)) {\n        vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));\n    }\n});\nvar UpdateDynamicAttributeOpcode = function (_UpdatingOpcode2) {\n    inherits(UpdateDynamicAttributeOpcode, _UpdatingOpcode2);\n\n    function UpdateDynamicAttributeOpcode(reference, attribute) {\n        classCallCheck(this, UpdateDynamicAttributeOpcode);\n\n        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));\n\n        _this2.reference = reference;\n        _this2.attribute = attribute;\n        _this2.type = 'patch-element';\n        _this2.tag = reference.tag;\n        _this2.lastRevision = _this2.tag.value();\n        return _this2;\n    }\n\n    UpdateDynamicAttributeOpcode.prototype.evaluate = function evaluate(vm) {\n        var attribute = this.attribute,\n            reference = this.reference,\n            tag = this.tag;\n\n        if (!tag.validate(this.lastRevision)) {\n            this.lastRevision = tag.value();\n            attribute.update(reference.value(), vm.env);\n        }\n    };\n\n    return UpdateDynamicAttributeOpcode;\n}(UpdatingOpcode);\n\nfunction resolveComponent(resolver, name, meta) {\n    var definition = resolver.lookupComponent(name, meta);\n    false && debugAssert(definition, 'Could not find a component named \"' + name + '\"');\n\n    return definition;\n}\n\n/** @internal */\nfunction hasStaticLayout(state, manager) {\n    return manager.getCapabilities(state).dynamicLayout === false;\n}\n/** @internal */\nfunction hasDynamicLayout(state, manager) {\n    return manager.getCapabilities(state).dynamicLayout === true;\n}\n\nvar CurryComponentReference = function () {\n    function CurryComponentReference(inner, resolver, meta, args) {\n        classCallCheck(this, CurryComponentReference);\n\n        this.inner = inner;\n        this.resolver = resolver;\n        this.meta = meta;\n        this.args = args;\n        this.tag = inner.tag;\n        this.lastValue = null;\n        this.lastDefinition = null;\n    }\n\n    CurryComponentReference.prototype.value = function value() {\n        var inner = this.inner,\n            lastValue = this.lastValue;\n\n        var value = inner.value();\n        if (value === lastValue) {\n            return this.lastDefinition;\n        }\n        var definition = null;\n        if (isCurriedComponentDefinition(value)) {\n            definition = value;\n        } else if (typeof value === 'string' && value) {\n            var resolver = this.resolver,\n                meta = this.meta;\n\n            definition = resolveComponent(resolver, value, meta);\n        }\n        definition = this.curry(definition);\n        this.lastValue = value;\n        this.lastDefinition = definition;\n        return definition;\n    };\n\n    CurryComponentReference.prototype.get = function get$$1() {\n        return UNDEFINED_REFERENCE;\n    };\n\n    CurryComponentReference.prototype.curry = function curry$$1(definition) {\n        var args = this.args;\n\n        if (!args && isCurriedComponentDefinition(definition)) {\n            return definition;\n        } else if (!definition) {\n            return null;\n        } else {\n            return new CurriedComponentDefinition(definition, args);\n        }\n    };\n\n    return CurryComponentReference;\n}();\n\nfunction normalizeStringValue(value) {\n    if (isEmpty(value)) {\n        return '';\n    }\n    return String(value);\n}\nfunction normalizeTrustedValue(value) {\n    if (isEmpty(value)) {\n        return '';\n    }\n    if (isString(value)) {\n        return value;\n    }\n    if (isSafeString(value)) {\n        return value.toHTML();\n    }\n    if (isNode(value)) {\n        return value;\n    }\n    return String(value);\n}\nfunction isEmpty(value) {\n    return value === null || value === undefined || typeof value.toString !== 'function';\n}\nfunction isSafeString(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && typeof value.toHTML === 'function';\n}\nfunction isNode(value) {\n    return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null && typeof value.nodeType === 'number';\n}\nfunction isFragment(value) {\n    return isNode(value) && value.nodeType === 11;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\nvar ClassListReference = function () {\n    function ClassListReference(list) {\n        classCallCheck(this, ClassListReference);\n\n        this.list = list;\n        this.tag = combineTagged(list);\n        this.list = list;\n    }\n\n    ClassListReference.prototype.value = function value() {\n        var ret = [];\n        var list = this.list;\n\n        for (var i = 0; i < list.length; i++) {\n            var value = normalizeStringValue(list[i].value());\n            if (value) ret.push(value);\n        }\n        return ret.length === 0 ? null : ret.join(' ');\n    };\n\n    return ClassListReference;\n}();\n\nvar ARGS = new Arguments();\nAPPEND_OPCODES.add(57 /* IsComponent */, function (vm) {\n    var stack = vm.stack;\n    var ref = stack.pop();\n    stack.push(IsCurriedComponentDefinitionReference.create(ref));\n});\nAPPEND_OPCODES.add(58 /* CurryComponent */, function (vm, _ref) {\n    var _meta = _ref.op1;\n\n    var stack = vm.stack;\n    var definition = stack.pop();\n    var args = stack.pop();\n    var captured = null;\n    if (args.length) {\n        captured = args.capture();\n    }\n    var meta = vm.constants.getSerializable(_meta);\n    var resolver = vm.constants.resolver;\n    vm.loadValue(Register.v0, new CurryComponentReference(definition, resolver, meta, captured));\n    // expectStackChange(vm.stack, -args.length - 1, 'CurryComponent');\n});\nAPPEND_OPCODES.add(59 /* PushComponentDefinition */, function (vm, _ref2) {\n    var handle = _ref2.op1;\n\n    var definition = vm.constants.resolveHandle(handle);\n    false && debugAssert(!!definition, 'Missing component for ' + handle + ' (TODO: env.specifierForHandle)');\n\n    var manager = definition.manager;\n\n    vm.stack.push({ definition: definition, manager: manager, state: null });\n});\nAPPEND_OPCODES.add(60 /* PushDynamicComponentManager */, function (vm, _ref3) {\n    var _meta = _ref3.op1;\n\n    var stack = vm.stack;\n    var component = stack.pop().value();\n    var definition = void 0;\n    if (typeof component === 'string') {\n        var constants = vm.constants,\n            resolver = vm.constants.resolver;\n\n        var meta = constants.getSerializable(_meta);\n        var resolvedDefinition = resolveComponent(resolver, component, meta);\n        definition = resolvedDefinition;\n    } else if (isCurriedComponentDefinition(component)) {\n        definition = component;\n    } else {\n        throw unreachable();\n    }\n    stack.push({ definition: definition, manager: null, state: null });\n});\nAPPEND_OPCODES.add(61 /* PushArgs */, function (vm, _ref4) {\n    var _names = _ref4.op1,\n        flags = _ref4.op2;\n\n    var stack = vm.stack;\n    var names = vm.constants.getStringArray(_names);\n    var positionalCount = flags >> 4;\n    var synthetic = flags & 8;\n    var blockNames = [];\n    if (flags & 4) blockNames.push('main');\n    if (flags & 2) blockNames.push('else');\n    if (flags & 1) blockNames.push('attrs');\n    ARGS.setup(stack, names, blockNames, positionalCount, !!synthetic);\n    stack.push(ARGS);\n});\nAPPEND_OPCODES.add(63 /* PrepareArgs */, function (vm, _ref5) {\n    var _state = _ref5.op1;\n\n    var stack = vm.stack;\n    var instance = vm.fetchValue(_state);\n    var definition = instance.definition;\n\n    var args = void 0;\n    if (isCurriedComponentDefinition(definition)) {\n        false && debugAssert(!definition.manager, \"If the component definition was curried, we don't yet have a manager\");\n\n        args = stack.pop();\n        definition = instance.definition = definition.unwrap(args);\n    } else {\n        args = stack.pop();\n    }\n    var _definition = definition,\n        manager = _definition.manager,\n        state = _definition.state;\n\n    instance.manager = definition.manager;\n    if (manager.getCapabilities(state).prepareArgs !== true) {\n        stack.push(args);\n        return;\n    }\n    var blocks = args.blocks.values;\n    var blockNames = args.blocks.names;\n    var preparedArgs = manager.prepareArgs(state, args);\n    if (preparedArgs) {\n        args.clear();\n        for (var i = 0; i < blocks.length; i++) {\n            stack.push(blocks[i]);\n        }\n        var positional = preparedArgs.positional,\n            named = preparedArgs.named;\n\n        var positionalCount = positional.length;\n        for (var _i = 0; _i < positionalCount; _i++) {\n            stack.push(positional[_i]);\n        }\n        var names = Object.keys(named);\n        for (var _i2 = 0; _i2 < names.length; _i2++) {\n            stack.push(named[names[_i2]]);\n        }\n        args.setup(stack, names, blockNames, positionalCount, true);\n    }\n    stack.push(args);\n});\nAPPEND_OPCODES.add(64 /* CreateComponent */, function (vm, _ref6) {\n    var flags = _ref6.op1,\n        _state = _ref6.op2;\n\n    var dynamicScope = vm.dynamicScope();\n    var instance = vm.fetchValue(_state);\n    var definition = instance.definition,\n        manager = instance.manager;\n\n    var hasDefaultBlock = flags & 1;\n    var args = null;\n    if (manager.getCapabilities(definition.state).createArgs) {\n        args = vm.stack.peek();\n    }\n    var state = manager.create(vm.env, definition.state, args, dynamicScope, vm.getSelf(), !!hasDefaultBlock);\n    // We want to reuse the `state` POJO here, because we know that the opcodes\n    // only transition at exactly one place.\n    instance.state = state;\n    var tag = manager.getTag(state);\n    if (!isConstTag(tag)) {\n        vm.updateWith(new UpdateComponentOpcode(tag, state, manager, dynamicScope));\n    }\n});\nAPPEND_OPCODES.add(65 /* RegisterComponentDestructor */, function (vm, _ref7) {\n    var _state = _ref7.op1;\n\n    var _vm$fetchValue = vm.fetchValue(_state),\n        manager = _vm$fetchValue.manager,\n        state = _vm$fetchValue.state;\n\n    var destructor = manager.getDestructor(state);\n    if (destructor) vm.newDestroyable(destructor);\n});\nAPPEND_OPCODES.add(71 /* BeginComponentTransaction */, function (vm) {\n    vm.beginCacheGroup();\n    vm.elements().pushSimpleBlock();\n});\nAPPEND_OPCODES.add(66 /* PutComponentOperations */, function (vm) {\n    vm.loadValue(Register.t0, new ComponentElementOperations());\n});\nAPPEND_OPCODES.add(30 /* ComponentAttr */, function (vm, _ref8) {\n    var _name = _ref8.op1,\n        trusting = _ref8.op2,\n        _namespace = _ref8.op3;\n\n    var name = vm.constants.getString(_name);\n    var reference = vm.stack.pop();\n    var namespace = _namespace ? vm.constants.getString(_namespace) : null;\n    vm.fetchValue(Register.t0).setAttribute(name, reference, !!trusting, namespace);\n});\nvar ComponentElementOperations = function () {\n    function ComponentElementOperations() {\n        classCallCheck(this, ComponentElementOperations);\n\n        this.attributes = dict();\n        this.classes = [];\n    }\n\n    ComponentElementOperations.prototype.setAttribute = function setAttribute(name, value, trusting, namespace) {\n        var deferred = { value: value, namespace: namespace, trusting: trusting };\n        if (name === 'class') {\n            this.classes.push(value);\n        }\n        this.attributes[name] = deferred;\n    };\n\n    ComponentElementOperations.prototype.flush = function flush(vm) {\n        for (var name in this.attributes) {\n            var attr = this.attributes[name];\n            var reference = attr.value,\n                namespace = attr.namespace,\n                trusting = attr.trusting;\n\n            if (name === 'class') {\n                reference = new ClassListReference(this.classes);\n            }\n            var attribute = vm.elements().setDynamicAttribute(name, reference.value(), trusting, namespace);\n            if (!isConst(reference)) {\n                vm.updateWith(new UpdateDynamicAttributeOpcode(reference, attribute));\n            }\n        }\n    };\n\n    return ComponentElementOperations;\n}();\nAPPEND_OPCODES.add(73 /* DidCreateElement */, function (vm, _ref9) {\n    var _state = _ref9.op1;\n\n    var _vm$fetchValue2 = vm.fetchValue(_state),\n        definition = _vm$fetchValue2.definition,\n        state = _vm$fetchValue2.state;\n\n    var manager = definition.manager;\n\n    var operations = vm.fetchValue(Register.t0);\n    var action = 'DidCreateElementOpcode#evaluate';\n    manager.didCreateElement(state, vm.elements().expectConstructing(action), operations);\n});\nAPPEND_OPCODES.add(67 /* GetComponentSelf */, function (vm, _ref10) {\n    var _state = _ref10.op1;\n\n    var _vm$fetchValue3 = vm.fetchValue(_state),\n        definition = _vm$fetchValue3.definition,\n        state = _vm$fetchValue3.state;\n\n    var manager = definition.manager;\n\n    vm.stack.push(manager.getSelf(state));\n});\nAPPEND_OPCODES.add(68 /* GetComponentTagName */, function (vm, _ref11) {\n    var _state = _ref11.op1;\n\n    var _vm$fetchValue4 = vm.fetchValue(_state),\n        definition = _vm$fetchValue4.definition,\n        state = _vm$fetchValue4.state;\n\n    var manager = definition.manager;\n\n    vm.stack.push(manager.getTagName(state));\n});\n// Dynamic Invocation Only\nAPPEND_OPCODES.add(69 /* GetComponentLayout */, function (vm, _ref12) {\n    var _state = _ref12.op1;\n\n    var instance = vm.fetchValue(_state);\n    var manager = instance.manager,\n        definition = instance.definition;\n    var resolver = vm.constants.resolver,\n        stack = vm.stack;\n    var instanceState = instance.state;\n    var definitionState = definition.state;\n\n    var invoke = void 0;\n    if (hasStaticLayout(definitionState, manager)) {\n        invoke = manager.getLayout(definitionState, resolver);\n    } else if (hasDynamicLayout(definitionState, manager)) {\n        invoke = manager.getDynamicLayout(instanceState, resolver);\n    } else {\n        throw unreachable();\n    }\n    stack.push(invoke.symbolTable);\n    stack.push(invoke.handle);\n});\n// Dynamic Invocation Only\nAPPEND_OPCODES.add(70 /* InvokeComponentLayout */, function (vm) {\n    var stack = vm.stack;\n\n    var handle = stack.pop();\n\n    var _stack$pop = stack.pop(),\n        symbols = _stack$pop.symbols,\n        hasEval = _stack$pop.hasEval;\n\n    {\n        var scope = vm.pushRootScope(symbols.length + 1, true);\n        scope.bindSelf(stack.pop());\n        var args = vm.stack.pop();\n        var lookup = null;\n        var $eval = -1;\n        if (hasEval) {\n            $eval = symbols.indexOf('$eval') + 1;\n            lookup = dict();\n        }\n        var callerNames = args.named.atNames;\n        for (var i = callerNames.length - 1; i >= 0; i--) {\n            var atName = callerNames[i];\n            var symbol = symbols.indexOf(callerNames[i]);\n            var value = args.named.get(atName, false);\n            if (symbol !== -1) scope.bindSymbol(symbol + 1, value);\n            if (hasEval) lookup[atName] = value;\n        }\n        var bindBlock = function bindBlock(symbolName, blockName) {\n            var symbol = symbols.indexOf(symbolName);\n            var block = blocks.get(blockName);\n            if (symbol !== -1) {\n                scope.bindBlock(symbol + 1, block);\n            }\n            if (lookup) lookup[symbolName] = block;\n        };\n        var blocks = args.blocks;\n        bindBlock(ATTRS_BLOCK, 'attrs');\n        bindBlock('&inverse', 'else');\n        bindBlock('&default', 'main');\n        if (lookup) scope.bindEvalScope(lookup);\n        vm.call(handle);\n    }\n});\nAPPEND_OPCODES.add(74 /* DidRenderLayout */, function (vm, _ref13) {\n    var _state = _ref13.op1;\n\n    var _vm$fetchValue5 = vm.fetchValue(_state),\n        manager = _vm$fetchValue5.manager,\n        state = _vm$fetchValue5.state;\n\n    var bounds = vm.elements().popBlock();\n    var mgr = manager;\n    mgr.didRenderLayout(state, bounds);\n    vm.env.didCreate(state, manager);\n    vm.updateWith(new DidUpdateLayoutOpcode(manager, state, bounds));\n});\nAPPEND_OPCODES.add(72 /* CommitComponentTransaction */, function (vm) {\n    vm.commitCacheGroup();\n});\nvar UpdateComponentOpcode = function (_UpdatingOpcode) {\n    inherits(UpdateComponentOpcode, _UpdatingOpcode);\n\n    function UpdateComponentOpcode(tag, component, manager, dynamicScope) {\n        classCallCheck(this, UpdateComponentOpcode);\n\n        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));\n\n        _this.tag = tag;\n        _this.component = component;\n        _this.manager = manager;\n        _this.dynamicScope = dynamicScope;\n        _this.type = 'update-component';\n        return _this;\n    }\n\n    UpdateComponentOpcode.prototype.evaluate = function evaluate(_vm) {\n        var component = this.component,\n            manager = this.manager,\n            dynamicScope = this.dynamicScope;\n\n        manager.update(component, dynamicScope);\n    };\n\n    return UpdateComponentOpcode;\n}(UpdatingOpcode);\nvar DidUpdateLayoutOpcode = function (_UpdatingOpcode2) {\n    inherits(DidUpdateLayoutOpcode, _UpdatingOpcode2);\n\n    function DidUpdateLayoutOpcode(manager, component, bounds) {\n        classCallCheck(this, DidUpdateLayoutOpcode);\n\n        var _this2 = possibleConstructorReturn(this, _UpdatingOpcode2.call(this));\n\n        _this2.manager = manager;\n        _this2.component = component;\n        _this2.bounds = bounds;\n        _this2.type = 'did-update-layout';\n        _this2.tag = CONSTANT_TAG;\n        return _this2;\n    }\n\n    DidUpdateLayoutOpcode.prototype.evaluate = function evaluate(vm) {\n        var manager = this.manager,\n            component = this.component,\n            bounds = this.bounds;\n\n        manager.didUpdateLayout(component, bounds);\n        vm.env.didUpdate(component, manager);\n    };\n\n    return DidUpdateLayoutOpcode;\n}(UpdatingOpcode);\n\n/* tslint:disable */\nfunction debugCallback(context, get$$1) {\n    console.info('Use `context`, and `get(<path>)` to debug this template.');\n    // for example...\n    context === get$$1('this');\n    debugger;\n}\n/* tslint:enable */\nvar callback = debugCallback;\n// For testing purposes\n\n\n\nvar ScopeInspector = function () {\n    function ScopeInspector(scope, symbols, evalInfo) {\n        classCallCheck(this, ScopeInspector);\n\n        this.scope = scope;\n        this.locals = dict();\n        for (var i = 0; i < evalInfo.length; i++) {\n            var slot = evalInfo[i];\n            var name = symbols[slot - 1];\n            var ref = scope.getSymbol(slot);\n            this.locals[name] = ref;\n        }\n    }\n\n    ScopeInspector.prototype.get = function get$$1(path) {\n        var scope = this.scope,\n            locals = this.locals;\n\n        var parts = path.split('.');\n\n        var _path$split = path.split('.'),\n            head = _path$split[0],\n            tail = _path$split.slice(1);\n\n        var evalScope = scope.getEvalScope();\n        var ref = void 0;\n        if (head === 'this') {\n            ref = scope.getSelf();\n        } else if (locals[head]) {\n            ref = locals[head];\n        } else if (head.indexOf('@') === 0 && evalScope[head]) {\n            ref = evalScope[head];\n        } else {\n            ref = this.scope.getSelf();\n            tail = parts;\n        }\n        return tail.reduce(function (r, part) {\n            return r.get(part);\n        }, ref);\n    };\n\n    return ScopeInspector;\n}();\n\nAPPEND_OPCODES.add(77 /* Debugger */, function (vm, _ref) {\n    var _symbols = _ref.op1,\n        _evalInfo = _ref.op2;\n\n    var symbols = vm.constants.getStringArray(_symbols);\n    var evalInfo = vm.constants.getArray(_evalInfo);\n    var inspector = new ScopeInspector(vm.scope(), symbols, evalInfo);\n    callback(vm.getSelf().value(), function (path) {\n        return inspector.get(path).value();\n    });\n});\n\nAPPEND_OPCODES.add(75 /* InvokePartial */, function (vm, _ref) {\n    var _meta = _ref.op1,\n        _symbols = _ref.op2,\n        _evalInfo = _ref.op3;\n    var constants = vm.constants,\n        resolver = vm.constants.resolver,\n        stack = vm.stack;\n\n    var name = stack.pop().value();\n    false && debugAssert(typeof name === 'string', 'Could not find a partial named \"' + String(name) + '\"');\n\n    var meta = constants.getSerializable(_meta);\n    var outerSymbols = constants.getStringArray(_symbols);\n    var evalInfo = constants.getArray(_evalInfo);\n    var specifier = resolver.lookupPartial(name, meta);\n    false && debugAssert(specifier, 'Could not find a partial named \"' + name + '\"');\n\n    var definition = resolver.resolve(specifier);\n\n    var _definition$getPartia = definition.getPartial(),\n        symbolTable = _definition$getPartia.symbolTable,\n        handle = _definition$getPartia.handle;\n\n    {\n        var partialSymbols = symbolTable.symbols;\n        var outerScope = vm.scope();\n        var partialScope = vm.pushRootScope(partialSymbols.length, false);\n        partialScope.bindCallerScope(outerScope.getCallerScope());\n        partialScope.bindEvalScope(outerScope.getEvalScope());\n        partialScope.bindSelf(outerScope.getSelf());\n        var locals = dict();\n        for (var i = 0; i < evalInfo.length; i++) {\n            var slot = evalInfo[i];\n            var _name = outerSymbols[slot - 1];\n            var ref = outerScope.getSymbol(slot);\n            locals[_name] = ref;\n        }\n        var evalScope = outerScope.getEvalScope();\n        for (var _i = 0; _i < partialSymbols.length; _i++) {\n            var _name2 = partialSymbols[_i];\n            var symbol = _i + 1;\n            var value = evalScope[_name2];\n            if (value !== undefined) partialScope.bind(symbol, value);\n        }\n        partialScope.bindPartialMap(locals);\n        vm.pushFrame(); // sp += 2\n        vm.call(handle);\n    }\n});\n\nvar IterablePresenceReference = function () {\n    function IterablePresenceReference(artifacts) {\n        classCallCheck(this, IterablePresenceReference);\n\n        this.tag = artifacts.tag;\n        this.artifacts = artifacts;\n    }\n\n    IterablePresenceReference.prototype.value = function value() {\n        return !this.artifacts.isEmpty();\n    };\n\n    return IterablePresenceReference;\n}();\n\nAPPEND_OPCODES.add(55 /* PutIterator */, function (vm) {\n    var stack = vm.stack;\n    var listRef = stack.pop();\n    var key = stack.pop();\n    var iterable = vm.env.iterableFor(listRef, key.value());\n    var iterator = new ReferenceIterator(iterable);\n    stack.push(iterator);\n    stack.push(new IterablePresenceReference(iterator.artifacts));\n});\nAPPEND_OPCODES.add(53 /* EnterList */, function (vm, _ref) {\n    var relativeStart = _ref.op1;\n\n    vm.enterList(relativeStart);\n});\nAPPEND_OPCODES.add(54 /* ExitList */, function (vm) {\n    vm.exitList();\n});\nAPPEND_OPCODES.add(56 /* Iterate */, function (vm, _ref2) {\n    var breaks = _ref2.op1;\n\n    var stack = vm.stack;\n    var item = stack.peek().next();\n    if (item) {\n        var tryOpcode = vm.iterate(item.memo, item.value);\n        vm.enterItem(item.key, tryOpcode);\n    } else {\n        vm.goto(breaks);\n    }\n});\n\nvar Cursor = function Cursor(element, nextSibling) {\n    classCallCheck(this, Cursor);\n\n    this.element = element;\n    this.nextSibling = nextSibling;\n};\nvar ConcreteBounds = function () {\n    function ConcreteBounds(parentNode, first, last) {\n        classCallCheck(this, ConcreteBounds);\n\n        this.parentNode = parentNode;\n        this.first = first;\n        this.last = last;\n    }\n\n    ConcreteBounds.prototype.parentElement = function parentElement() {\n        return this.parentNode;\n    };\n\n    ConcreteBounds.prototype.firstNode = function firstNode() {\n        return this.first;\n    };\n\n    ConcreteBounds.prototype.lastNode = function lastNode() {\n        return this.last;\n    };\n\n    return ConcreteBounds;\n}();\nvar SingleNodeBounds = function () {\n    function SingleNodeBounds(parentNode, node) {\n        classCallCheck(this, SingleNodeBounds);\n\n        this.parentNode = parentNode;\n        this.node = node;\n    }\n\n    SingleNodeBounds.prototype.parentElement = function parentElement() {\n        return this.parentNode;\n    };\n\n    SingleNodeBounds.prototype.firstNode = function firstNode() {\n        return this.node;\n    };\n\n    SingleNodeBounds.prototype.lastNode = function lastNode() {\n        return this.node;\n    };\n\n    return SingleNodeBounds;\n}();\nfunction bounds(parent, first, last) {\n    return new ConcreteBounds(parent, first, last);\n}\nfunction single(parent, node) {\n    return new SingleNodeBounds(parent, node);\n}\nfunction move(bounds, reference) {\n    var parent = bounds.parentElement();\n    var first = bounds.firstNode();\n    var last = bounds.lastNode();\n    var node = first;\n    while (node) {\n        var next = node.nextSibling;\n        parent.insertBefore(node, reference);\n        if (node === last) return next;\n        node = next;\n    }\n    return null;\n}\nfunction clear(bounds) {\n    var parent = bounds.parentElement();\n    var first = bounds.firstNode();\n    var last = bounds.lastNode();\n    var node = first;\n    while (node) {\n        var next = node.nextSibling;\n        parent.removeChild(node);\n        if (node === last) return next;\n        node = next;\n    }\n    return null;\n}\n\nvar SVG_NAMESPACE$1 = 'http://www.w3.org/2000/svg';\n// Patch:    insertAdjacentHTML on SVG Fix\n// Browsers: Safari, IE, Edge, Firefox ~33-34\n// Reason:   insertAdjacentHTML does not exist on SVG elements in Safari. It is\n//           present but throws an exception on IE and Edge. Old versions of\n//           Firefox create nodes in the incorrect namespace.\n// Fix:      Since IE and Edge silently fail to create SVG nodes using\n//           innerHTML, and because Firefox may create nodes in the incorrect\n//           namespace using innerHTML on SVG elements, an HTML-string wrapping\n//           approach is used. A pre/post SVG tag is added to the string, then\n//           that whole string is added to a div. The created nodes are plucked\n//           out and applied to the target location on DOM.\nfunction applySVGInnerHTMLFix(document, DOMClass, svgNamespace) {\n    if (!document) return DOMClass;\n    if (!shouldApplyFix(document, svgNamespace)) {\n        return DOMClass;\n    }\n    var div = document.createElement('div');\n    return function (_DOMClass) {\n        inherits(DOMChangesWithSVGInnerHTMLFix, _DOMClass);\n\n        function DOMChangesWithSVGInnerHTMLFix() {\n            classCallCheck(this, DOMChangesWithSVGInnerHTMLFix);\n            return possibleConstructorReturn(this, _DOMClass.apply(this, arguments));\n        }\n\n        DOMChangesWithSVGInnerHTMLFix.prototype.insertHTMLBefore = function insertHTMLBefore$$1(parent, nextSibling, html) {\n            if (html === null || html === '') {\n                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);\n            }\n            if (parent.namespaceURI !== svgNamespace) {\n                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);\n            }\n            return fixSVG(parent, div, html, nextSibling);\n        };\n\n        return DOMChangesWithSVGInnerHTMLFix;\n    }(DOMClass);\n}\nfunction fixSVG(parent, div, html, reference) {\n    // IE, Edge: also do not correctly support using `innerHTML` on SVG\n    // namespaced elements. So here a wrapper is used.\n    var wrappedHtml = '<svg>' + html + '</svg>';\n    div.innerHTML = wrappedHtml;\n\n    var _moveNodesBefore = moveNodesBefore(div.firstChild, parent, reference),\n        first = _moveNodesBefore[0],\n        last = _moveNodesBefore[1];\n\n    return new ConcreteBounds(parent, first, last);\n}\nfunction shouldApplyFix(document, svgNamespace) {\n    var svg = document.createElementNS(svgNamespace, 'svg');\n    try {\n        svg['insertAdjacentHTML']('beforeend', '<circle></circle>');\n    } catch (e) {\n        // IE, Edge: Will throw, insertAdjacentHTML is unsupported on SVG\n        // Safari: Will throw, insertAdjacentHTML is not present on SVG\n    } finally {\n        // FF: Old versions will create a node in the wrong namespace\n        if (svg.childNodes.length === 1 && svg.firstChild.namespaceURI === SVG_NAMESPACE$1) {\n            // The test worked as expected, no fix required\n            return false;\n        }\n        return true;\n    }\n}\n\n// Patch:    Adjacent text node merging fix\n// Browsers: IE, Edge, Firefox w/o inspector open\n// Reason:   These browsers will merge adjacent text nodes. For exmaple given\n//           <div>Hello</div> with div.insertAdjacentHTML(' world') browsers\n//           with proper behavior will populate div.childNodes with two items.\n//           These browsers will populate it with one merged node instead.\n// Fix:      Add these nodes to a wrapper element, then iterate the childNodes\n//           of that wrapper and move the nodes to their target location. Note\n//           that potential SVG bugs will have been handled before this fix.\n//           Note that this fix must only apply to the previous text node, as\n//           the base implementation of `insertHTMLBefore` already handles\n//           following text nodes correctly.\nfunction applyTextNodeMergingFix(document, DOMClass) {\n    if (!document) return DOMClass;\n    if (!shouldApplyFix$1(document)) {\n        return DOMClass;\n    }\n    return function (_DOMClass) {\n        inherits(DOMChangesWithTextNodeMergingFix, _DOMClass);\n\n        function DOMChangesWithTextNodeMergingFix(document) {\n            classCallCheck(this, DOMChangesWithTextNodeMergingFix);\n\n            var _this = possibleConstructorReturn(this, _DOMClass.call(this, document));\n\n            _this.uselessComment = document.createComment('');\n            return _this;\n        }\n\n        DOMChangesWithTextNodeMergingFix.prototype.insertHTMLBefore = function insertHTMLBefore(parent, nextSibling, html) {\n            if (html === null) {\n                return _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);\n            }\n            var didSetUselessComment = false;\n            var nextPrevious = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n            if (nextPrevious && nextPrevious instanceof Text) {\n                didSetUselessComment = true;\n                parent.insertBefore(this.uselessComment, nextSibling);\n            }\n            var bounds = _DOMClass.prototype.insertHTMLBefore.call(this, parent, nextSibling, html);\n            if (didSetUselessComment) {\n                parent.removeChild(this.uselessComment);\n            }\n            return bounds;\n        };\n\n        return DOMChangesWithTextNodeMergingFix;\n    }(DOMClass);\n}\nfunction shouldApplyFix$1(document) {\n    var mergingTextDiv = document.createElement('div');\n    mergingTextDiv.innerHTML = 'first';\n    mergingTextDiv.insertAdjacentHTML('beforeend', 'second');\n    if (mergingTextDiv.childNodes.length === 2) {\n        // It worked as expected, no fix required\n        return false;\n    }\n    return true;\n}\n\nvar SVG_NAMESPACE$$1 = 'http://www.w3.org/2000/svg';\n// http://www.w3.org/TR/html/syntax.html#html-integration-point\nvar SVG_INTEGRATION_POINTS = { foreignObject: 1, desc: 1, title: 1 };\n// http://www.w3.org/TR/html/syntax.html#adjust-svg-attributes\n// TODO: Adjust SVG attributes\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\n// TODO: Adjust SVG elements\n// http://www.w3.org/TR/html/syntax.html#parsing-main-inforeign\nvar BLACKLIST_TABLE = Object.create(null);\n[\"b\", \"big\", \"blockquote\", \"body\", \"br\", \"center\", \"code\", \"dd\", \"div\", \"dl\", \"dt\", \"em\", \"embed\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"hr\", \"i\", \"img\", \"li\", \"listing\", \"main\", \"meta\", \"nobr\", \"ol\", \"p\", \"pre\", \"ruby\", \"s\", \"small\", \"span\", \"strong\", \"strike\", \"sub\", \"sup\", \"table\", \"tt\", \"u\", \"ul\", \"var\"].forEach(function (tag) {\n    return BLACKLIST_TABLE[tag] = 1;\n});\nvar doc = typeof document === 'undefined' ? null : document;\n\nfunction moveNodesBefore(source, target, nextSibling) {\n    var first = source.firstChild;\n    var last = null;\n    var current = first;\n    while (current) {\n        last = current;\n        current = current.nextSibling;\n        target.insertBefore(last, nextSibling);\n    }\n    return [first, last];\n}\nvar DOMOperations = function () {\n    function DOMOperations(document) {\n        classCallCheck(this, DOMOperations);\n\n        this.document = document;\n        this.setupUselessElement();\n    }\n    // split into seperate method so that NodeDOMTreeConstruction\n    // can override it.\n\n\n    DOMOperations.prototype.setupUselessElement = function setupUselessElement() {\n        this.uselessElement = this.document.createElement('div');\n    };\n\n    DOMOperations.prototype.createElement = function createElement(tag, context) {\n        var isElementInSVGNamespace = void 0,\n            isHTMLIntegrationPoint = void 0;\n        if (context) {\n            isElementInSVGNamespace = context.namespaceURI === SVG_NAMESPACE$$1 || tag === 'svg';\n            isHTMLIntegrationPoint = SVG_INTEGRATION_POINTS[context.tagName];\n        } else {\n            isElementInSVGNamespace = tag === 'svg';\n            isHTMLIntegrationPoint = false;\n        }\n        if (isElementInSVGNamespace && !isHTMLIntegrationPoint) {\n            // FIXME: This does not properly handle <font> with color, face, or\n            // size attributes, which is also disallowed by the spec. We should fix\n            // this.\n            if (BLACKLIST_TABLE[tag]) {\n                throw new Error('Cannot create a ' + tag + ' inside an SVG context');\n            }\n            return this.document.createElementNS(SVG_NAMESPACE$$1, tag);\n        } else {\n            return this.document.createElement(tag);\n        }\n    };\n\n    DOMOperations.prototype.insertBefore = function insertBefore(parent, node, reference) {\n        parent.insertBefore(node, reference);\n    };\n\n    DOMOperations.prototype.insertHTMLBefore = function insertHTMLBefore(_parent, nextSibling, html) {\n        return _insertHTMLBefore(this.uselessElement, _parent, nextSibling, html);\n    };\n\n    DOMOperations.prototype.createTextNode = function createTextNode(text) {\n        return this.document.createTextNode(text);\n    };\n\n    DOMOperations.prototype.createComment = function createComment(data) {\n        return this.document.createComment(data);\n    };\n\n    return DOMOperations;\n}();\nvar DOM;\n(function (DOM) {\n    var TreeConstruction = function (_DOMOperations) {\n        inherits(TreeConstruction, _DOMOperations);\n\n        function TreeConstruction() {\n            classCallCheck(this, TreeConstruction);\n            return possibleConstructorReturn(this, _DOMOperations.apply(this, arguments));\n        }\n\n        TreeConstruction.prototype.createElementNS = function createElementNS(namespace, tag) {\n            return this.document.createElementNS(namespace, tag);\n        };\n\n        TreeConstruction.prototype.setAttribute = function setAttribute(element, name, value) {\n            var namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n            if (namespace) {\n                element.setAttributeNS(namespace, name, value);\n            } else {\n                element.setAttribute(name, value);\n            }\n        };\n\n        return TreeConstruction;\n    }(DOMOperations);\n\n    DOM.TreeConstruction = TreeConstruction;\n    var appliedTreeContruction = TreeConstruction;\n    appliedTreeContruction = applyTextNodeMergingFix(doc, appliedTreeContruction);\n    appliedTreeContruction = applySVGInnerHTMLFix(doc, appliedTreeContruction, SVG_NAMESPACE$$1);\n    DOM.DOMTreeConstruction = appliedTreeContruction;\n})(DOM || (DOM = {}));\nvar DOMChanges = function (_DOMOperations2) {\n    inherits(DOMChanges, _DOMOperations2);\n\n    function DOMChanges(document) {\n        classCallCheck(this, DOMChanges);\n\n        var _this2 = possibleConstructorReturn(this, _DOMOperations2.call(this, document));\n\n        _this2.document = document;\n        _this2.namespace = null;\n        return _this2;\n    }\n\n    DOMChanges.prototype.setAttribute = function setAttribute(element, name, value) {\n        element.setAttribute(name, value);\n    };\n\n    DOMChanges.prototype.removeAttribute = function removeAttribute(element, name) {\n        element.removeAttribute(name);\n    };\n\n    DOMChanges.prototype.insertAfter = function insertAfter(element, node, reference) {\n        this.insertBefore(element, node, reference.nextSibling);\n    };\n\n    return DOMChanges;\n}(DOMOperations);\nfunction _insertHTMLBefore(_useless, _parent, _nextSibling, html) {\n    // TypeScript vendored an old version of the DOM spec where `insertAdjacentHTML`\n    // only exists on `HTMLElement` but not on `Element`. We actually work with the\n    // newer version of the DOM API here (and monkey-patch this method in `./compat`\n    // when we detect older browsers). This is a hack to work around this limitation.\n    var parent = _parent;\n    var useless = _useless;\n    var nextSibling = _nextSibling;\n    var prev = nextSibling ? nextSibling.previousSibling : parent.lastChild;\n    var last = void 0;\n    if (html === null || html === '') {\n        return new ConcreteBounds(parent, null, null);\n    }\n    if (nextSibling === null) {\n        parent.insertAdjacentHTML('beforeend', html);\n        last = parent.lastChild;\n    } else if (nextSibling instanceof HTMLElement) {\n        nextSibling.insertAdjacentHTML('beforebegin', html);\n        last = nextSibling.previousSibling;\n    } else {\n        // Non-element nodes do not support insertAdjacentHTML, so add an\n        // element and call it on that element. Then remove the element.\n        //\n        // This also protects Edge, IE and Firefox w/o the inspector open\n        // from merging adjacent text nodes. See ./compat/text-node-merging-fix.ts\n        parent.insertBefore(useless, nextSibling);\n        useless.insertAdjacentHTML('beforebegin', html);\n        last = useless.previousSibling;\n        parent.removeChild(useless);\n    }\n    var first = prev ? prev.nextSibling : parent.firstChild;\n    return new ConcreteBounds(parent, first, last);\n}\nvar helper = DOMChanges;\nhelper = applyTextNodeMergingFix(doc, helper);\nhelper = applySVGInnerHTMLFix(doc, helper, SVG_NAMESPACE$$1);\nvar DOMChanges$1 = helper;\nvar DOMTreeConstruction = DOM.DOMTreeConstruction;\n\nvar badProtocols = ['javascript:', 'vbscript:'];\nvar badTags = ['A', 'BODY', 'LINK', 'IMG', 'IFRAME', 'BASE', 'FORM'];\nvar badTagsForDataURI = ['EMBED'];\nvar badAttributes = ['href', 'src', 'background', 'action'];\nvar badAttributesForDataURI = ['src'];\nfunction has(array, item) {\n    return array.indexOf(item) !== -1;\n}\nfunction checkURI(tagName, attribute) {\n    return (tagName === null || has(badTags, tagName)) && has(badAttributes, attribute);\n}\nfunction checkDataURI(tagName, attribute) {\n    if (tagName === null) return false;\n    return has(badTagsForDataURI, tagName) && has(badAttributesForDataURI, attribute);\n}\nfunction requiresSanitization(tagName, attribute) {\n    return checkURI(tagName, attribute) || checkDataURI(tagName, attribute);\n}\nfunction sanitizeAttributeValue(env, element, attribute, value) {\n    var tagName = null;\n    if (value === null || value === undefined) {\n        return value;\n    }\n    if (isSafeString(value)) {\n        return value.toHTML();\n    }\n    if (!element) {\n        tagName = null;\n    } else {\n        tagName = element.tagName.toUpperCase();\n    }\n    var str = normalizeStringValue(value);\n    if (checkURI(tagName, attribute)) {\n        var protocol = env.protocolForURL(str);\n        if (has(badProtocols, protocol)) {\n            return 'unsafe:' + str;\n        }\n    }\n    if (checkDataURI(tagName, attribute)) {\n        return 'unsafe:' + str;\n    }\n    return str;\n}\n\n/*\n * @method normalizeProperty\n * @param element {HTMLElement}\n * @param slotName {String}\n * @returns {Object} { name, type }\n */\nfunction normalizeProperty(element, slotName) {\n    var type = void 0,\n        normalized = void 0;\n    if (slotName in element) {\n        normalized = slotName;\n        type = 'prop';\n    } else {\n        var lower = slotName.toLowerCase();\n        if (lower in element) {\n            type = 'prop';\n            normalized = lower;\n        } else {\n            type = 'attr';\n            normalized = slotName;\n        }\n    }\n    if (type === 'prop' && (normalized.toLowerCase() === 'style' || preferAttr(element.tagName, normalized))) {\n        type = 'attr';\n    }\n    return { normalized: normalized, type: type };\n}\n\n// properties that MUST be set as attributes, due to:\n// * browser bug\n// * strange spec outlier\nvar ATTR_OVERRIDES = {\n    INPUT: {\n        form: true,\n        // Chrome 46.0.2464.0: 'autocorrect' in document.createElement('input') === false\n        // Safari 8.0.7: 'autocorrect' in document.createElement('input') === false\n        // Mobile Safari (iOS 8.4 simulator): 'autocorrect' in document.createElement('input') === true\n        autocorrect: true,\n        // Chrome 54.0.2840.98: 'list' in document.createElement('input') === true\n        // Safari 9.1.3: 'list' in document.createElement('input') === false\n        list: true\n    },\n    // element.form is actually a legitimate readOnly property, that is to be\n    // mutated, but must be mutated by setAttribute...\n    SELECT: { form: true },\n    OPTION: { form: true },\n    TEXTAREA: { form: true },\n    LABEL: { form: true },\n    FIELDSET: { form: true },\n    LEGEND: { form: true },\n    OBJECT: { form: true }\n};\nfunction preferAttr(tagName, propName) {\n    var tag = ATTR_OVERRIDES[tagName.toUpperCase()];\n    return tag && tag[propName.toLowerCase()] || false;\n}\n\nfunction defaultDynamicAttributes(element, attr) {\n    var tagName = element.tagName,\n        namespaceURI = element.namespaceURI;\n\n    if (namespaceURI === SVG_NAMESPACE$$1) {\n        return defaultDynamicAttribute(tagName, attr);\n    }\n\n    var _normalizeProperty = normalizeProperty(element, attr),\n        type = _normalizeProperty.type,\n        normalized = _normalizeProperty.normalized;\n\n    if (type === 'attr') {\n        return defaultDynamicAttribute(tagName, normalized);\n    } else {\n        return defaultDynamicProperty(tagName, normalized);\n    }\n}\nfunction defaultDynamicAttribute(tagName, name) {\n    if (requiresSanitization(tagName, name)) {\n        return SafeDynamicAttribute;\n    } else {\n        return SimpleDynamicAttribute;\n    }\n}\nfunction defaultDynamicProperty(tagName, name) {\n    if (requiresSanitization(tagName, name)) {\n        return SafeDynamicProperty;\n    }\n    if (isUserInputValue(tagName, name)) {\n        return InputValueDynamicAttribute;\n    }\n    if (isOptionSelected(tagName, name)) {\n        return OptionSelectedDynamicAttribute;\n    }\n    return DefaultDynamicProperty;\n}\nvar DynamicAttribute = function DynamicAttribute(attribute) {\n    classCallCheck(this, DynamicAttribute);\n\n    this.attribute = attribute;\n};\nvar SimpleDynamicAttribute = function (_DynamicAttribute) {\n    inherits(SimpleDynamicAttribute, _DynamicAttribute);\n\n    function SimpleDynamicAttribute() {\n        classCallCheck(this, SimpleDynamicAttribute);\n        return possibleConstructorReturn(this, _DynamicAttribute.apply(this, arguments));\n    }\n\n    SimpleDynamicAttribute.prototype.set = function set$$1(dom, value, _env) {\n        var normalizedValue = normalizeValue(value);\n        if (normalizedValue !== null) {\n            var _attribute = this.attribute,\n                name = _attribute.name,\n                namespace = _attribute.namespace;\n\n            dom.__setAttribute(name, normalizedValue, namespace);\n        }\n    };\n\n    SimpleDynamicAttribute.prototype.update = function update(value, _env) {\n        var normalizedValue = normalizeValue(value);\n        var _attribute2 = this.attribute,\n            element = _attribute2.element,\n            name = _attribute2.name;\n\n        if (normalizedValue === null) {\n            element.removeAttribute(name);\n        } else {\n            element.setAttribute(name, normalizedValue);\n        }\n    };\n\n    return SimpleDynamicAttribute;\n}(DynamicAttribute);\nvar DefaultDynamicProperty = function (_DynamicAttribute2) {\n    inherits(DefaultDynamicProperty, _DynamicAttribute2);\n\n    function DefaultDynamicProperty() {\n        classCallCheck(this, DefaultDynamicProperty);\n        return possibleConstructorReturn(this, _DynamicAttribute2.apply(this, arguments));\n    }\n\n    DefaultDynamicProperty.prototype.set = function set$$1(dom, value, _env) {\n        if (value !== null && value !== undefined) {\n            var name = this.attribute.name;\n\n            this.value = value;\n            dom.__setProperty(name, value);\n        }\n    };\n\n    DefaultDynamicProperty.prototype.update = function update(value, _env) {\n        var _attribute3 = this.attribute,\n            element = _attribute3.element,\n            name = _attribute3.name;\n\n        if (this.value !== value) {\n            element[name] = this.value = value;\n            if (value === null || value === undefined) {\n                this.removeAttribute();\n            }\n        }\n    };\n\n    DefaultDynamicProperty.prototype.removeAttribute = function removeAttribute() {\n        // TODO this sucks but to preserve properties first and to meet current\n        // semantics we must do this.\n        var _attribute4 = this.attribute,\n            element = _attribute4.element,\n            name = _attribute4.name,\n            namespace = _attribute4.namespace;\n\n        if (namespace) {\n            element.removeAttributeNS(namespace, name);\n        } else {\n            element.removeAttribute(name);\n        }\n    };\n\n    return DefaultDynamicProperty;\n}(DynamicAttribute);\nvar SafeDynamicProperty = function (_DefaultDynamicProper) {\n    inherits(SafeDynamicProperty, _DefaultDynamicProper);\n\n    function SafeDynamicProperty() {\n        classCallCheck(this, SafeDynamicProperty);\n        return possibleConstructorReturn(this, _DefaultDynamicProper.apply(this, arguments));\n    }\n\n    SafeDynamicProperty.prototype.set = function set$$1(dom, value, env) {\n        var _attribute5 = this.attribute,\n            element = _attribute5.element,\n            name = _attribute5.name;\n\n        var sanitized = sanitizeAttributeValue(env, element, name, value);\n        _DefaultDynamicProper.prototype.set.call(this, dom, sanitized, env);\n    };\n\n    SafeDynamicProperty.prototype.update = function update(value, env) {\n        var _attribute6 = this.attribute,\n            element = _attribute6.element,\n            name = _attribute6.name;\n\n        var sanitized = sanitizeAttributeValue(env, element, name, value);\n        _DefaultDynamicProper.prototype.update.call(this, sanitized, env);\n    };\n\n    return SafeDynamicProperty;\n}(DefaultDynamicProperty);\nvar SafeDynamicAttribute = function (_SimpleDynamicAttribu) {\n    inherits(SafeDynamicAttribute, _SimpleDynamicAttribu);\n\n    function SafeDynamicAttribute() {\n        classCallCheck(this, SafeDynamicAttribute);\n        return possibleConstructorReturn(this, _SimpleDynamicAttribu.apply(this, arguments));\n    }\n\n    SafeDynamicAttribute.prototype.set = function set$$1(dom, value, env) {\n        var _attribute7 = this.attribute,\n            element = _attribute7.element,\n            name = _attribute7.name;\n\n        var sanitized = sanitizeAttributeValue(env, element, name, value);\n        _SimpleDynamicAttribu.prototype.set.call(this, dom, sanitized, env);\n    };\n\n    SafeDynamicAttribute.prototype.update = function update(value, env) {\n        var _attribute8 = this.attribute,\n            element = _attribute8.element,\n            name = _attribute8.name;\n\n        var sanitized = sanitizeAttributeValue(env, element, name, value);\n        _SimpleDynamicAttribu.prototype.update.call(this, sanitized, env);\n    };\n\n    return SafeDynamicAttribute;\n}(SimpleDynamicAttribute);\nvar InputValueDynamicAttribute = function (_DefaultDynamicProper2) {\n    inherits(InputValueDynamicAttribute, _DefaultDynamicProper2);\n\n    function InputValueDynamicAttribute() {\n        classCallCheck(this, InputValueDynamicAttribute);\n        return possibleConstructorReturn(this, _DefaultDynamicProper2.apply(this, arguments));\n    }\n\n    InputValueDynamicAttribute.prototype.set = function set$$1(dom, value) {\n        dom.__setProperty('value', normalizeStringValue(value));\n    };\n\n    InputValueDynamicAttribute.prototype.update = function update(value) {\n        var input = this.attribute.element;\n        var currentValue = input.value;\n        var normalizedValue = normalizeStringValue(value);\n        if (currentValue !== normalizedValue) {\n            input.value = normalizedValue;\n        }\n    };\n\n    return InputValueDynamicAttribute;\n}(DefaultDynamicProperty);\nvar OptionSelectedDynamicAttribute = function (_DefaultDynamicProper3) {\n    inherits(OptionSelectedDynamicAttribute, _DefaultDynamicProper3);\n\n    function OptionSelectedDynamicAttribute() {\n        classCallCheck(this, OptionSelectedDynamicAttribute);\n        return possibleConstructorReturn(this, _DefaultDynamicProper3.apply(this, arguments));\n    }\n\n    OptionSelectedDynamicAttribute.prototype.set = function set$$1(dom, value) {\n        if (value !== null && value !== undefined && value !== false) {\n            dom.__setProperty('selected', true);\n        }\n    };\n\n    OptionSelectedDynamicAttribute.prototype.update = function update(value) {\n        var option = this.attribute.element;\n        if (value) {\n            option.selected = true;\n        } else {\n            option.selected = false;\n        }\n    };\n\n    return OptionSelectedDynamicAttribute;\n}(DefaultDynamicProperty);\nfunction isOptionSelected(tagName, attribute) {\n    return tagName === 'OPTION' && attribute === 'selected';\n}\nfunction isUserInputValue(tagName, attribute) {\n    return (tagName === 'INPUT' || tagName === 'TEXTAREA') && attribute === 'value';\n}\nfunction normalizeValue(value) {\n    if (value === false || value === undefined || value === null || typeof value.toString === 'undefined') {\n        return null;\n    }\n    if (value === true) {\n        return '';\n    }\n    // onclick function etc in SSR\n    if (typeof value === 'function') {\n        return null;\n    }\n    return String(value);\n}\n\nvar Scope = function () {\n    function Scope(\n    // the 0th slot is `self`\n    slots, callerScope,\n    // named arguments and blocks passed to a layout that uses eval\n    evalScope,\n    // locals in scope when the partial was invoked\n    partialMap) {\n        classCallCheck(this, Scope);\n\n        this.slots = slots;\n        this.callerScope = callerScope;\n        this.evalScope = evalScope;\n        this.partialMap = partialMap;\n    }\n\n    Scope.root = function root(self) {\n        var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n        var refs = new Array(size + 1);\n        for (var i = 0; i <= size; i++) {\n            refs[i] = UNDEFINED_REFERENCE;\n        }\n        return new Scope(refs, null, null, null).init({ self: self });\n    };\n\n    Scope.sized = function sized() {\n        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n        var refs = new Array(size + 1);\n        for (var i = 0; i <= size; i++) {\n            refs[i] = UNDEFINED_REFERENCE;\n        }\n        return new Scope(refs, null, null, null);\n    };\n\n    Scope.prototype.init = function init(_ref) {\n        var self = _ref.self;\n\n        this.slots[0] = self;\n        return this;\n    };\n\n    Scope.prototype.getSelf = function getSelf() {\n        return this.get(0);\n    };\n\n    Scope.prototype.getSymbol = function getSymbol(symbol) {\n        return this.get(symbol);\n    };\n\n    Scope.prototype.getBlock = function getBlock(symbol) {\n        return this.get(symbol);\n    };\n\n    Scope.prototype.getEvalScope = function getEvalScope() {\n        return this.evalScope;\n    };\n\n    Scope.prototype.getPartialMap = function getPartialMap() {\n        return this.partialMap;\n    };\n\n    Scope.prototype.bind = function bind(symbol, value) {\n        this.set(symbol, value);\n    };\n\n    Scope.prototype.bindSelf = function bindSelf(self) {\n        this.set(0, self);\n    };\n\n    Scope.prototype.bindSymbol = function bindSymbol(symbol, value) {\n        this.set(symbol, value);\n    };\n\n    Scope.prototype.bindBlock = function bindBlock(symbol, value) {\n        this.set(symbol, value);\n    };\n\n    Scope.prototype.bindEvalScope = function bindEvalScope(map) {\n        this.evalScope = map;\n    };\n\n    Scope.prototype.bindPartialMap = function bindPartialMap(map) {\n        this.partialMap = map;\n    };\n\n    Scope.prototype.bindCallerScope = function bindCallerScope(scope) {\n        this.callerScope = scope;\n    };\n\n    Scope.prototype.getCallerScope = function getCallerScope() {\n        return this.callerScope;\n    };\n\n    Scope.prototype.child = function child() {\n        return new Scope(this.slots.slice(), this.callerScope, this.evalScope, this.partialMap);\n    };\n\n    Scope.prototype.get = function get$$1(index) {\n        if (index >= this.slots.length) {\n            throw new RangeError('BUG: cannot get $' + index + ' from scope; length=' + this.slots.length);\n        }\n        return this.slots[index];\n    };\n\n    Scope.prototype.set = function set$$1(index, value) {\n        if (index >= this.slots.length) {\n            throw new RangeError('BUG: cannot get $' + index + ' from scope; length=' + this.slots.length);\n        }\n        this.slots[index] = value;\n    };\n\n    return Scope;\n}();\n\nvar Transaction = function () {\n    function Transaction() {\n        classCallCheck(this, Transaction);\n\n        this.scheduledInstallManagers = [];\n        this.scheduledInstallModifiers = [];\n        this.scheduledUpdateModifierManagers = [];\n        this.scheduledUpdateModifiers = [];\n        this.createdComponents = [];\n        this.createdManagers = [];\n        this.updatedComponents = [];\n        this.updatedManagers = [];\n        this.destructors = [];\n    }\n\n    Transaction.prototype.didCreate = function didCreate(component, manager) {\n        this.createdComponents.push(component);\n        this.createdManagers.push(manager);\n    };\n\n    Transaction.prototype.didUpdate = function didUpdate(component, manager) {\n        this.updatedComponents.push(component);\n        this.updatedManagers.push(manager);\n    };\n\n    Transaction.prototype.scheduleInstallModifier = function scheduleInstallModifier(modifier, manager) {\n        this.scheduledInstallManagers.push(manager);\n        this.scheduledInstallModifiers.push(modifier);\n    };\n\n    Transaction.prototype.scheduleUpdateModifier = function scheduleUpdateModifier(modifier, manager) {\n        this.scheduledUpdateModifierManagers.push(manager);\n        this.scheduledUpdateModifiers.push(modifier);\n    };\n\n    Transaction.prototype.didDestroy = function didDestroy(d) {\n        this.destructors.push(d);\n    };\n\n    Transaction.prototype.commit = function commit() {\n        var createdComponents = this.createdComponents,\n            createdManagers = this.createdManagers;\n\n        for (var i = 0; i < createdComponents.length; i++) {\n            var component = createdComponents[i];\n            var manager = createdManagers[i];\n            manager.didCreate(component);\n        }\n        var updatedComponents = this.updatedComponents,\n            updatedManagers = this.updatedManagers;\n\n        for (var _i = 0; _i < updatedComponents.length; _i++) {\n            var _component = updatedComponents[_i];\n            var _manager = updatedManagers[_i];\n            _manager.didUpdate(_component);\n        }\n        var destructors = this.destructors;\n\n        for (var _i2 = 0; _i2 < destructors.length; _i2++) {\n            destructors[_i2].destroy();\n        }\n        var scheduledInstallManagers = this.scheduledInstallManagers,\n            scheduledInstallModifiers = this.scheduledInstallModifiers;\n\n        for (var _i3 = 0; _i3 < scheduledInstallManagers.length; _i3++) {\n            var _manager2 = scheduledInstallManagers[_i3];\n            var modifier = scheduledInstallModifiers[_i3];\n            _manager2.install(modifier);\n        }\n        var scheduledUpdateModifierManagers = this.scheduledUpdateModifierManagers,\n            scheduledUpdateModifiers = this.scheduledUpdateModifiers;\n\n        for (var _i4 = 0; _i4 < scheduledUpdateModifierManagers.length; _i4++) {\n            var _manager3 = scheduledUpdateModifierManagers[_i4];\n            var _modifier = scheduledUpdateModifiers[_i4];\n            _manager3.update(_modifier);\n        }\n    };\n\n    return Transaction;\n}();\n\nvar Environment = function () {\n    function Environment(_ref2) {\n        var appendOperations = _ref2.appendOperations,\n            updateOperations = _ref2.updateOperations;\n        classCallCheck(this, Environment);\n\n        this._transaction = null;\n        this.appendOperations = appendOperations;\n        this.updateOperations = updateOperations;\n    }\n\n    Environment.prototype.toConditionalReference = function toConditionalReference(reference) {\n        return new ConditionalReference$1(reference);\n    };\n\n    Environment.prototype.getAppendOperations = function getAppendOperations() {\n        return this.appendOperations;\n    };\n\n    Environment.prototype.getDOM = function getDOM() {\n        return this.updateOperations;\n    };\n\n    Environment.prototype.getIdentity = function getIdentity(object) {\n        return ensureGuid(object) + '';\n    };\n\n    Environment.prototype.begin = function begin() {\n        false && debugAssert(!this._transaction, 'a glimmer transaction was begun, but one already exists. You may have a nested transaction');\n\n        this._transaction = new Transaction();\n    };\n\n    Environment.prototype.didCreate = function didCreate(component, manager) {\n        this.transaction.didCreate(component, manager);\n    };\n\n    Environment.prototype.didUpdate = function didUpdate(component, manager) {\n        this.transaction.didUpdate(component, manager);\n    };\n\n    Environment.prototype.scheduleInstallModifier = function scheduleInstallModifier(modifier, manager) {\n        this.transaction.scheduleInstallModifier(modifier, manager);\n    };\n\n    Environment.prototype.scheduleUpdateModifier = function scheduleUpdateModifier(modifier, manager) {\n        this.transaction.scheduleUpdateModifier(modifier, manager);\n    };\n\n    Environment.prototype.didDestroy = function didDestroy(d) {\n        this.transaction.didDestroy(d);\n    };\n\n    Environment.prototype.commit = function commit() {\n        var transaction = this.transaction;\n        this._transaction = null;\n        transaction.commit();\n    };\n\n    Environment.prototype.attributeFor = function attributeFor(element, attr, _isTrusting) {\n        var _namespace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n        return defaultDynamicAttributes(element, attr);\n    };\n\n    createClass(Environment, [{\n        key: 'transaction',\n        get: function get$$1() {\n            return this._transaction;\n        }\n    }]);\n    return Environment;\n}();\nvar DefaultEnvironment = function (_Environment) {\n    inherits(DefaultEnvironment, _Environment);\n\n    function DefaultEnvironment(options) {\n        classCallCheck(this, DefaultEnvironment);\n\n        if (!options) {\n            var document = window.document;\n            var appendOperations = new DOMTreeConstruction(document);\n            var updateOperations = new DOMChanges(document);\n            options = { appendOperations: appendOperations, updateOperations: updateOperations };\n        }\n        return possibleConstructorReturn(this, _Environment.call(this, options));\n    }\n\n    return DefaultEnvironment;\n}(Environment);\n\nvar DynamicContentBase = function () {\n    function DynamicContentBase(trusting) {\n        classCallCheck(this, DynamicContentBase);\n\n        this.trusting = trusting;\n    }\n\n    DynamicContentBase.prototype.retry = function retry(env, value) {\n        var bounds$$1 = this.bounds;\n\n        var parentElement = bounds$$1.parentElement();\n        var nextSibling = clear(bounds$$1);\n        var stack = NewElementBuilder.forInitialRender(env, { element: parentElement, nextSibling: nextSibling });\n        if (this.trusting) {\n            return stack.__appendTrustingDynamicContent(value);\n        } else {\n            return stack.__appendCautiousDynamicContent(value);\n        }\n    };\n\n    return DynamicContentBase;\n}();\n\nvar DynamicContentWrapper = function () {\n    function DynamicContentWrapper(inner) {\n        classCallCheck(this, DynamicContentWrapper);\n\n        this.inner = inner;\n        this.bounds = inner.bounds;\n    }\n\n    DynamicContentWrapper.prototype.parentElement = function parentElement() {\n        return this.bounds.parentElement();\n    };\n\n    DynamicContentWrapper.prototype.firstNode = function firstNode() {\n        return this.bounds.firstNode();\n    };\n\n    DynamicContentWrapper.prototype.lastNode = function lastNode() {\n        return this.bounds.lastNode();\n    };\n\n    DynamicContentWrapper.prototype.update = function update(env, value) {\n        var inner = this.inner = this.inner.update(env, value);\n        this.bounds = inner.bounds;\n        return this;\n    };\n\n    return DynamicContentWrapper;\n}();\n\nvar DynamicTextContent = function (_DynamicContentBase) {\n    inherits(DynamicTextContent, _DynamicContentBase);\n\n    function DynamicTextContent(bounds, lastValue, trusted) {\n        classCallCheck(this, DynamicTextContent);\n\n        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusted));\n\n        _this.bounds = bounds;\n        _this.lastValue = lastValue;\n        return _this;\n    }\n\n    DynamicTextContent.prototype.update = function update(env, value) {\n        var lastValue = this.lastValue;\n\n        if (value === lastValue) return this;\n        if (isNode(value) || isSafeString(value)) return this.retry(env, value);\n        var normalized = void 0;\n        if (isEmpty(value)) {\n            normalized = '';\n        } else if (isString(value)) {\n            normalized = value;\n        } else {\n            normalized = String(value);\n        }\n        if (normalized !== lastValue) {\n            var textNode = this.bounds.firstNode();\n            textNode.nodeValue = this.lastValue = normalized;\n        }\n        return this;\n    };\n\n    return DynamicTextContent;\n}(DynamicContentBase);\n\nvar DynamicNodeContent = function (_DynamicContentBase) {\n    inherits(DynamicNodeContent, _DynamicContentBase);\n\n    function DynamicNodeContent(bounds, lastValue, trusting) {\n        classCallCheck(this, DynamicNodeContent);\n\n        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusting));\n\n        _this.bounds = bounds;\n        _this.lastValue = lastValue;\n        return _this;\n    }\n\n    DynamicNodeContent.prototype.update = function update(env, value) {\n        var lastValue = this.lastValue;\n\n        if (value === lastValue) return this;\n        return this.retry(env, value);\n    };\n\n    return DynamicNodeContent;\n}(DynamicContentBase);\n\nvar DynamicHTMLContent = function (_DynamicContentBase) {\n    inherits(DynamicHTMLContent, _DynamicContentBase);\n\n    function DynamicHTMLContent(bounds, lastValue, trusted) {\n        classCallCheck(this, DynamicHTMLContent);\n\n        var _this = possibleConstructorReturn(this, _DynamicContentBase.call(this, trusted));\n\n        _this.bounds = bounds;\n        _this.lastValue = lastValue;\n        return _this;\n    }\n\n    DynamicHTMLContent.prototype.update = function update(env, value) {\n        var lastValue = this.lastValue;\n\n        if (value === lastValue) return this;\n        if (isSafeString(value) && value.toHTML() === lastValue.toHTML()) {\n            this.lastValue = value;\n            return this;\n        }\n        return this.retry(env, value);\n    };\n\n    return DynamicHTMLContent;\n}(DynamicContentBase);\n\nvar DynamicTrustedHTMLContent = function (_DynamicContentBase2) {\n    inherits(DynamicTrustedHTMLContent, _DynamicContentBase2);\n\n    function DynamicTrustedHTMLContent(bounds, lastValue, trusted) {\n        classCallCheck(this, DynamicTrustedHTMLContent);\n\n        var _this2 = possibleConstructorReturn(this, _DynamicContentBase2.call(this, trusted));\n\n        _this2.bounds = bounds;\n        _this2.lastValue = lastValue;\n        return _this2;\n    }\n\n    DynamicTrustedHTMLContent.prototype.update = function update(env, value) {\n        var lastValue = this.lastValue;\n\n        if (value === lastValue) return this;\n        var newValue = normalizeTrustedValue(value);\n        if (newValue === lastValue) return this;\n        return this.retry(env, value);\n    };\n\n    return DynamicTrustedHTMLContent;\n}(DynamicContentBase);\n\nvar First = function () {\n    function First(node) {\n        classCallCheck(this, First);\n\n        this.node = node;\n    }\n\n    First.prototype.firstNode = function firstNode() {\n        return this.node;\n    };\n\n    return First;\n}();\n\nvar Last = function () {\n    function Last(node) {\n        classCallCheck(this, Last);\n\n        this.node = node;\n    }\n\n    Last.prototype.lastNode = function lastNode() {\n        return this.node;\n    };\n\n    return Last;\n}();\n\n\nvar NewElementBuilder = function () {\n    function NewElementBuilder(env, parentNode, nextSibling) {\n        classCallCheck(this, NewElementBuilder);\n\n        this.constructing = null;\n        this.operations = null;\n        this.cursorStack = new Stack();\n        this.blockStack = new Stack();\n        this.pushElement(parentNode, nextSibling);\n        this.env = env;\n        this.dom = env.getAppendOperations();\n        this.updateOperations = env.getDOM();\n    }\n\n    NewElementBuilder.forInitialRender = function forInitialRender(env, cursor) {\n        var builder = new this(env, cursor.element, cursor.nextSibling);\n        builder.pushSimpleBlock();\n        return builder;\n    };\n\n    NewElementBuilder.resume = function resume(env, tracker, nextSibling) {\n        var parentNode = tracker.parentElement();\n        var stack = new this(env, parentNode, nextSibling);\n        stack.pushSimpleBlock();\n        stack.pushBlockTracker(tracker);\n        return stack;\n    };\n\n    NewElementBuilder.prototype.expectConstructing = function expectConstructing(method) {\n        return this.constructing;\n    };\n\n    NewElementBuilder.prototype.block = function block() {\n        return this.blockStack.current;\n    };\n\n    NewElementBuilder.prototype.popElement = function popElement() {\n        this.cursorStack.pop();\n        this.cursorStack.current;\n    };\n\n    NewElementBuilder.prototype.pushSimpleBlock = function pushSimpleBlock() {\n        return this.pushBlockTracker(new SimpleBlockTracker(this.element));\n    };\n\n    NewElementBuilder.prototype.pushUpdatableBlock = function pushUpdatableBlock() {\n        return this.pushBlockTracker(new UpdatableBlockTracker(this.element));\n    };\n\n    NewElementBuilder.prototype.pushBlockList = function pushBlockList(list) {\n        return this.pushBlockTracker(new BlockListTracker(this.element, list));\n    };\n\n    NewElementBuilder.prototype.pushBlockTracker = function pushBlockTracker(tracker) {\n        var isRemote = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        var current = this.blockStack.current;\n        if (current !== null) {\n            current.newDestroyable(tracker);\n            if (!isRemote) {\n                current.didAppendBounds(tracker);\n            }\n        }\n        this.__openBlock();\n        this.blockStack.push(tracker);\n        return tracker;\n    };\n\n    NewElementBuilder.prototype.popBlock = function popBlock() {\n        this.block().finalize(this);\n        this.__closeBlock();\n        return this.blockStack.pop();\n    };\n\n    NewElementBuilder.prototype.__openBlock = function __openBlock() {};\n\n    NewElementBuilder.prototype.__closeBlock = function __closeBlock() {};\n    // todo return seems unused\n\n\n    NewElementBuilder.prototype.openElement = function openElement(tag) {\n        var element = this.__openElement(tag);\n        this.constructing = element;\n        return element;\n    };\n\n    NewElementBuilder.prototype.__openElement = function __openElement(tag) {\n        return this.dom.createElement(tag, this.element);\n    };\n\n    NewElementBuilder.prototype.flushElement = function flushElement() {\n        var parent = this.element;\n        var element = this.constructing;\n        this.__flushElement(parent, element);\n        this.constructing = null;\n        this.operations = null;\n        this.pushElement(element, null);\n        this.didOpenElement(element);\n    };\n\n    NewElementBuilder.prototype.__flushElement = function __flushElement(parent, constructing) {\n        this.dom.insertBefore(parent, constructing, this.nextSibling);\n    };\n\n    NewElementBuilder.prototype.closeElement = function closeElement() {\n        this.willCloseElement();\n        this.popElement();\n    };\n\n    NewElementBuilder.prototype.pushRemoteElement = function pushRemoteElement(element, guid) {\n        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        this.__pushRemoteElement(element, guid, nextSibling);\n    };\n\n    NewElementBuilder.prototype.__pushRemoteElement = function __pushRemoteElement(element, _guid, nextSibling) {\n        this.pushElement(element, nextSibling);\n        var tracker = new RemoteBlockTracker(element);\n        this.pushBlockTracker(tracker, true);\n    };\n\n    NewElementBuilder.prototype.popRemoteElement = function popRemoteElement() {\n        this.popBlock();\n        this.popElement();\n    };\n\n    NewElementBuilder.prototype.pushElement = function pushElement(element, nextSibling) {\n        this.cursorStack.push(new Cursor(element, nextSibling));\n    };\n\n    NewElementBuilder.prototype.didAddDestroyable = function didAddDestroyable(d) {\n        this.block().newDestroyable(d);\n    };\n\n    NewElementBuilder.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {\n        this.block().didAppendBounds(bounds$$1);\n        return bounds$$1;\n    };\n\n    NewElementBuilder.prototype.didAppendNode = function didAppendNode(node) {\n        this.block().didAppendNode(node);\n        return node;\n    };\n\n    NewElementBuilder.prototype.didOpenElement = function didOpenElement(element) {\n        this.block().openElement(element);\n        return element;\n    };\n\n    NewElementBuilder.prototype.willCloseElement = function willCloseElement() {\n        this.block().closeElement();\n    };\n\n    NewElementBuilder.prototype.appendText = function appendText(string) {\n        return this.didAppendNode(this.__appendText(string));\n    };\n\n    NewElementBuilder.prototype.__appendText = function __appendText(text) {\n        var dom = this.dom,\n            element = this.element,\n            nextSibling = this.nextSibling;\n\n        var node = dom.createTextNode(text);\n        dom.insertBefore(element, node, nextSibling);\n        return node;\n    };\n\n    NewElementBuilder.prototype.__appendNode = function __appendNode(node) {\n        this.dom.insertBefore(this.element, node, this.nextSibling);\n        return node;\n    };\n\n    NewElementBuilder.prototype.__appendFragment = function __appendFragment(fragment) {\n        var first = fragment.firstChild;\n        if (first) {\n            var ret = bounds(this.element, first, fragment.lastChild);\n            this.dom.insertBefore(this.element, fragment, this.nextSibling);\n            return ret;\n        } else {\n            return single(this.element, this.__appendComment(''));\n        }\n    };\n\n    NewElementBuilder.prototype.__appendHTML = function __appendHTML(html) {\n        return this.dom.insertHTMLBefore(this.element, this.nextSibling, html);\n    };\n\n    NewElementBuilder.prototype.appendTrustingDynamicContent = function appendTrustingDynamicContent(value) {\n        var wrapper = new DynamicContentWrapper(this.__appendTrustingDynamicContent(value));\n        this.didAppendBounds(wrapper);\n        return wrapper;\n    };\n\n    NewElementBuilder.prototype.__appendTrustingDynamicContent = function __appendTrustingDynamicContent(value) {\n        if (isString(value)) {\n            return this.trustedContent(value);\n        } else if (isEmpty(value)) {\n            return this.trustedContent('');\n        } else if (isSafeString(value)) {\n            return this.trustedContent(value.toHTML());\n        }\n        if (isFragment(value)) {\n            var _bounds2 = this.__appendFragment(value);\n            return new DynamicNodeContent(_bounds2, value, true);\n        } else if (isNode(value)) {\n            var node = this.__appendNode(value);\n            return new DynamicNodeContent(single(this.element, node), node, true);\n        }\n        return this.trustedContent(String(value));\n    };\n\n    NewElementBuilder.prototype.appendCautiousDynamicContent = function appendCautiousDynamicContent(value) {\n        var wrapper = new DynamicContentWrapper(this.__appendCautiousDynamicContent(value));\n        this.didAppendBounds(wrapper.bounds);\n        return wrapper;\n    };\n\n    NewElementBuilder.prototype.__appendCautiousDynamicContent = function __appendCautiousDynamicContent(value) {\n        if (isString(value)) {\n            return this.untrustedContent(value);\n        } else if (isEmpty(value)) {\n            return this.untrustedContent('');\n        } else if (isFragment(value)) {\n            var _bounds3 = this.__appendFragment(value);\n            return new DynamicNodeContent(_bounds3, value, false);\n        } else if (isNode(value)) {\n            var node = this.__appendNode(value);\n            return new DynamicNodeContent(single(this.element, node), node, false);\n        } else if (isSafeString(value)) {\n            var normalized = value.toHTML();\n            var _bounds4 = this.__appendHTML(normalized);\n            // let bounds = this.dom.insertHTMLBefore(this.element, this.nextSibling, normalized);\n            return new DynamicHTMLContent(_bounds4, value, false);\n        }\n        return this.untrustedContent(String(value));\n    };\n\n    NewElementBuilder.prototype.trustedContent = function trustedContent(value) {\n        var bounds$$1 = this.__appendHTML(value);\n        return new DynamicTrustedHTMLContent(bounds$$1, value, true);\n    };\n\n    NewElementBuilder.prototype.untrustedContent = function untrustedContent(value) {\n        var textNode = this.__appendText(value);\n        var bounds$$1 = single(this.element, textNode);\n        return new DynamicTextContent(bounds$$1, value, false);\n    };\n\n    NewElementBuilder.prototype.appendComment = function appendComment(string) {\n        return this.didAppendNode(this.__appendComment(string));\n    };\n\n    NewElementBuilder.prototype.__appendComment = function __appendComment(string) {\n        var dom = this.dom,\n            element = this.element,\n            nextSibling = this.nextSibling;\n\n        var node = dom.createComment(string);\n        dom.insertBefore(element, node, nextSibling);\n        return node;\n    };\n\n    NewElementBuilder.prototype.__setAttribute = function __setAttribute(name, value, namespace) {\n        this.dom.setAttribute(this.constructing, name, value, namespace);\n    };\n\n    NewElementBuilder.prototype.__setProperty = function __setProperty(name, value) {\n        this.constructing[name] = value;\n    };\n\n    NewElementBuilder.prototype.setStaticAttribute = function setStaticAttribute(name, value, namespace) {\n        this.__setAttribute(name, value, namespace);\n    };\n\n    NewElementBuilder.prototype.setDynamicAttribute = function setDynamicAttribute(name, value, trusting, namespace) {\n        var element = this.constructing;\n        var DynamicAttribute = this.env.attributeFor(element, name, trusting, namespace);\n        var attribute = new DynamicAttribute({ element: element, name: name, namespace: namespace || null });\n        attribute.set(this, value, this.env);\n        return attribute;\n    };\n\n    createClass(NewElementBuilder, [{\n        key: 'element',\n        get: function get$$1() {\n            return this.cursorStack.current.element;\n        }\n    }, {\n        key: 'nextSibling',\n        get: function get$$1() {\n            return this.cursorStack.current.nextSibling;\n        }\n    }]);\n    return NewElementBuilder;\n}();\nvar SimpleBlockTracker = function () {\n    function SimpleBlockTracker(parent) {\n        classCallCheck(this, SimpleBlockTracker);\n\n        this.parent = parent;\n        this.first = null;\n        this.last = null;\n        this.destroyables = null;\n        this.nesting = 0;\n    }\n\n    SimpleBlockTracker.prototype.destroy = function destroy() {\n        var destroyables = this.destroyables;\n\n        if (destroyables && destroyables.length) {\n            for (var i = 0; i < destroyables.length; i++) {\n                destroyables[i].destroy();\n            }\n        }\n    };\n\n    SimpleBlockTracker.prototype.parentElement = function parentElement() {\n        return this.parent;\n    };\n\n    SimpleBlockTracker.prototype.firstNode = function firstNode() {\n        return this.first && this.first.firstNode();\n    };\n\n    SimpleBlockTracker.prototype.lastNode = function lastNode() {\n        return this.last && this.last.lastNode();\n    };\n\n    SimpleBlockTracker.prototype.openElement = function openElement(element) {\n        this.didAppendNode(element);\n        this.nesting++;\n    };\n\n    SimpleBlockTracker.prototype.closeElement = function closeElement() {\n        this.nesting--;\n    };\n\n    SimpleBlockTracker.prototype.didAppendNode = function didAppendNode(node) {\n        if (this.nesting !== 0) return;\n        if (!this.first) {\n            this.first = new First(node);\n        }\n        this.last = new Last(node);\n    };\n\n    SimpleBlockTracker.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {\n        if (this.nesting !== 0) return;\n        if (!this.first) {\n            this.first = bounds$$1;\n        }\n        this.last = bounds$$1;\n    };\n\n    SimpleBlockTracker.prototype.newDestroyable = function newDestroyable(d) {\n        this.destroyables = this.destroyables || [];\n        this.destroyables.push(d);\n    };\n\n    SimpleBlockTracker.prototype.finalize = function finalize(stack) {\n        if (!this.first) {\n            stack.appendComment('');\n        }\n    };\n\n    return SimpleBlockTracker;\n}();\nvar RemoteBlockTracker = function (_SimpleBlockTracker) {\n    inherits(RemoteBlockTracker, _SimpleBlockTracker);\n\n    function RemoteBlockTracker() {\n        classCallCheck(this, RemoteBlockTracker);\n        return possibleConstructorReturn(this, _SimpleBlockTracker.apply(this, arguments));\n    }\n\n    RemoteBlockTracker.prototype.destroy = function destroy() {\n        _SimpleBlockTracker.prototype.destroy.call(this);\n        clear(this);\n    };\n\n    return RemoteBlockTracker;\n}(SimpleBlockTracker);\nvar UpdatableBlockTracker = function (_SimpleBlockTracker2) {\n    inherits(UpdatableBlockTracker, _SimpleBlockTracker2);\n\n    function UpdatableBlockTracker() {\n        classCallCheck(this, UpdatableBlockTracker);\n        return possibleConstructorReturn(this, _SimpleBlockTracker2.apply(this, arguments));\n    }\n\n    UpdatableBlockTracker.prototype.reset = function reset(env) {\n        var destroyables = this.destroyables;\n\n        if (destroyables && destroyables.length) {\n            for (var i = 0; i < destroyables.length; i++) {\n                env.didDestroy(destroyables[i]);\n            }\n        }\n        var nextSibling = clear(this);\n        this.first = null;\n        this.last = null;\n        this.destroyables = null;\n        this.nesting = 0;\n        return nextSibling;\n    };\n\n    return UpdatableBlockTracker;\n}(SimpleBlockTracker);\n\nvar BlockListTracker = function () {\n    function BlockListTracker(parent, boundList) {\n        classCallCheck(this, BlockListTracker);\n\n        this.parent = parent;\n        this.boundList = boundList;\n        this.parent = parent;\n        this.boundList = boundList;\n    }\n\n    BlockListTracker.prototype.destroy = function destroy() {\n        this.boundList.forEachNode(function (node) {\n            return node.destroy();\n        });\n    };\n\n    BlockListTracker.prototype.parentElement = function parentElement() {\n        return this.parent;\n    };\n\n    BlockListTracker.prototype.firstNode = function firstNode() {\n        var head = this.boundList.head();\n        return head && head.firstNode();\n    };\n\n    BlockListTracker.prototype.lastNode = function lastNode() {\n        var tail = this.boundList.tail();\n        return tail && tail.lastNode();\n    };\n\n    BlockListTracker.prototype.openElement = function openElement(_element) {\n        false && debugAssert(false, 'Cannot openElement directly inside a block list');\n    };\n\n    BlockListTracker.prototype.closeElement = function closeElement() {\n        false && debugAssert(false, 'Cannot closeElement directly inside a block list');\n    };\n\n    BlockListTracker.prototype.didAppendNode = function didAppendNode(_node) {\n        false && debugAssert(false, 'Cannot create a new node directly inside a block list');\n    };\n\n    BlockListTracker.prototype.didAppendBounds = function didAppendBounds(_bounds) {};\n\n    BlockListTracker.prototype.newDestroyable = function newDestroyable(_d) {};\n\n    BlockListTracker.prototype.finalize = function finalize(_stack) {};\n\n    return BlockListTracker;\n}();\n\nfunction clientBuilder(env, cursor) {\n    return NewElementBuilder.forInitialRender(env, cursor);\n}\n\nvar UpdatingVM = function () {\n    function UpdatingVM(env, program, _ref) {\n        var _ref$alwaysRevalidate = _ref.alwaysRevalidate,\n            alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;\n        classCallCheck(this, UpdatingVM);\n\n        this.frameStack = new Stack();\n        this.env = env;\n        this.constants = program.constants;\n        this.dom = env.getDOM();\n        this.alwaysRevalidate = alwaysRevalidate;\n    }\n\n    UpdatingVM.prototype.execute = function execute(opcodes, handler) {\n        var frameStack = this.frameStack;\n\n        this.try(opcodes, handler);\n        while (true) {\n            if (frameStack.isEmpty()) break;\n            var opcode = this.frame.nextStatement();\n            if (opcode === null) {\n                this.frameStack.pop();\n                continue;\n            }\n            opcode.evaluate(this);\n        }\n    };\n\n    UpdatingVM.prototype.goto = function goto(op) {\n        this.frame.goto(op);\n    };\n\n    UpdatingVM.prototype.try = function _try(ops, handler) {\n        this.frameStack.push(new UpdatingVMFrame(this, ops, handler));\n    };\n\n    UpdatingVM.prototype.throw = function _throw() {\n        this.frame.handleException();\n        this.frameStack.pop();\n    };\n\n    createClass(UpdatingVM, [{\n        key: 'frame',\n        get: function get$$1() {\n            return this.frameStack.current;\n        }\n    }]);\n    return UpdatingVM;\n}();\n\nvar BlockOpcode = function (_UpdatingOpcode) {\n    inherits(BlockOpcode, _UpdatingOpcode);\n\n    function BlockOpcode(start, state, bounds$$1, children) {\n        classCallCheck(this, BlockOpcode);\n\n        var _this = possibleConstructorReturn(this, _UpdatingOpcode.call(this));\n\n        _this.start = start;\n        _this.state = state;\n        _this.type = \"block\";\n        _this.next = null;\n        _this.prev = null;\n        _this.children = children;\n        _this.bounds = bounds$$1;\n        return _this;\n    }\n\n    BlockOpcode.prototype.parentElement = function parentElement() {\n        return this.bounds.parentElement();\n    };\n\n    BlockOpcode.prototype.firstNode = function firstNode() {\n        return this.bounds.firstNode();\n    };\n\n    BlockOpcode.prototype.lastNode = function lastNode() {\n        return this.bounds.lastNode();\n    };\n\n    BlockOpcode.prototype.evaluate = function evaluate(vm) {\n        vm.try(this.children, null);\n    };\n\n    BlockOpcode.prototype.destroy = function destroy() {\n        this.bounds.destroy();\n    };\n\n    BlockOpcode.prototype.didDestroy = function didDestroy() {\n        this.state.env.didDestroy(this.bounds);\n    };\n\n    return BlockOpcode;\n}(UpdatingOpcode);\nvar TryOpcode = function (_BlockOpcode) {\n    inherits(TryOpcode, _BlockOpcode);\n\n    function TryOpcode(start, state, bounds$$1, children) {\n        classCallCheck(this, TryOpcode);\n\n        var _this2 = possibleConstructorReturn(this, _BlockOpcode.call(this, start, state, bounds$$1, children));\n\n        _this2.type = \"try\";\n        _this2.tag = _this2._tag = UpdatableTag.create(CONSTANT_TAG);\n        return _this2;\n    }\n\n    TryOpcode.prototype.didInitializeChildren = function didInitializeChildren() {\n        this._tag.inner.update(combineSlice(this.children));\n    };\n\n    TryOpcode.prototype.evaluate = function evaluate(vm) {\n        vm.try(this.children, this);\n    };\n\n    TryOpcode.prototype.handleException = function handleException() {\n        var _this3 = this;\n\n        var state = this.state,\n            bounds$$1 = this.bounds,\n            children = this.children,\n            start = this.start,\n            prev = this.prev,\n            next = this.next;\n\n        children.clear();\n        var elementStack = NewElementBuilder.resume(state.env, bounds$$1, bounds$$1.reset(state.env));\n        var vm = VM.resume(state, elementStack);\n        var updating = new LinkedList();\n        vm.execute(start, function (vm) {\n            vm.stack = EvaluationStack.restore(state.stack);\n            vm.updatingOpcodeStack.push(updating);\n            vm.updateWith(_this3);\n            vm.updatingOpcodeStack.push(children);\n        });\n        this.prev = prev;\n        this.next = next;\n    };\n\n    return TryOpcode;\n}(BlockOpcode);\n\nvar ListRevalidationDelegate = function () {\n    function ListRevalidationDelegate(opcode, marker) {\n        classCallCheck(this, ListRevalidationDelegate);\n\n        this.opcode = opcode;\n        this.marker = marker;\n        this.didInsert = false;\n        this.didDelete = false;\n        this.map = opcode.map;\n        this.updating = opcode['children'];\n    }\n\n    ListRevalidationDelegate.prototype.insert = function insert(key, item, memo, before) {\n        var map$$1 = this.map,\n            opcode = this.opcode,\n            updating = this.updating;\n\n        var nextSibling = null;\n        var reference = null;\n        if (before) {\n            reference = map$$1[before];\n            nextSibling = reference['bounds'].firstNode();\n        } else {\n            nextSibling = this.marker;\n        }\n        var vm = opcode.vmForInsertion(nextSibling);\n        var tryOpcode = null;\n        var start = opcode.start;\n\n        vm.execute(start, function (vm) {\n            map$$1[key] = tryOpcode = vm.iterate(memo, item);\n            vm.updatingOpcodeStack.push(new LinkedList());\n            vm.updateWith(tryOpcode);\n            vm.updatingOpcodeStack.push(tryOpcode.children);\n        });\n        updating.insertBefore(tryOpcode, reference);\n        this.didInsert = true;\n    };\n\n    ListRevalidationDelegate.prototype.retain = function retain(_key, _item, _memo) {};\n\n    ListRevalidationDelegate.prototype.move = function move$$1(key, _item, _memo, before) {\n        var map$$1 = this.map,\n            updating = this.updating;\n\n        var entry = map$$1[key];\n        var reference = map$$1[before] || null;\n        if (before) {\n            move(entry, reference.firstNode());\n        } else {\n            move(entry, this.marker);\n        }\n        updating.remove(entry);\n        updating.insertBefore(entry, reference);\n    };\n\n    ListRevalidationDelegate.prototype.delete = function _delete(key) {\n        var map$$1 = this.map;\n\n        var opcode = map$$1[key];\n        opcode.didDestroy();\n        clear(opcode);\n        this.updating.remove(opcode);\n        delete map$$1[key];\n        this.didDelete = true;\n    };\n\n    ListRevalidationDelegate.prototype.done = function done() {\n        this.opcode.didInitializeChildren(this.didInsert || this.didDelete);\n    };\n\n    return ListRevalidationDelegate;\n}();\n\nvar ListBlockOpcode = function (_BlockOpcode2) {\n    inherits(ListBlockOpcode, _BlockOpcode2);\n\n    function ListBlockOpcode(start, state, bounds$$1, children, artifacts) {\n        classCallCheck(this, ListBlockOpcode);\n\n        var _this4 = possibleConstructorReturn(this, _BlockOpcode2.call(this, start, state, bounds$$1, children));\n\n        _this4.type = \"list-block\";\n        _this4.map = dict();\n        _this4.lastIterated = INITIAL;\n        _this4.artifacts = artifacts;\n        var _tag = _this4._tag = UpdatableTag.create(CONSTANT_TAG);\n        _this4.tag = combine([artifacts.tag, _tag]);\n        return _this4;\n    }\n\n    ListBlockOpcode.prototype.didInitializeChildren = function didInitializeChildren() {\n        var listDidChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n        this.lastIterated = this.artifacts.tag.value();\n        if (listDidChange) {\n            this._tag.inner.update(combineSlice(this.children));\n        }\n    };\n\n    ListBlockOpcode.prototype.evaluate = function evaluate(vm) {\n        var artifacts = this.artifacts,\n            lastIterated = this.lastIterated;\n\n        if (!artifacts.tag.validate(lastIterated)) {\n            var bounds$$1 = this.bounds;\n            var dom = vm.dom;\n\n            var marker = dom.createComment('');\n            dom.insertAfter(bounds$$1.parentElement(), marker, bounds$$1.lastNode());\n            var target = new ListRevalidationDelegate(this, marker);\n            var synchronizer = new IteratorSynchronizer({ target: target, artifacts: artifacts });\n            synchronizer.sync();\n            this.parentElement().removeChild(marker);\n        }\n        // Run now-updated updating opcodes\n        _BlockOpcode2.prototype.evaluate.call(this, vm);\n    };\n\n    ListBlockOpcode.prototype.vmForInsertion = function vmForInsertion(nextSibling) {\n        var bounds$$1 = this.bounds,\n            state = this.state;\n\n        var elementStack = NewElementBuilder.forInitialRender(state.env, { element: bounds$$1.parentElement(), nextSibling: nextSibling });\n        return VM.resume(state, elementStack);\n    };\n\n    return ListBlockOpcode;\n}(BlockOpcode);\n\nvar UpdatingVMFrame = function () {\n    function UpdatingVMFrame(vm, ops, exceptionHandler) {\n        classCallCheck(this, UpdatingVMFrame);\n\n        this.vm = vm;\n        this.ops = ops;\n        this.exceptionHandler = exceptionHandler;\n        this.vm = vm;\n        this.ops = ops;\n        this.current = ops.head();\n    }\n\n    UpdatingVMFrame.prototype.goto = function goto(op) {\n        this.current = op;\n    };\n\n    UpdatingVMFrame.prototype.nextStatement = function nextStatement() {\n        var current = this.current,\n            ops = this.ops;\n\n        if (current) this.current = ops.nextNode(current);\n        return current;\n    };\n\n    UpdatingVMFrame.prototype.handleException = function handleException() {\n        if (this.exceptionHandler) {\n            this.exceptionHandler.handleException();\n        }\n    };\n\n    return UpdatingVMFrame;\n}();\n\nvar RenderResult = function () {\n    function RenderResult(env, program, updating, bounds$$1) {\n        classCallCheck(this, RenderResult);\n\n        this.env = env;\n        this.program = program;\n        this.updating = updating;\n        this.bounds = bounds$$1;\n    }\n\n    RenderResult.prototype.rerender = function rerender() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { alwaysRevalidate: false },\n            _ref$alwaysRevalidate = _ref.alwaysRevalidate,\n            alwaysRevalidate = _ref$alwaysRevalidate === undefined ? false : _ref$alwaysRevalidate;\n\n        var env = this.env,\n            program = this.program,\n            updating = this.updating;\n\n        var vm = new UpdatingVM(env, program, { alwaysRevalidate: alwaysRevalidate });\n        vm.execute(updating, this);\n    };\n\n    RenderResult.prototype.parentElement = function parentElement() {\n        return this.bounds.parentElement();\n    };\n\n    RenderResult.prototype.firstNode = function firstNode() {\n        return this.bounds.firstNode();\n    };\n\n    RenderResult.prototype.lastNode = function lastNode() {\n        return this.bounds.lastNode();\n    };\n\n    RenderResult.prototype.handleException = function handleException() {\n        throw \"this should never happen\";\n    };\n\n    RenderResult.prototype.destroy = function destroy() {\n        this.bounds.destroy();\n        clear(this.bounds);\n    };\n\n    return RenderResult;\n}();\n\nvar EvaluationStack = function () {\n    function EvaluationStack(stack, fp, sp) {\n        classCallCheck(this, EvaluationStack);\n\n        this.stack = stack;\n        this.fp = fp;\n        this.sp = sp;\n        \n    }\n\n    EvaluationStack.empty = function empty() {\n        return new this([], 0, -1);\n    };\n\n    EvaluationStack.restore = function restore(snapshot) {\n        return new this(snapshot.slice(), 0, snapshot.length - 1);\n    };\n\n    EvaluationStack.prototype.push = function push(value) {\n        this.stack[++this.sp] = value;\n    };\n\n    EvaluationStack.prototype.dup = function dup() {\n        var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.sp;\n\n        this.push(this.stack[position]);\n    };\n\n    EvaluationStack.prototype.pop = function pop() {\n        var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n        var top = this.stack[this.sp];\n        this.sp -= n;\n        return top;\n    };\n\n    EvaluationStack.prototype.peek = function peek() {\n        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n        return this.stack[this.sp - offset];\n    };\n\n    EvaluationStack.prototype.get = function get$$1(offset) {\n        var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.fp;\n\n        return this.stack[base + offset];\n    };\n\n    EvaluationStack.prototype.set = function set$$1(value, offset) {\n        var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.fp;\n\n        this.stack[base + offset] = value;\n    };\n\n    EvaluationStack.prototype.slice = function slice(start, end) {\n        return this.stack.slice(start, end);\n    };\n\n    EvaluationStack.prototype.capture = function capture(items) {\n        var end = this.sp + 1;\n        var start = end - items;\n        return this.stack.slice(start, end);\n    };\n\n    EvaluationStack.prototype.reset = function reset() {\n        this.stack.length = 0;\n    };\n\n    EvaluationStack.prototype.toArray = function toArray$$1() {\n        return this.stack.slice(this.fp, this.sp + 1);\n    };\n\n    return EvaluationStack;\n}();\n\nvar VM = function () {\n    function VM(program, env, scope, dynamicScope, elementStack) {\n        classCallCheck(this, VM);\n\n        this.program = program;\n        this.env = env;\n        this.elementStack = elementStack;\n        this.dynamicScopeStack = new Stack();\n        this.scopeStack = new Stack();\n        this.updatingOpcodeStack = new Stack();\n        this.cacheGroups = new Stack();\n        this.listBlockStack = new Stack();\n        this.stack = EvaluationStack.empty();\n        /* Registers */\n        this._pc = -1;\n        this.ra = -1;\n        this.currentOpSize = 0;\n        this.s0 = null;\n        this.s1 = null;\n        this.t0 = null;\n        this.t1 = null;\n        this.v0 = null;\n        this.env = env;\n        this.heap = program.heap;\n        this.constants = program.constants;\n        this.elementStack = elementStack;\n        this.scopeStack.push(scope);\n        this.dynamicScopeStack.push(dynamicScope);\n    }\n\n    // Fetch a value from a register onto the stack\n    VM.prototype.fetch = function fetch(register) {\n        this.stack.push(this[Register[register]]);\n    };\n    // Load a value from the stack into a register\n\n\n    VM.prototype.load = function load(register) {\n        this[Register[register]] = this.stack.pop();\n    };\n    // Fetch a value from a register\n\n\n    VM.prototype.fetchValue = function fetchValue(register) {\n        return this[Register[register]];\n    };\n    // Load a value into a register\n\n\n    VM.prototype.loadValue = function loadValue(register, value) {\n        this[Register[register]] = value;\n    };\n    // Start a new frame and save $ra and $fp on the stack\n\n\n    VM.prototype.pushFrame = function pushFrame() {\n        this.stack.push(this.ra);\n        this.stack.push(this.fp);\n        this.fp = this.sp - 1;\n    };\n    // Restore $ra, $sp and $fp\n\n\n    VM.prototype.popFrame = function popFrame() {\n        this.sp = this.fp - 1;\n        this.ra = this.stack.get(0);\n        this.fp = this.stack.get(1);\n    };\n    // Jump to an address in `program`\n\n\n    VM.prototype.goto = function goto(offset) {\n        var addr = this.pc + offset - this.currentOpSize;\n        this.pc = addr;\n    };\n    // Save $pc into $ra, then jump to a new address in `program` (jal in MIPS)\n\n\n    VM.prototype.call = function call(handle) {\n        this.ra = this.pc;\n        this.pc = this.heap.getaddr(handle);\n    };\n    // Put a specific `program` address in $ra\n\n\n    VM.prototype.returnTo = function returnTo(offset) {\n        var addr = this.pc + offset - this.currentOpSize;\n        this.ra = addr;\n    };\n    // Return to the `program` address stored in $ra\n\n\n    VM.prototype.return = function _return() {\n        this.pc = this.ra;\n    };\n\n    VM.initial = function initial(program, env, self, args, dynamicScope, elementStack, handle) {\n        var scopeSize = program.heap.scopesizeof(handle);\n        var scope = Scope.root(self, scopeSize);\n        if (args) {}\n        var vm = new VM(program, env, scope, dynamicScope, elementStack);\n        vm.pc = vm.heap.getaddr(handle);\n        vm.updatingOpcodeStack.push(new LinkedList());\n        return vm;\n    };\n\n    VM.resume = function resume(_ref, stack) {\n        var program = _ref.program,\n            env = _ref.env,\n            scope = _ref.scope,\n            dynamicScope = _ref.dynamicScope;\n\n        return new VM(program, env, scope, dynamicScope, stack);\n    };\n\n    VM.prototype.capture = function capture(args) {\n        return {\n            env: this.env,\n            program: this.program,\n            dynamicScope: this.dynamicScope(),\n            scope: this.scope(),\n            stack: this.stack.capture(args)\n        };\n    };\n\n    VM.prototype.beginCacheGroup = function beginCacheGroup() {\n        this.cacheGroups.push(this.updating().tail());\n    };\n\n    VM.prototype.commitCacheGroup = function commitCacheGroup() {\n        //        JumpIfNotModified(END)\n        //        (head)\n        //        (....)\n        //        (tail)\n        //        DidModify\n        // END:   Noop\n        var END = new LabelOpcode(\"END\");\n        var opcodes = this.updating();\n        var marker = this.cacheGroups.pop();\n        var head = marker ? opcodes.nextNode(marker) : opcodes.head();\n        var tail = opcodes.tail();\n        var tag = combineSlice(new ListSlice(head, tail));\n        var guard = new JumpIfNotModifiedOpcode(tag, END);\n        opcodes.insertBefore(guard, head);\n        opcodes.append(new DidModifyOpcode(guard));\n        opcodes.append(END);\n    };\n\n    VM.prototype.enter = function enter(args) {\n        var updating = new LinkedList();\n        var state = this.capture(args);\n        var tracker = this.elements().pushUpdatableBlock();\n        var tryOpcode = new TryOpcode(this.heap.gethandle(this.pc), state, tracker, updating);\n        this.didEnter(tryOpcode);\n    };\n\n    VM.prototype.iterate = function iterate(memo, value) {\n        var stack = this.stack;\n        stack.push(value);\n        stack.push(memo);\n        var state = this.capture(2);\n        var tracker = this.elements().pushUpdatableBlock();\n        // let ip = this.ip;\n        // this.ip = end + 4;\n        // this.frames.push(ip);\n        return new TryOpcode(this.heap.gethandle(this.pc), state, tracker, new LinkedList());\n    };\n\n    VM.prototype.enterItem = function enterItem(key, opcode) {\n        this.listBlock().map[key] = opcode;\n        this.didEnter(opcode);\n    };\n\n    VM.prototype.enterList = function enterList(relativeStart) {\n        var updating = new LinkedList();\n        var state = this.capture(0);\n        var tracker = this.elements().pushBlockList(updating);\n        var artifacts = this.stack.peek().artifacts;\n        var addr = this.pc + relativeStart - this.currentOpSize;\n        var start = this.heap.gethandle(addr);\n        var opcode = new ListBlockOpcode(start, state, tracker, updating, artifacts);\n        this.listBlockStack.push(opcode);\n        this.didEnter(opcode);\n    };\n\n    VM.prototype.didEnter = function didEnter(opcode) {\n        this.updateWith(opcode);\n        this.updatingOpcodeStack.push(opcode.children);\n    };\n\n    VM.prototype.exit = function exit() {\n        this.elements().popBlock();\n        this.updatingOpcodeStack.pop();\n        var parent = this.updating().tail();\n        parent.didInitializeChildren();\n    };\n\n    VM.prototype.exitList = function exitList() {\n        this.exit();\n        this.listBlockStack.pop();\n    };\n\n    VM.prototype.updateWith = function updateWith(opcode) {\n        this.updating().append(opcode);\n    };\n\n    VM.prototype.listBlock = function listBlock() {\n        return this.listBlockStack.current;\n    };\n\n    VM.prototype.updating = function updating() {\n        return this.updatingOpcodeStack.current;\n    };\n\n    VM.prototype.elements = function elements() {\n        return this.elementStack;\n    };\n\n    VM.prototype.scope = function scope() {\n        return this.scopeStack.current;\n    };\n\n    VM.prototype.dynamicScope = function dynamicScope() {\n        return this.dynamicScopeStack.current;\n    };\n\n    VM.prototype.pushChildScope = function pushChildScope() {\n        this.scopeStack.push(this.scope().child());\n    };\n\n    VM.prototype.pushDynamicScope = function pushDynamicScope() {\n        var child = this.dynamicScope().child();\n        this.dynamicScopeStack.push(child);\n        return child;\n    };\n\n    VM.prototype.pushRootScope = function pushRootScope(size, bindCaller) {\n        var scope = Scope.sized(size);\n        if (bindCaller) scope.bindCallerScope(this.scope());\n        this.scopeStack.push(scope);\n        return scope;\n    };\n\n    VM.prototype.pushScope = function pushScope(scope) {\n        this.scopeStack.push(scope);\n    };\n\n    VM.prototype.popScope = function popScope() {\n        this.scopeStack.pop();\n    };\n\n    VM.prototype.popDynamicScope = function popDynamicScope() {\n        this.dynamicScopeStack.pop();\n    };\n\n    VM.prototype.newDestroyable = function newDestroyable(d) {\n        this.elements().didAddDestroyable(d);\n    };\n    /// SCOPE HELPERS\n\n\n    VM.prototype.getSelf = function getSelf() {\n        return this.scope().getSelf();\n    };\n\n    VM.prototype.referenceForSymbol = function referenceForSymbol(symbol) {\n        return this.scope().getSymbol(symbol);\n    };\n    /// EXECUTION\n\n\n    VM.prototype.execute = function execute(start, initialize) {\n        this.pc = this.heap.getaddr(start);\n        if (initialize) initialize(this);\n        var result = void 0;\n        while (true) {\n            result = this.next();\n            if (result.done) break;\n        }\n        return result.value;\n    };\n\n    VM.prototype.next = function next() {\n        var env = this.env,\n            program = this.program,\n            updatingOpcodeStack = this.updatingOpcodeStack,\n            elementStack = this.elementStack;\n\n        var opcode = this.nextStatement();\n        var result = void 0;\n        if (opcode !== null) {\n            APPEND_OPCODES.evaluate(this, opcode, opcode.type);\n            result = { done: false, value: null };\n        } else {\n            // Unload the stack\n            this.stack.reset();\n            result = {\n                done: true,\n                value: new RenderResult(env, program, updatingOpcodeStack.pop(), elementStack.popBlock())\n            };\n        }\n        return result;\n    };\n\n    VM.prototype.nextStatement = function nextStatement() {\n        var pc = this.pc,\n            program = this.program;\n\n        if (pc === -1) {\n            return null;\n        }\n        // We have to save off the current operations size so that\n        // when we do a jump we can calculate the correct offset\n        // to where we are going. We can't simply ask for the size\n        // in a jump because we have have already incremented the\n        // program counter to the next instruction prior to executing.\n\n        var _program$opcode = this.program.opcode(pc),\n            size = _program$opcode.size;\n\n        var operationSize = this.currentOpSize = size;\n        this.pc += operationSize;\n        return program.opcode(pc);\n    };\n\n    VM.prototype.bindDynamicScope = function bindDynamicScope(names) {\n        var scope = this.dynamicScope();\n        for (var i = names.length - 1; i >= 0; i--) {\n            var name = this.constants.getString(names[i]);\n            scope.set(name, this.stack.pop());\n        }\n    };\n\n    createClass(VM, [{\n        key: 'pc',\n        get: function get$$1() {\n            return this._pc;\n        },\n        set: function set$$1(value) {\n            false && debugAssert(typeof value === 'number' && value >= -1, 'invalid pc: ' + value);\n\n            this._pc = value;\n        }\n    }, {\n        key: 'fp',\n        get: function get$$1() {\n            return this.stack.fp;\n        },\n        set: function set$$1(fp) {\n            this.stack.fp = fp;\n        }\n    }, {\n        key: 'sp',\n        get: function get$$1() {\n            return this.stack.sp;\n        },\n        set: function set$$1(sp) {\n            this.stack.sp = sp;\n        }\n    }]);\n    return VM;\n}();\n\nvar TemplateIterator = function () {\n    function TemplateIterator(vm) {\n        classCallCheck(this, TemplateIterator);\n\n        this.vm = vm;\n    }\n\n    TemplateIterator.prototype.next = function next() {\n        return this.vm.next();\n    };\n\n    return TemplateIterator;\n}();\nvar clientId = 0;\nfunction templateFactory(_ref) {\n    var templateId = _ref.id,\n        meta = _ref.meta,\n        block = _ref.block;\n\n    var parsedBlock = void 0;\n    var id = templateId || 'client-' + clientId++;\n    var create = function create(options, envMeta) {\n        var newMeta = envMeta ? assign({}, envMeta, meta) : meta;\n        if (!parsedBlock) {\n            parsedBlock = JSON.parse(block);\n        }\n        return new ScannableTemplate(options, { id: id, block: parsedBlock, referrer: newMeta });\n    };\n    return { id: id, meta: meta, create: create };\n}\nvar ScannableTemplate = function () {\n    function ScannableTemplate(options, parsedLayout) {\n        classCallCheck(this, ScannableTemplate);\n\n        this.options = options;\n        this.parsedLayout = parsedLayout;\n        this.layout = null;\n        this.partial = null;\n        var block = parsedLayout.block;\n\n        this.symbols = block.symbols;\n        this.hasEval = block.hasEval;\n        this.statements = block.statements;\n        this.referrer = parsedLayout.referrer;\n        this.id = parsedLayout.id || 'client-' + clientId++;\n    }\n\n    ScannableTemplate.prototype.renderLayout = function renderLayout(options) {\n        var env = options.env,\n            self = options.self,\n            dynamicScope = options.dynamicScope,\n            _options$args = options.args,\n            args = _options$args === undefined ? EMPTY_ARGS : _options$args,\n            builder = options.builder;\n\n        var layout = this.asLayout();\n        var handle = layout.compile();\n        var vm = VM.initial(this.options.program, env, self, args, dynamicScope, builder, handle);\n        return new TemplateIterator(vm);\n    };\n\n    ScannableTemplate.prototype.asLayout = function asLayout() {\n        if (this.layout) return this.layout;\n        return this.layout = compilable(this.parsedLayout, this.options, false);\n    };\n\n    ScannableTemplate.prototype.asPartial = function asPartial() {\n        if (this.partial) return this.partial;\n        return this.partial = compilable(this.parsedLayout, this.options, true);\n    };\n\n    return ScannableTemplate;\n}();\nfunction compilable(layout, options, asPartial) {\n    var block = layout.block,\n        referrer = layout.referrer;\n    var hasEval = block.hasEval,\n        symbols = block.symbols;\n\n    var compileOptions = assign({}, options, { asPartial: asPartial, referrer: referrer });\n    return new CompilableTemplate(block.statements, layout, compileOptions, { referrer: referrer, hasEval: hasEval, symbols: symbols });\n}\n\nvar RehydratingCursor = function (_Cursor) {\n    inherits(RehydratingCursor, _Cursor);\n\n    function RehydratingCursor(element, nextSibling, startingBlockDepth) {\n        classCallCheck(this, RehydratingCursor);\n\n        var _this = possibleConstructorReturn(this, _Cursor.call(this, element, nextSibling));\n\n        _this.startingBlockDepth = startingBlockDepth;\n        _this.candidate = null;\n        _this.injectedOmittedNode = false;\n        _this.openBlockDepth = startingBlockDepth - 1;\n        return _this;\n    }\n\n    return RehydratingCursor;\n}(Cursor);\nvar RehydrateBuilder = function (_NewElementBuilder) {\n    inherits(RehydrateBuilder, _NewElementBuilder);\n\n    // private candidate: Option<Simple.Node> = null;\n    function RehydrateBuilder(env, parentNode, nextSibling) {\n        classCallCheck(this, RehydrateBuilder);\n\n        var _this2 = possibleConstructorReturn(this, _NewElementBuilder.call(this, env, parentNode, nextSibling));\n\n        _this2.unmatchedAttributes = null;\n        _this2.blockDepth = 0;\n        if (nextSibling) throw new Error(\"Rehydration with nextSibling not supported\");\n        _this2.candidate = _this2.currentCursor.element.firstChild;\n        false && debugAssert(_this2.candidate && isComment(_this2.candidate) && _this2.candidate.nodeValue === '%+block:0%', 'Must have opening comment <!--%+block:0%--> for rehydration.');\n        return _this2;\n    }\n\n    RehydrateBuilder.prototype.pushElement = function pushElement(element, nextSibling) {\n        var _blockDepth = this.blockDepth,\n            blockDepth = _blockDepth === undefined ? 0 : _blockDepth;\n\n        var cursor = new RehydratingCursor(element, nextSibling, blockDepth);\n        var currentCursor = this.currentCursor;\n        if (currentCursor) {\n            if (currentCursor.candidate) {\n                /**\n                 * <div>   <---------------  currentCursor.element\n                 *   <!--%+block:1%-->\n                 *   <div> <---------------  currentCursor.candidate -> cursor.element\n                 *     <!--%+block:2%--> <-  currentCursor.candidate.firstChild -> cursor.candidate\n                 *     Foo\n                 *     <!--%-block:2%-->\n                 *   </div>\n                 *   <!--%-block:1%-->  <--  becomes currentCursor.candidate\n                 */\n                // where to rehydrate from if we are in rehydration mode\n                cursor.candidate = element.firstChild;\n                // where to continue when we pop\n                currentCursor.candidate = element.nextSibling;\n            }\n        }\n        this.cursorStack.push(cursor);\n    };\n\n    RehydrateBuilder.prototype.clearMismatch = function clearMismatch(candidate) {\n        var current = candidate;\n        var currentCursor = this.currentCursor;\n        if (currentCursor !== null) {\n            var openBlockDepth = currentCursor.openBlockDepth;\n            if (openBlockDepth >= currentCursor.startingBlockDepth) {\n                while (current && !(isComment(current) && getCloseBlockDepth(current) === openBlockDepth)) {\n                    current = this.remove(current);\n                }\n                false && debugAssert(current !== null, 'should have found closing block');\n            } else {\n                while (current !== null) {\n                    current = this.remove(current);\n                }\n            }\n            // current cursor parentNode should be openCandidate if element\n            // or openCandidate.parentNode if comment\n            currentCursor.nextSibling = current;\n            // disable rehydration until we popElement or closeBlock for openBlockDepth\n            currentCursor.candidate = null;\n        }\n    };\n\n    RehydrateBuilder.prototype.__openBlock = function __openBlock() {\n        var currentCursor = this.currentCursor;\n\n        if (currentCursor === null) return;\n        var blockDepth = this.blockDepth;\n        this.blockDepth++;\n        var candidate = currentCursor.candidate;\n\n        if (candidate === null) return;\n        if (isComment(candidate) && getOpenBlockDepth(candidate) === blockDepth) {\n            currentCursor.candidate = this.remove(candidate);\n            currentCursor.openBlockDepth = blockDepth;\n        } else {\n            this.clearMismatch(candidate);\n        }\n    };\n\n    RehydrateBuilder.prototype.__closeBlock = function __closeBlock() {\n        var currentCursor = this.currentCursor;\n\n        if (currentCursor === null) return;\n        // openBlock is the last rehydrated open block\n        var openBlockDepth = currentCursor.openBlockDepth;\n        // this currently is the expected next open block depth\n        this.blockDepth--;\n        var candidate = currentCursor.candidate;\n        // rehydrating\n\n        if (candidate !== null) {\n            false && debugAssert(openBlockDepth === this.blockDepth, 'when rehydrating, openBlockDepth should match this.blockDepth here');\n\n            if (isComment(candidate) && getCloseBlockDepth(candidate) === openBlockDepth) {\n                currentCursor.candidate = this.remove(candidate);\n                currentCursor.openBlockDepth--;\n            } else {\n                this.clearMismatch(candidate);\n            }\n            // if the openBlockDepth matches the blockDepth we just closed to\n            // then restore rehydration\n        }\n        if (currentCursor.openBlockDepth === this.blockDepth) {\n            false && debugAssert(currentCursor.nextSibling !== null && isComment(currentCursor.nextSibling) && getCloseBlockDepth(currentCursor.nextSibling) === openBlockDepth, \"expected close block to match rehydrated open block\");\n\n            currentCursor.candidate = this.remove(currentCursor.nextSibling);\n            currentCursor.openBlockDepth--;\n        }\n    };\n\n    RehydrateBuilder.prototype.__appendNode = function __appendNode(node) {\n        var candidate = this.candidate;\n        // This code path is only used when inserting precisely one node. It needs more\n        // comparison logic, but we can probably lean on the cases where this code path\n        // is actually used.\n\n        if (candidate) {\n            return candidate;\n        } else {\n            return _NewElementBuilder.prototype.__appendNode.call(this, node);\n        }\n    };\n\n    RehydrateBuilder.prototype.__appendHTML = function __appendHTML(html) {\n        var candidateBounds = this.markerBounds();\n        if (candidateBounds) {\n            var first = candidateBounds.firstNode();\n            var last = candidateBounds.lastNode();\n            var newBounds = bounds(this.element, first.nextSibling, last.previousSibling);\n            this.remove(first);\n            this.remove(last);\n            return newBounds;\n        } else {\n            return _NewElementBuilder.prototype.__appendHTML.call(this, html);\n        }\n    };\n\n    RehydrateBuilder.prototype.remove = function remove(node) {\n        var element = node.parentNode;\n        var next = node.nextSibling;\n        element.removeChild(node);\n        return next;\n    };\n\n    RehydrateBuilder.prototype.markerBounds = function markerBounds() {\n        var _candidate = this.candidate;\n        if (_candidate && isMarker(_candidate)) {\n            var first = _candidate;\n            var last = first.nextSibling;\n            while (last && !isMarker(last)) {\n                last = last.nextSibling;\n            }\n            return bounds(this.element, first, last);\n        } else {\n            return null;\n        }\n    };\n\n    RehydrateBuilder.prototype.__appendText = function __appendText(string) {\n        var candidate = this.candidate;\n\n        if (candidate) {\n            if (isTextNode(candidate)) {\n                if (candidate.nodeValue !== string) {\n                    candidate.nodeValue = string;\n                }\n                this.candidate = candidate.nextSibling;\n                return candidate;\n            } else if (candidate && (isSeparator(candidate) || isEmpty$1(candidate))) {\n                this.candidate = candidate.nextSibling;\n                this.remove(candidate);\n                return this.__appendText(string);\n            } else if (isEmpty$1(candidate)) {\n                var next = this.remove(candidate);\n                this.candidate = next;\n                var text = this.dom.createTextNode(string);\n                this.dom.insertBefore(this.element, text, next);\n                return text;\n            } else {\n                this.clearMismatch(candidate);\n                return _NewElementBuilder.prototype.__appendText.call(this, string);\n            }\n        } else {\n            return _NewElementBuilder.prototype.__appendText.call(this, string);\n        }\n    };\n\n    RehydrateBuilder.prototype.__appendComment = function __appendComment(string) {\n        var _candidate = this.candidate;\n        if (_candidate && isComment(_candidate)) {\n            if (_candidate.nodeValue !== string) {\n                _candidate.nodeValue = string;\n            }\n            this.candidate = _candidate.nextSibling;\n            return _candidate;\n        } else if (_candidate) {\n            this.clearMismatch(_candidate);\n        }\n        return _NewElementBuilder.prototype.__appendComment.call(this, string);\n    };\n\n    RehydrateBuilder.prototype.__openElement = function __openElement(tag) {\n        var _candidate = this.candidate;\n        if (_candidate && isElement(_candidate) && isSameNodeType(_candidate, tag)) {\n            this.unmatchedAttributes = [].slice.call(_candidate.attributes);\n            return _candidate;\n        } else if (_candidate) {\n            if (isElement(_candidate) && _candidate.tagName === 'TBODY') {\n                this.pushElement(_candidate, null);\n                this.currentCursor.injectedOmittedNode = true;\n                return this.__openElement(tag);\n            }\n            this.clearMismatch(_candidate);\n        }\n        return _NewElementBuilder.prototype.__openElement.call(this, tag);\n    };\n\n    RehydrateBuilder.prototype.__setAttribute = function __setAttribute(name, value, namespace) {\n        var unmatched = this.unmatchedAttributes;\n        if (unmatched) {\n            var attr = findByName(unmatched, name);\n            if (attr) {\n                if (attr.value !== value) {\n                    attr.value = value;\n                }\n                unmatched.splice(unmatched.indexOf(attr), 1);\n                return;\n            }\n        }\n        return _NewElementBuilder.prototype.__setAttribute.call(this, name, value, namespace);\n    };\n\n    RehydrateBuilder.prototype.__setProperty = function __setProperty(name, value) {\n        var unmatched = this.unmatchedAttributes;\n        if (unmatched) {\n            var attr = findByName(unmatched, name);\n            if (attr) {\n                if (attr.value !== value) {\n                    attr.value = value;\n                }\n                unmatched.splice(unmatched.indexOf(attr), 1);\n                return;\n            }\n        }\n        return _NewElementBuilder.prototype.__setProperty.call(this, name, value);\n    };\n\n    RehydrateBuilder.prototype.__flushElement = function __flushElement(parent, constructing) {\n        var unmatched = this.unmatchedAttributes;\n\n        if (unmatched) {\n            for (var i = 0; i < unmatched.length; i++) {\n                this.constructing.removeAttribute(unmatched[i].name);\n            }\n            this.unmatchedAttributes = null;\n        } else {\n            _NewElementBuilder.prototype.__flushElement.call(this, parent, constructing);\n        }\n    };\n\n    RehydrateBuilder.prototype.appendCautiousDynamicContent = function appendCautiousDynamicContent(value) {\n        var content = _NewElementBuilder.prototype.appendCautiousDynamicContent.call(this, value);\n        content.update(this.env, value);\n        return content;\n    };\n\n    RehydrateBuilder.prototype.willCloseElement = function willCloseElement() {\n        var candidate = this.candidate,\n            currentCursor = this.currentCursor;\n\n        if (candidate !== null) {\n            this.clearMismatch(candidate);\n        }\n        if (currentCursor && currentCursor.injectedOmittedNode) {\n            this.popElement();\n        }\n        _NewElementBuilder.prototype.willCloseElement.call(this);\n    };\n\n    RehydrateBuilder.prototype.getMarker = function getMarker(element, guid) {\n        var marker = element.querySelector(\"script[glmr=\\\"\" + guid + \"\\\"]\");\n        if (marker) {\n            return marker;\n        }\n        throw new Error('Cannot find serialized cursor for `in-element`');\n    };\n\n    RehydrateBuilder.prototype.__pushRemoteElement = function __pushRemoteElement(element, cursorId) {\n        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var marker = this.getMarker(element, cursorId);\n        if (marker.parentNode === element) {\n            var currentCursor = this.currentCursor;\n            var candidate = currentCursor.candidate;\n            this.pushElement(element, nextSibling);\n            currentCursor.candidate = candidate;\n            this.candidate = this.remove(marker);\n            var tracker = new RemoteBlockTracker(element);\n            this.pushBlockTracker(tracker, true);\n        }\n    };\n\n    RehydrateBuilder.prototype.didAppendBounds = function didAppendBounds(bounds$$1) {\n        _NewElementBuilder.prototype.didAppendBounds.call(this, bounds$$1);\n        if (this.candidate) {\n            var last = bounds$$1.lastNode();\n            this.candidate = last && last.nextSibling;\n        }\n        return bounds$$1;\n    };\n\n    createClass(RehydrateBuilder, [{\n        key: \"currentCursor\",\n        get: function get$$1() {\n            return this.cursorStack.current;\n        }\n    }, {\n        key: \"candidate\",\n        get: function get$$1() {\n            if (this.currentCursor) {\n                return this.currentCursor.candidate;\n            }\n            return null;\n        },\n        set: function set$$1(node) {\n            this.currentCursor.candidate = node;\n        }\n    }]);\n    return RehydrateBuilder;\n}(NewElementBuilder);\nfunction isTextNode(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nfunction getOpenBlockDepth(node) {\n    var boundsDepth = node.nodeValue.match(/^%\\+block:(\\d+)%$/);\n    if (boundsDepth && boundsDepth[1]) {\n        return Number(boundsDepth[1]);\n    } else {\n        return null;\n    }\n}\nfunction getCloseBlockDepth(node) {\n    var boundsDepth = node.nodeValue.match(/^%\\-block:(\\d+)%$/);\n    if (boundsDepth && boundsDepth[1]) {\n        return Number(boundsDepth[1]);\n    } else {\n        return null;\n    }\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isMarker(node) {\n    return node.nodeType === 8 && node.nodeValue === '%glimmer%';\n}\nfunction isSeparator(node) {\n    return node.nodeType === 8 && node.nodeValue === '%sep%';\n}\nfunction isEmpty$1(node) {\n    return node.nodeType === 8 && node.nodeValue === '%empty%';\n}\nfunction isSameNodeType(candidate, tag) {\n    if (candidate.namespaceURI === SVG_NAMESPACE$$1) {\n        return candidate.tagName === tag;\n    }\n    return candidate.tagName === tag.toUpperCase();\n}\nfunction findByName(array, name) {\n    for (var i = 0; i < array.length; i++) {\n        var attr = array[i];\n        if (attr.name === name) return attr;\n    }\n    return undefined;\n}\n\n/**\n * The base PathReference.\n */\nvar ComponentPathReference = function () {\n    function ComponentPathReference() {\n        classCallCheck(this, ComponentPathReference);\n    }\n\n    ComponentPathReference.prototype.get = function get$$1(key) {\n        return PropertyReference.create(this, key);\n    };\n\n    return ComponentPathReference;\n}();\nvar CachedReference$1 = function (_ComponentPathReferen) {\n    inherits(CachedReference$$1, _ComponentPathReferen);\n\n    function CachedReference$$1() {\n        classCallCheck(this, CachedReference$$1);\n\n        var _this = possibleConstructorReturn(this, _ComponentPathReferen.apply(this, arguments));\n\n        _this._lastRevision = null;\n        _this._lastValue = null;\n        return _this;\n    }\n\n    CachedReference$$1.prototype.value = function value() {\n        var tag = this.tag,\n            _lastRevision = this._lastRevision,\n            _lastValue = this._lastValue;\n\n        if (!_lastRevision || !tag.validate(_lastRevision)) {\n            _lastValue = this._lastValue = this.compute();\n            this._lastRevision = tag.value();\n        }\n        return _lastValue;\n    };\n\n    return CachedReference$$1;\n}(ComponentPathReference);\nvar RootReference = function (_ConstReference) {\n    inherits(RootReference, _ConstReference);\n\n    function RootReference() {\n        classCallCheck(this, RootReference);\n\n        var _this2 = possibleConstructorReturn(this, _ConstReference.apply(this, arguments));\n\n        _this2.children = dict();\n        return _this2;\n    }\n\n    RootReference.prototype.get = function get$$1(propertyKey) {\n        var ref = this.children[propertyKey];\n        if (!ref) {\n            ref = this.children[propertyKey] = new RootPropertyReference(this.inner, propertyKey);\n        }\n        return ref;\n    };\n\n    return RootReference;\n}(ConstReference);\nvar PropertyReference = function (_CachedReference) {\n    inherits(PropertyReference, _CachedReference);\n\n    function PropertyReference() {\n        classCallCheck(this, PropertyReference);\n        return possibleConstructorReturn(this, _CachedReference.apply(this, arguments));\n    }\n\n    PropertyReference.create = function create(parentReference, propertyKey) {\n        if (isConst(parentReference)) {\n            return new RootPropertyReference(parentReference.value(), propertyKey);\n        } else {\n            return new NestedPropertyReference(parentReference, propertyKey);\n        }\n    };\n\n    PropertyReference.prototype.get = function get$$1(key) {\n        return new NestedPropertyReference(this, key);\n    };\n\n    return PropertyReference;\n}(CachedReference$1);\nvar RootPropertyReference = function (_PropertyReference) {\n    inherits(RootPropertyReference, _PropertyReference);\n\n    function RootPropertyReference(parentValue, propertyKey) {\n        classCallCheck(this, RootPropertyReference);\n\n        var _this4 = possibleConstructorReturn(this, _PropertyReference.call(this));\n\n        _this4._parentValue = parentValue;\n        _this4._propertyKey = propertyKey;\n        _this4.tag = tagForProperty(parentValue, propertyKey);\n        return _this4;\n    }\n\n    RootPropertyReference.prototype.compute = function compute() {\n        return this._parentValue[this._propertyKey];\n    };\n\n    return RootPropertyReference;\n}(PropertyReference);\nvar NestedPropertyReference = function (_PropertyReference2) {\n    inherits(NestedPropertyReference, _PropertyReference2);\n\n    function NestedPropertyReference(parentReference, propertyKey) {\n        classCallCheck(this, NestedPropertyReference);\n\n        var _this5 = possibleConstructorReturn(this, _PropertyReference2.call(this));\n\n        var parentReferenceTag = parentReference.tag;\n        var parentObjectTag = UpdatableTag.create(CONSTANT_TAG);\n        _this5._parentReference = parentReference;\n        _this5._parentObjectTag = parentObjectTag;\n        _this5._propertyKey = propertyKey;\n        _this5.tag = combine([parentReferenceTag, parentObjectTag]);\n        return _this5;\n    }\n\n    NestedPropertyReference.prototype.compute = function compute() {\n        var _parentReference = this._parentReference,\n            _parentObjectTag = this._parentObjectTag,\n            _propertyKey = this._propertyKey;\n\n        var parentValue = _parentReference.value();\n        _parentObjectTag.inner.update(tagForProperty(parentValue, _propertyKey));\n        if (typeof parentValue === \"string\" && _propertyKey === \"length\") {\n            return parentValue.length;\n        }\n        if ((typeof parentValue === \"undefined\" ? \"undefined\" : _typeof(parentValue)) === \"object\" && parentValue) {\n            return parentValue[_propertyKey];\n        } else {\n            return undefined;\n        }\n    };\n\n    return NestedPropertyReference;\n}(PropertyReference);\nvar UpdatableReference = function (_ComponentPathReferen2) {\n    inherits(UpdatableReference, _ComponentPathReferen2);\n\n    function UpdatableReference(value) {\n        classCallCheck(this, UpdatableReference);\n\n        var _this6 = possibleConstructorReturn(this, _ComponentPathReferen2.call(this));\n\n        _this6.tag = DirtyableTag.create();\n        _this6._value = value;\n        return _this6;\n    }\n\n    UpdatableReference.prototype.value = function value() {\n        return this._value;\n    };\n\n    UpdatableReference.prototype.update = function update(value) {\n        var _value = this._value;\n\n        if (value !== _value) {\n            this.tag.inner.dirty();\n            this._value = value;\n        }\n    };\n\n    return UpdatableReference;\n}(ComponentPathReference);\nvar ConditionalReference$$1 = function (_GlimmerConditionalRe) {\n    inherits(ConditionalReference$$1, _GlimmerConditionalRe);\n\n    function ConditionalReference$$1() {\n        classCallCheck(this, ConditionalReference$$1);\n        return possibleConstructorReturn(this, _GlimmerConditionalRe.apply(this, arguments));\n    }\n\n    ConditionalReference$$1.create = function create(reference) {\n        if (isConst(reference)) {\n            var value = reference.value();\n            return PrimitiveReference.create(value);\n        }\n        return new ConditionalReference$$1(reference);\n    };\n\n    return ConditionalReference$$1;\n}(ConditionalReference$1);\n\nvar ComponentStateBucket = function () {\n    function ComponentStateBucket(definition, args, owner) {\n        classCallCheck(this, ComponentStateBucket);\n\n        var componentFactory = definition.ComponentClass;\n        var name = definition.name;\n        this.args = args;\n        var injections = {\n            debugName: name,\n            args: this.namedArgsSnapshot()\n        };\n        setOwner(injections, owner);\n        this.component = componentFactory.create(injections);\n    }\n\n    ComponentStateBucket.prototype.namedArgsSnapshot = function namedArgsSnapshot() {\n        return Object.freeze(this.args.named.value());\n    };\n\n    createClass(ComponentStateBucket, [{\n        key: \"tag\",\n        get: function get$$1() {\n            return this.args.tag;\n        }\n    }]);\n    return ComponentStateBucket;\n}();\n\nvar ComponentManager = function () {\n    ComponentManager.create = function create(options) {\n        return new ComponentManager(options);\n    };\n\n    function ComponentManager(options) {\n        classCallCheck(this, ComponentManager);\n\n        this.env = options.env;\n    }\n\n    ComponentManager.prototype.prepareArgs = function prepareArgs(state, args) {\n        return null;\n    };\n\n    ComponentManager.prototype.getCapabilities = function getCapabilities(state) {\n        return state.capabilities;\n    };\n\n    ComponentManager.prototype.getLayout = function getLayout(_ref, resolver) {\n        var name = _ref.name,\n            layout = _ref.layout;\n\n        return resolver.compileTemplate(name, layout);\n    };\n\n    ComponentManager.prototype.create = function create(_env, definition, args, _dynamicScope, _caller, _hasDefaultBlock) {\n        var owner = getOwner(this.env);\n        return new ComponentStateBucket(definition, args.capture(), owner);\n    };\n\n    ComponentManager.prototype.getSelf = function getSelf(bucket) {\n        return new RootReference(bucket.component);\n    };\n\n    ComponentManager.prototype.didCreateElement = function didCreateElement(bucket, element) {};\n\n    ComponentManager.prototype.didRenderLayout = function didRenderLayout(bucket, bounds) {\n        bucket.component.bounds = new Bounds(bounds);\n    };\n\n    ComponentManager.prototype.didCreate = function didCreate(bucket) {\n        if (bucket) {\n            bucket.component.didInsertElement();\n        }\n    };\n\n    ComponentManager.prototype.getTag = function getTag(_ref2) {\n        var tag = _ref2.tag;\n\n        return tag;\n    };\n\n    ComponentManager.prototype.update = function update(bucket, scope) {\n        bucket.component.args = bucket.namedArgsSnapshot();\n    };\n\n    ComponentManager.prototype.didUpdateLayout = function didUpdateLayout() {};\n\n    ComponentManager.prototype.didUpdate = function didUpdate(_ref3) {\n        var component = _ref3.component;\n\n        component.didUpdate();\n    };\n\n    ComponentManager.prototype.getDestructor = function getDestructor(bucket) {\n        return bucket.component;\n    };\n\n    return ComponentManager;\n}();\n\nfunction EMPTY_CACHE() {}\n\nvar PathReference = function () {\n    function PathReference(parent, property) {\n        classCallCheck(this, PathReference);\n\n        this.cache = EMPTY_CACHE;\n        this.inner = null;\n        this.chains = null;\n        this.lastParentValue = EMPTY_CACHE;\n        this._guid = 0;\n        this.tag = VOLATILE_TAG;\n        this.parent = parent;\n        this.property = property;\n    }\n\n    PathReference.prototype.value = function value() {\n        var lastParentValue = this.lastParentValue,\n            property = this.property,\n            inner = this.inner;\n\n        var parentValue = this._parentValue();\n        if (parentValue === null || parentValue === undefined) {\n            return this.cache = undefined;\n        }\n        if (lastParentValue === parentValue) {\n            inner = this.inner;\n        } else {\n            var ReferenceType = (typeof parentValue === 'undefined' ? 'undefined' : _typeof(parentValue)) === 'object' ? Meta$2.for(parentValue).referenceTypeFor(property) : PropertyReference$1;\n            inner = this.inner = new ReferenceType(parentValue, property, this);\n        }\n        // if (typeof parentValue === 'object') {\n        //   Meta.for(parentValue).addReference(property, this);\n        // }\n        return this.cache = inner.value();\n    };\n\n    PathReference.prototype.get = function get$$1(prop) {\n        var chains = this._getChains();\n        if (prop in chains) return chains[prop];\n        return chains[prop] = new PathReference(this, prop);\n    };\n\n    PathReference.prototype.label = function label() {\n        return '[reference Direct]';\n    };\n\n    PathReference.prototype._getChains = function _getChains() {\n        if (this.chains) return this.chains;\n        return this.chains = dict();\n    };\n\n    PathReference.prototype._parentValue = function _parentValue() {\n        var parent = this.parent.value();\n        this.lastParentValue = parent;\n        return parent;\n    };\n\n    return PathReference;\n}();\n\nvar RootReference$1 = function () {\n    function RootReference(object) {\n        classCallCheck(this, RootReference);\n\n        this.chains = dict();\n        this.tag = VOLATILE_TAG;\n        this.object = object;\n    }\n\n    RootReference.prototype.value = function value() {\n        return this.object;\n    };\n\n    RootReference.prototype.update = function update(object) {\n        this.object = object;\n        // this.notify();\n    };\n\n    RootReference.prototype.get = function get$$1(prop) {\n        var chains = this.chains;\n        if (prop in chains) return chains[prop];\n        return chains[prop] = new PathReference(this, prop);\n    };\n\n    RootReference.prototype.chainFor = function chainFor(prop) {\n        var chains = this.chains;\n        if (prop in chains) return chains[prop];\n        return null;\n    };\n\n    RootReference.prototype.path = function path(string) {\n        return this.referenceFromParts(string.split('.'));\n    };\n\n    RootReference.prototype.referenceFromParts = function referenceFromParts(parts) {\n        return parts.reduce(function (ref, part) {\n            return ref.get(part);\n        }, this);\n    };\n\n    RootReference.prototype.label = function label() {\n        return '[reference Root]';\n    };\n\n    return RootReference;\n}();\n\nvar NOOP_DESTROY = {\n    destroy: function destroy() {}\n};\n\nvar ConstPath = function () {\n    function ConstPath(parent, _property) {\n        classCallCheck(this, ConstPath);\n\n        this.tag = VOLATILE_TAG;\n        this.parent = parent;\n    }\n\n    ConstPath.prototype.chain = function chain() {\n        return NOOP_DESTROY;\n    };\n\n    ConstPath.prototype.notify = function notify() {};\n\n    ConstPath.prototype.value = function value() {\n        return this.parent[this.property];\n    };\n\n    ConstPath.prototype.get = function get$$1(prop) {\n        return new ConstPath(this.parent[this.property], prop);\n    };\n\n    return ConstPath;\n}();\n\nvar ConstRoot = function () {\n    function ConstRoot(value) {\n        classCallCheck(this, ConstRoot);\n\n        this.tag = VOLATILE_TAG;\n        this.inner = value;\n    }\n\n    ConstRoot.prototype.update = function update(inner) {\n        this.inner = inner;\n    };\n\n    ConstRoot.prototype.chain = function chain() {\n        return NOOP_DESTROY;\n    };\n\n    ConstRoot.prototype.notify = function notify() {};\n\n    ConstRoot.prototype.value = function value() {\n        return this.inner;\n    };\n\n    ConstRoot.prototype.referenceFromParts = function referenceFromParts(_parts) {\n        throw new Error(\"Not implemented\");\n    };\n\n    ConstRoot.prototype.chainFor = function chainFor(_prop) {\n        throw new Error(\"Not implemented\");\n    };\n\n    ConstRoot.prototype.get = function get$$1(prop) {\n        return new ConstPath(this.inner, prop);\n    };\n\n    return ConstRoot;\n}();\n\nvar ConstMeta /*implements IMeta*/ = function () {\n    function ConstMeta(object) {\n        classCallCheck(this, ConstMeta);\n\n        this.object = object;\n    }\n\n    ConstMeta.prototype.root = function root() {\n        return new ConstRoot(this.object);\n    };\n\n    return ConstMeta;\n}();\n\nvar CLASS_META = \"df8be4c8-4e89-44e2-a8f9-550c8dacdca7\";\nvar hasOwnProperty$1 = Object.hasOwnProperty;\n\nvar Meta$2 = function () {\n    function Meta(object, _ref) {\n        var RootReferenceFactory = _ref.RootReferenceFactory,\n            DefaultPathReferenceFactory = _ref.DefaultPathReferenceFactory;\n        classCallCheck(this, Meta);\n\n        this.references = null;\n        this.slots = null;\n        this.referenceTypes = null;\n        this.propertyMetadata = null;\n        this.object = object;\n        this.RootReferenceFactory = RootReferenceFactory || RootReference$1;\n        this.DefaultPathReferenceFactory = DefaultPathReferenceFactory || PropertyReference$1;\n    }\n\n    Meta.for = function _for(obj) {\n        if (obj === null || obj === undefined) return new Meta(obj, {});\n        if (hasOwnProperty$1.call(obj, '_meta') && obj._meta) return obj._meta;\n        if (!Object.isExtensible(obj)) return new ConstMeta(obj);\n        var MetaToUse = Meta;\n        if (obj.constructor && obj.constructor[CLASS_META]) {\n            var classMeta = obj.constructor[CLASS_META];\n            MetaToUse = classMeta.InstanceMetaConstructor;\n        } else if (obj[CLASS_META]) {\n            MetaToUse = obj[CLASS_META].InstanceMetaConstructor;\n        }\n        return obj._meta = new MetaToUse(obj, {});\n    };\n\n    Meta.exists = function exists(obj) {\n        return (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj._meta;\n    };\n\n    Meta.metadataForProperty = function metadataForProperty(_key) {\n        return null;\n    };\n\n    Meta.prototype.addReference = function addReference(property, reference) {\n        var refs = this.references = this.references || dict();\n        var set$$1 = refs[property] = refs[property] || new DictSet();\n        set$$1.add(reference);\n    };\n\n    Meta.prototype.addReferenceTypeFor = function addReferenceTypeFor(property, type) {\n        this.referenceTypes = this.referenceTypes || dict();\n        this.referenceTypes[property] = type;\n    };\n\n    Meta.prototype.referenceTypeFor = function referenceTypeFor(property) {\n        if (!this.referenceTypes) return PropertyReference$1;\n        return this.referenceTypes[property] || PropertyReference$1;\n    };\n\n    Meta.prototype.removeReference = function removeReference(property, reference) {\n        if (!this.references) return;\n        var set$$1 = this.references[property];\n        set$$1.delete(reference);\n    };\n\n    Meta.prototype.getReferenceTypes = function getReferenceTypes() {\n        this.referenceTypes = this.referenceTypes || dict();\n        return this.referenceTypes;\n    };\n\n    Meta.prototype.referencesFor = function referencesFor(property) {\n        if (!this.references) return null;\n        return this.references[property];\n    };\n\n    Meta.prototype.getSlots = function getSlots() {\n        return this.slots = this.slots || dict();\n    };\n\n    Meta.prototype.root = function root() {\n        return this.rootCache = this.rootCache || new this.RootReferenceFactory(this.object);\n    };\n\n    return Meta;\n}();\n\nvar PropertyReference$1 = function () {\n    function PropertyReference(object, property, _outer) {\n        classCallCheck(this, PropertyReference);\n\n        this.tag = VOLATILE_TAG;\n        this.object = object;\n        this.property = property;\n    }\n\n    PropertyReference.prototype.value = function value() {\n        return this.object[this.property];\n    };\n\n    PropertyReference.prototype.label = function label() {\n        return '[reference Property]';\n    };\n\n    return PropertyReference;\n}();\n\n// import { metaFor } from './meta';\n// import { intern } from '@glimmer/util';\n\nfunction isTypeSpecifier(specifier) {\n    return specifier.indexOf(':') === -1;\n}\n\nvar ApplicationRegistry = function () {\n    function ApplicationRegistry(registry, resolver) {\n        classCallCheck(this, ApplicationRegistry);\n\n        this._registry = registry;\n        this._resolver = resolver;\n    }\n\n    ApplicationRegistry.prototype.register = function register(specifier, factory, options) {\n        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);\n        this._registry.register(normalizedSpecifier, factory, options);\n    };\n\n    ApplicationRegistry.prototype.registration = function registration(specifier) {\n        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);\n        return this._registry.registration(normalizedSpecifier);\n    };\n\n    ApplicationRegistry.prototype.unregister = function unregister(specifier) {\n        var normalizedSpecifier = this._toAbsoluteSpecifier(specifier);\n        this._registry.unregister(normalizedSpecifier);\n    };\n\n    ApplicationRegistry.prototype.registerOption = function registerOption(specifier, option, value) {\n        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n        this._registry.registerOption(normalizedSpecifier, option, value);\n    };\n\n    ApplicationRegistry.prototype.registeredOption = function registeredOption(specifier, option) {\n        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n        return this._registry.registeredOption(normalizedSpecifier, option);\n    };\n\n    ApplicationRegistry.prototype.registeredOptions = function registeredOptions(specifier) {\n        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n        return this._registry.registeredOptions(normalizedSpecifier);\n    };\n\n    ApplicationRegistry.prototype.unregisterOption = function unregisterOption(specifier, option) {\n        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n        this._registry.unregisterOption(normalizedSpecifier, option);\n    };\n\n    ApplicationRegistry.prototype.registerInjection = function registerInjection(specifier, property, injection) {\n        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n        var normalizedInjection = this._toAbsoluteSpecifier(injection);\n        this._registry.registerInjection(normalizedSpecifier, property, normalizedInjection);\n    };\n\n    ApplicationRegistry.prototype.registeredInjections = function registeredInjections(specifier) {\n        var normalizedSpecifier = this._toAbsoluteOrTypeSpecifier(specifier);\n        return this._registry.registeredInjections(normalizedSpecifier);\n    };\n\n    ApplicationRegistry.prototype._toAbsoluteSpecifier = function _toAbsoluteSpecifier(specifier, referrer) {\n        return this._resolver.identify(specifier, referrer);\n    };\n\n    ApplicationRegistry.prototype._toAbsoluteOrTypeSpecifier = function _toAbsoluteOrTypeSpecifier(specifier) {\n        if (isTypeSpecifier(specifier)) {\n            return specifier;\n        } else {\n            return this._toAbsoluteSpecifier(specifier);\n        }\n    };\n\n    return ApplicationRegistry;\n}();\n\nvar DynamicScope = function () {\n    function DynamicScope() {\n        var bucket = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        classCallCheck(this, DynamicScope);\n\n        if (bucket) {\n            this.bucket = assign({}, bucket);\n        } else {\n            this.bucket = {};\n        }\n    }\n\n    DynamicScope.prototype.get = function get$$1(key) {\n        return this.bucket[key];\n    };\n\n    DynamicScope.prototype.set = function set$$1(key, reference) {\n        return this.bucket[key] = reference;\n    };\n\n    DynamicScope.prototype.child = function child() {\n        return new DynamicScope(this.bucket);\n    };\n\n    return DynamicScope;\n}();\n\nvar ArrayIterator = function () {\n    function ArrayIterator(array, keyFor) {\n        classCallCheck(this, ArrayIterator);\n\n        this.position = 0;\n        this.array = array;\n        this.keyFor = keyFor;\n    }\n\n    ArrayIterator.prototype.isEmpty = function isEmpty() {\n        return this.array.length === 0;\n    };\n\n    ArrayIterator.prototype.next = function next() {\n        var position = this.position,\n            array = this.array,\n            keyFor = this.keyFor;\n\n        if (position >= array.length) return null;\n        var value = array[position];\n        var key = keyFor(value, position);\n        var memo = position;\n        this.position++;\n        return { key: key, value: value, memo: memo };\n    };\n\n    return ArrayIterator;\n}();\n\nvar ObjectKeysIterator = function () {\n    function ObjectKeysIterator(keys, values, keyFor) {\n        classCallCheck(this, ObjectKeysIterator);\n\n        this.position = 0;\n        this.keys = keys;\n        this.values = values;\n        this.keyFor = keyFor;\n    }\n\n    ObjectKeysIterator.prototype.isEmpty = function isEmpty() {\n        return this.keys.length === 0;\n    };\n\n    ObjectKeysIterator.prototype.next = function next() {\n        var position = this.position,\n            keys = this.keys,\n            values = this.values,\n            keyFor = this.keyFor;\n\n        if (position >= keys.length) return null;\n        var value = values[position];\n        var memo = keys[position];\n        var key = keyFor(value, memo);\n        this.position++;\n        return { key: key, value: value, memo: memo };\n    };\n\n    return ObjectKeysIterator;\n}();\n\nvar EmptyIterator = function () {\n    function EmptyIterator() {\n        classCallCheck(this, EmptyIterator);\n    }\n\n    EmptyIterator.prototype.isEmpty = function isEmpty() {\n        return true;\n    };\n\n    EmptyIterator.prototype.next = function next() {\n        throw new Error(\"Cannot call next() on an empty iterator\");\n    };\n\n    return EmptyIterator;\n}();\n\nvar EMPTY_ITERATOR = new EmptyIterator();\n\nvar Iterable = function () {\n    function Iterable(ref, keyFor) {\n        classCallCheck(this, Iterable);\n\n        this.tag = ref.tag;\n        this.ref = ref;\n        this.keyFor = keyFor;\n    }\n\n    Iterable.prototype.iterate = function iterate() {\n        var ref = this.ref,\n            keyFor = this.keyFor;\n\n        var iterable = ref.value();\n        if (Array.isArray(iterable)) {\n            return iterable.length > 0 ? new ArrayIterator(iterable, keyFor) : EMPTY_ITERATOR;\n        } else if (iterable === undefined || iterable === null) {\n            return EMPTY_ITERATOR;\n        } else if (iterable.forEach !== undefined) {\n            var array = [];\n            iterable.forEach(function (item) {\n                array.push(item);\n            });\n            return array.length > 0 ? new ArrayIterator(array, keyFor) : EMPTY_ITERATOR;\n        } else if ((typeof iterable === \"undefined\" ? \"undefined\" : _typeof(iterable)) === 'object') {\n            var keys = Object.keys(iterable);\n            return keys.length > 0 ? new ObjectKeysIterator(keys, keys.map(function (key) {\n                return iterable[key];\n            }), keyFor) : EMPTY_ITERATOR;\n        } else {\n            throw new Error(\"Don't know how to {{#each \" + iterable + \"}}\");\n        }\n    };\n\n    Iterable.prototype.valueReferenceFor = function valueReferenceFor(item) {\n        return new UpdatableReference(item.value);\n    };\n\n    Iterable.prototype.updateValueReference = function updateValueReference(reference, item) {\n        reference.update(item.value);\n    };\n\n    Iterable.prototype.memoReferenceFor = function memoReferenceFor(item) {\n        return new UpdatableReference(item.memo);\n    };\n\n    Iterable.prototype.updateMemoReference = function updateMemoReference(reference, item) {\n        reference.update(item.memo);\n    };\n\n    return Iterable;\n}();\n\nvar UNRESOLVED = {};\nvar WELL_KNOWN_EMPTY_ARRAY_POSITION = 0;\nvar WELL_KNOW_EMPTY_ARRAY = Object.freeze([]);\n\nvar WriteOnlyConstants = function () {\n    function WriteOnlyConstants() {\n        classCallCheck(this, WriteOnlyConstants);\n\n        // `0` means NULL\n        this.strings = [];\n        this.arrays = [WELL_KNOW_EMPTY_ARRAY];\n        this.tables = [];\n        this.handles = [];\n        this.serializables = [];\n        this.resolved = [];\n        this.floats = [];\n        this.negatives = [];\n    }\n\n    WriteOnlyConstants.prototype.float = function float(_float) {\n        var index = this.floats.indexOf(_float);\n        if (index > -1) {\n            return index;\n        }\n        return this.floats.push(_float) - 1;\n    };\n\n    WriteOnlyConstants.prototype.negative = function negative(_negative) {\n        return this.negatives.push(_negative) - 1;\n    };\n\n    WriteOnlyConstants.prototype.string = function string(value) {\n        var index = this.strings.indexOf(value);\n        if (index > -1) {\n            return index;\n        }\n        return this.strings.push(value) - 1;\n    };\n\n    WriteOnlyConstants.prototype.stringArray = function stringArray(strings) {\n        var _strings = new Array(strings.length);\n        for (var i = 0; i < strings.length; i++) {\n            _strings[i] = this.string(strings[i]);\n        }\n        return this.array(_strings);\n    };\n\n    WriteOnlyConstants.prototype.array = function array(values) {\n        if (values.length === 0) {\n            return WELL_KNOWN_EMPTY_ARRAY_POSITION;\n        }\n        var index = this.arrays.indexOf(values);\n        if (index > -1) {\n            return index;\n        }\n        return this.arrays.push(values) - 1;\n    };\n\n    WriteOnlyConstants.prototype.table = function table(t) {\n        var index = this.tables.indexOf(t);\n        if (index > -1) {\n            return index;\n        }\n        return this.tables.push(t) - 1;\n    };\n\n    WriteOnlyConstants.prototype.handle = function handle(_handle) {\n        this.resolved.push(UNRESOLVED);\n        return this.handles.push(_handle);\n    };\n\n    WriteOnlyConstants.prototype.serializable = function serializable(value) {\n        var index = this.serializables.indexOf(value);\n        if (index > -1) {\n            return index;\n        }\n        return this.serializables.push(value) - 1;\n    };\n\n    WriteOnlyConstants.prototype.toPool = function toPool() {\n        return {\n            strings: this.strings,\n            arrays: this.arrays,\n            tables: this.tables,\n            handles: this.handles,\n            serializables: this.serializables,\n            floats: this.floats,\n            negatives: this.negatives\n        };\n    };\n\n    return WriteOnlyConstants;\n}();\n\n\nvar Constants = function (_WriteOnlyConstants) {\n    inherits(Constants, _WriteOnlyConstants);\n\n    function Constants(resolver, pool) {\n        classCallCheck(this, Constants);\n\n        var _this = possibleConstructorReturn(this, _WriteOnlyConstants.call(this));\n\n        _this.resolver = resolver;\n        if (pool) {\n            _this.strings = pool.strings;\n            _this.arrays = pool.arrays;\n            _this.tables = pool.tables;\n            _this.handles = pool.handles;\n            _this.serializables = pool.serializables;\n            _this.floats = pool.floats;\n            _this.negatives = pool.negatives;\n            _this.resolved = _this.handles.map(function () {\n                return UNRESOLVED;\n            });\n        }\n        return _this;\n    }\n    // `0` means NULL\n\n\n    Constants.prototype.getFloat = function getFloat(value) {\n        return this.floats[value];\n    };\n\n    Constants.prototype.getNegative = function getNegative(value) {\n        return this.negatives[value];\n    };\n\n    Constants.prototype.getString = function getString(value) {\n        return this.strings[value];\n    };\n\n    Constants.prototype.getStringArray = function getStringArray(value) {\n        var names = this.getArray(value);\n        var _names = new Array(names.length);\n        for (var i = 0; i < names.length; i++) {\n            var n = names[i];\n            _names[i] = this.getString(n);\n        }\n        return _names;\n    };\n\n    Constants.prototype.getArray = function getArray(value) {\n        return this.arrays[value];\n    };\n\n    Constants.prototype.getSymbolTable = function getSymbolTable(value) {\n        return this.tables[value];\n    };\n\n    Constants.prototype.resolveHandle = function resolveHandle(s) {\n        var index = s - 1;\n        var resolved = this.resolved[index];\n        if (resolved === UNRESOLVED) {\n            var handle = this.handles[index];\n            resolved = this.resolved[index] = this.resolver.resolve(handle);\n        }\n        return resolved;\n    };\n\n    Constants.prototype.getSerializable = function getSerializable(s) {\n        return this.serializables[s];\n    };\n\n    return Constants;\n}(WriteOnlyConstants);\n\nvar LazyConstants = function (_Constants) {\n    inherits(LazyConstants, _Constants);\n\n    function LazyConstants() {\n        classCallCheck(this, LazyConstants);\n\n        var _this2 = possibleConstructorReturn(this, _Constants.apply(this, arguments));\n\n        _this2.others = [];\n        return _this2;\n    }\n\n    LazyConstants.prototype.getOther = function getOther(value) {\n        return this.others[value - 1];\n    };\n\n    LazyConstants.prototype.other = function other(_other) {\n        return this.others.push(_other);\n    };\n\n    return LazyConstants;\n}(Constants);\n\nvar Opcode = function () {\n    function Opcode(heap) {\n        classCallCheck(this, Opcode);\n\n        this.heap = heap;\n        this.offset = 0;\n    }\n\n    createClass(Opcode, [{\n        key: \"size\",\n        get: function get$$1() {\n            var rawType = this.heap.getbyaddr(this.offset);\n            return ((rawType & OPERAND_LEN_MASK) >> ARG_SHIFT) + 1;\n        }\n    }, {\n        key: \"type\",\n        get: function get$$1() {\n            return this.heap.getbyaddr(this.offset) & TYPE_MASK;\n        }\n    }, {\n        key: \"op1\",\n        get: function get$$1() {\n            return this.heap.getbyaddr(this.offset + 1);\n        }\n    }, {\n        key: \"op2\",\n        get: function get$$1() {\n            return this.heap.getbyaddr(this.offset + 2);\n        }\n    }, {\n        key: \"op3\",\n        get: function get$$1() {\n            return this.heap.getbyaddr(this.offset + 3);\n        }\n    }]);\n    return Opcode;\n}();\n\nvar TableSlotState;\n(function (TableSlotState) {\n    TableSlotState[TableSlotState[\"Allocated\"] = 0] = \"Allocated\";\n    TableSlotState[TableSlotState[\"Freed\"] = 1] = \"Freed\";\n    TableSlotState[TableSlotState[\"Purged\"] = 2] = \"Purged\";\n    TableSlotState[TableSlotState[\"Pointer\"] = 3] = \"Pointer\";\n})(TableSlotState || (TableSlotState = {}));\nvar ENTRY_SIZE = 2;\nvar INFO_OFFSET = 1;\nvar SIZE_MASK = 65535;\nvar SCOPE_MASK = 1073676288;\nvar STATE_MASK = 3221225472;\nfunction encodeTableInfo(size, scopeSize, state) {\n    return size | scopeSize << 16 | state << 30;\n}\nfunction changeState(info, newState) {\n    return info | newState << 30;\n}\n/**\n * The Heap is responsible for dynamically allocating\n * memory in which we read/write the VM's instructions\n * from/to. When we malloc we pass out a VMHandle, which\n * is used as an indirect way of accessing the memory during\n * execution of the VM. Internally we track the different\n * regions of the memory in an int array known as the table.\n *\n * The table 32-bit aligned and has the following layout:\n *\n * | ... | hp (u32) |       info (u32)          |\n * | ... |  Handle  | Size | Scope Size | State |\n * | ... | 32-bits  | 16b  |    14b     |  2b   |\n *\n * With this information we effectively have the ability to\n * control when we want to free memory. That being said you\n * can not free during execution as raw address are only\n * valid during the execution. This means you cannot close\n * over them as you will have a bad memory access exception.\n */\nvar Heap = function () {\n    function Heap(serializedHeap) {\n        classCallCheck(this, Heap);\n\n        this.offset = 0;\n        this.handle = 0;\n        if (serializedHeap) {\n            var buffer = serializedHeap.buffer,\n                table = serializedHeap.table,\n                handle = serializedHeap.handle;\n\n            this.heap = new Uint16Array(buffer);\n            this.table = table;\n            this.offset = this.heap.length;\n            this.handle = handle;\n        } else {\n            this.heap = new Uint16Array(0x100000);\n            this.table = [];\n        }\n    }\n\n    Heap.prototype.push = function push(item) {\n        this.heap[this.offset++] = item;\n    };\n\n    Heap.prototype.getbyaddr = function getbyaddr(address) {\n        return this.heap[address];\n    };\n\n    Heap.prototype.setbyaddr = function setbyaddr(address, value) {\n        this.heap[address] = value;\n    };\n\n    Heap.prototype.malloc = function malloc() {\n        this.table.push(this.offset, 0);\n        var handle = this.handle;\n        this.handle += ENTRY_SIZE;\n        return handle;\n    };\n\n    Heap.prototype.finishMalloc = function finishMalloc(handle, scopeSize) {\n        var start = this.table[handle];\n        var finish = this.offset;\n        var instructionSize = finish - start;\n        var info = encodeTableInfo(instructionSize, scopeSize, TableSlotState.Allocated);\n        this.table[handle + INFO_OFFSET] = info;\n    };\n\n    Heap.prototype.size = function size() {\n        return this.offset;\n    };\n    // It is illegal to close over this address, as compaction\n    // may move it. However, it is legal to use this address\n    // multiple times between compactions.\n\n\n    Heap.prototype.getaddr = function getaddr(handle) {\n        return this.table[handle];\n    };\n\n    Heap.prototype.gethandle = function gethandle(address) {\n        this.table.push(address, encodeTableInfo(0, 0, TableSlotState.Pointer));\n        var handle = this.handle;\n        this.handle += ENTRY_SIZE;\n        return handle;\n    };\n\n    Heap.prototype.sizeof = function sizeof(handle) {\n        return -1;\n    };\n\n    Heap.prototype.scopesizeof = function scopesizeof(handle) {\n        var info = this.table[handle + INFO_OFFSET];\n        return (info & SCOPE_MASK) >> 16;\n    };\n\n    Heap.prototype.free = function free(handle) {\n        var info = this.table[handle + INFO_OFFSET];\n        this.table[handle + INFO_OFFSET] = changeState(info, TableSlotState.Freed);\n    };\n    /**\n     * The heap uses the [Mark-Compact Algorithm](https://en.wikipedia.org/wiki/Mark-compact_algorithm) to shift\n     * reachable memory to the bottom of the heap and freeable\n     * memory to the top of the heap. When we have shifted all\n     * the reachable memory to the top of the heap, we move the\n     * offset to the next free position.\n     */\n\n\n    Heap.prototype.compact = function compact() {\n        var compactedSize = 0;\n        var table = this.table,\n            length = this.table.length,\n            heap = this.heap;\n\n        for (var i = 0; i < length; i += ENTRY_SIZE) {\n            var offset = table[i];\n            var info = table[i + INFO_OFFSET];\n            var size = info & SIZE_MASK;\n            var state = info & STATE_MASK >> 30;\n            if (state === TableSlotState.Purged) {\n                continue;\n            } else if (state === TableSlotState.Freed) {\n                // transition to \"already freed\" aka \"purged\"\n                // a good improvement would be to reuse\n                // these slots\n                table[i + INFO_OFFSET] = changeState(info, TableSlotState.Purged);\n                compactedSize += size;\n            } else if (state === TableSlotState.Allocated) {\n                for (var j = offset; j <= i + size; j++) {\n                    heap[j - compactedSize] = heap[j];\n                }\n                table[i] = offset - compactedSize;\n            } else if (state === TableSlotState.Pointer) {\n                table[i] = offset - compactedSize;\n            }\n        }\n        this.offset = this.offset - compactedSize;\n    };\n\n    Heap.prototype.capture = function capture() {\n        // Only called in eager mode\n        var buffer = slice(this.heap, 0, this.offset);\n        return {\n            handle: this.handle,\n            table: this.table,\n            buffer: buffer\n        };\n    };\n\n    return Heap;\n}();\nvar WriteOnlyProgram = function () {\n    function WriteOnlyProgram() {\n        var constants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new WriteOnlyConstants();\n        var heap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Heap();\n        classCallCheck(this, WriteOnlyProgram);\n\n        this.constants = constants;\n        this.heap = heap;\n        this._opcode = new Opcode(this.heap);\n    }\n\n    WriteOnlyProgram.prototype.opcode = function opcode(offset) {\n        this._opcode.offset = offset;\n        return this._opcode;\n    };\n\n    return WriteOnlyProgram;\n}();\n\nvar Program = function (_WriteOnlyProgram) {\n    inherits(Program, _WriteOnlyProgram);\n\n    function Program() {\n        classCallCheck(this, Program);\n        return possibleConstructorReturn(this, _WriteOnlyProgram.apply(this, arguments));\n    }\n\n    return Program;\n}(WriteOnlyProgram);\nfunction slice(arr, start, end) {\n    if (arr instanceof Uint16Array) {\n        if (arr.slice !== undefined) {\n            return arr.slice(start, end).buffer;\n        }\n        var ret = new Uint16Array(end);\n        for (; start < end; start++) {\n            ret[start] = arr[start];\n        }\n        return ret.buffer;\n    }\n    return null;\n}\n\nfunction buildAction(vm, _args) {\n    var componentRef = vm.getSelf();\n    var args = _args.capture();\n    var actionFunc = args.positional.at(0).value();\n    if (typeof actionFunc !== 'function') {\n        throwNoActionError(actionFunc, args.positional.at(0));\n    }\n    return new RootReference$1(function action() {\n        var curriedArgs = args.positional.value();\n        // Consume the action function that was already captured above.\n        curriedArgs.shift();\n        curriedArgs.push.apply(curriedArgs, arguments);\n        // Invoke the function with the component as the context, the curried\n        // arguments passed to `{{action}}`, and the arguments the bound function\n        // was invoked with.\n        actionFunc.apply(componentRef && componentRef.value(), curriedArgs);\n    });\n}\nfunction throwNoActionError(actionFunc, actionFuncReference) {\n    var referenceInfo = debugInfoForReference(actionFuncReference);\n    throw new Error('You tried to create an action with the {{action}} helper, but the first argument ' + referenceInfo + 'was ' + (typeof actionFunc === 'undefined' ? 'undefined' : _typeof(actionFunc)) + ' instead of a function.');\n}\nfunction debugInfoForReference(reference) {\n    var message = '';\n    var parent = void 0;\n    var property = void 0;\n    if (reference === null || reference === undefined) {\n        return message;\n    }\n    if ('parent' in reference && 'property' in reference) {\n        parent = reference['parent'].value();\n        property = reference['property'];\n    } else if ('_parentValue' in reference && '_propertyKey' in reference) {\n        parent = reference['_parentValue'];\n        property = reference['_propertyKey'];\n    }\n    if (property !== undefined) {\n        message += '(\\'' + property + '\\' on ' + debugName(parent) + ') ';\n    }\n    return message;\n}\nfunction debugName(obj) {\n    var objType = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n    if (obj === null || obj === undefined) {\n        return objType;\n    } else if (objType === 'number' || objType === 'boolean') {\n        return obj.toString();\n    } else {\n        if (obj['debugName']) {\n            return obj['debugName'];\n        }\n        try {\n            return JSON.stringify(obj);\n        } catch (e) {}\n        return obj.toString();\n    }\n}\n\nvar TypedRegistry = function () {\n    function TypedRegistry() {\n        classCallCheck(this, TypedRegistry);\n\n        this.byName = dict();\n        this.byHandle = dict();\n    }\n\n    TypedRegistry.prototype.hasName = function hasName(name) {\n        return name in this.byName;\n    };\n\n    TypedRegistry.prototype.getHandle = function getHandle(name) {\n        return this.byName[name];\n    };\n\n    TypedRegistry.prototype.hasHandle = function hasHandle(name) {\n        return name in this.byHandle;\n    };\n\n    TypedRegistry.prototype.getByHandle = function getByHandle(handle) {\n        return this.byHandle[handle];\n    };\n\n    TypedRegistry.prototype.register = function register(handle, name, value) {\n        this.byHandle[handle] = value;\n        this.byName[name] = handle;\n    };\n\n    return TypedRegistry;\n}();\n\nvar SimplePathReference = function () {\n    function SimplePathReference(parent, property) {\n        classCallCheck(this, SimplePathReference);\n\n        this.tag = VOLATILE_TAG;\n        this.parent = parent;\n        this.property = property;\n    }\n\n    SimplePathReference.prototype.value = function value() {\n        return this.parent.value()[this.property];\n    };\n\n    SimplePathReference.prototype.get = function get$$1(prop) {\n        return new SimplePathReference(this, prop);\n    };\n\n    return SimplePathReference;\n}();\nvar HelperReference = function () {\n    function HelperReference(helper, args) {\n        classCallCheck(this, HelperReference);\n\n        this.tag = VOLATILE_TAG;\n        this.helper = helper;\n        this.args = args.capture();\n    }\n\n    HelperReference.prototype.value = function value() {\n        var helper = this.helper,\n            args = this.args;\n\n        return helper(args.positional.value(), args.named.value());\n    };\n\n    HelperReference.prototype.get = function get$$1(prop) {\n        return new SimplePathReference(this, prop);\n    };\n\n    return HelperReference;\n}();\n\nvar RuntimeResolver = function () {\n    function RuntimeResolver(owner) {\n        classCallCheck(this, RuntimeResolver);\n\n        this.owner = owner;\n        this.handleLookup = [];\n        this.cache = {\n            component: new TypedRegistry(),\n            template: new TypedRegistry(),\n            compiledTemplate: new TypedRegistry(),\n            helper: new TypedRegistry(),\n            manager: new TypedRegistry(),\n            modifier: new TypedRegistry()\n        };\n    }\n\n    RuntimeResolver.prototype.setCompileOptions = function setCompileOptions(compileOptions) {\n        this.templateOptions = compileOptions;\n    };\n\n    RuntimeResolver.prototype.lookup = function lookup(type, name, referrer) {\n        if (this.cache[type].hasName(name)) {\n            return this.cache[type].getHandle(name);\n        } else {\n            return null;\n        }\n    };\n\n    RuntimeResolver.prototype.register = function register(type, name, value) {\n        var registry = this.cache[type];\n        var handle = this.handleLookup.length;\n        this.handleLookup.push(registry);\n        this.cache[type].register(handle, name, value);\n        return handle;\n    };\n\n    RuntimeResolver.prototype.lookupModifier = function lookupModifier(name, meta) {\n        var handle = this.lookup('modifier', name);\n        if (handle === null) {\n            throw new Error(\"Modifier for \" + name + \" not found.\");\n        }\n        return handle;\n    };\n\n    RuntimeResolver.prototype.compileTemplate = function compileTemplate(name, layout) {\n        if (!this.cache.compiledTemplate.hasName(name)) {\n            var serializedTemplate = this.resolve(layout);\n            var block = serializedTemplate.block,\n                meta = serializedTemplate.meta,\n                id = serializedTemplate.id;\n\n            var parsedBlock = JSON.parse(block);\n            var template = new ScannableTemplate(this.templateOptions, { id: id, block: parsedBlock, referrer: meta }).asLayout();\n            var invocation = {\n                handle: template.compile(),\n                symbolTable: template.symbolTable\n            };\n            this.register('compiledTemplate', name, invocation);\n            return invocation;\n        }\n        var handle = this.lookup('compiledTemplate', name);\n        return this.resolve(handle);\n    };\n\n    RuntimeResolver.prototype.registerHelper = function registerHelper(name, helper) {\n        var glimmerHelper = function glimmerHelper(_vm, args) {\n            return new HelperReference(helper, args);\n        };\n        return this.register('helper', name, glimmerHelper);\n    };\n\n    RuntimeResolver.prototype.registerInternalHelper = function registerInternalHelper(name, helper) {\n        this.register('helper', name, helper);\n    };\n\n    RuntimeResolver.prototype.registerComponent = function registerComponent(name, resolvedSpecifier, Component$$1, template) {\n        var templateEntry = this.registerTemplate(resolvedSpecifier, template);\n        var manager = this.managerFor(templateEntry.meta.managerId);\n        var definition = new ComponentDefinition(name, manager, Component$$1, templateEntry.handle);\n        return this.register('component', name, definition);\n    };\n\n    RuntimeResolver.prototype.lookupComponentHandle = function lookupComponentHandle(name, referrer) {\n        if (!this.cache.component.hasName(name)) {\n            this.lookupComponent(name, referrer);\n        }\n        return this.lookup('component', name, referrer);\n    };\n\n    RuntimeResolver.prototype.managerFor = function managerFor() {\n        var managerId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';\n\n        var manager = void 0;\n        if (!this.cache.manager.hasName(managerId)) {\n            var rootName = this.owner.rootName;\n\n            manager = this.owner.lookup(\"component-manager:/\" + rootName + \"/component-managers/\" + managerId);\n            if (!manager) {\n                throw new Error(\"No component manager found for ID \" + managerId + \".\");\n            }\n            this.register('manager', managerId, manager);\n            return manager;\n        } else {\n            var handle = this.cache.manager.getHandle(managerId);\n            return this.cache.manager.getByHandle(handle);\n        }\n    };\n\n    RuntimeResolver.prototype.registerTemplate = function registerTemplate(resolvedSpecifier, template) {\n        return {\n            name: resolvedSpecifier,\n            handle: this.register('template', resolvedSpecifier, template),\n            meta: template.meta\n        };\n    };\n\n    RuntimeResolver.prototype.lookupComponent = function lookupComponent(name, meta) {\n        var handle = void 0;\n        if (!this.cache.component.hasName(name)) {\n            var specifier = expect(this.identifyComponent(name, meta), \"Could not find the component '\" + name + \"'\");\n            var template = this.owner.lookup('template', specifier);\n            var componentSpecifier = this.owner.identify('component', specifier);\n            var componentFactory = null;\n            if (componentSpecifier !== undefined) {\n                componentFactory = this.owner.factoryFor(componentSpecifier);\n            } else {\n                componentFactory = {\n                    create: function create(injections) {\n                        return Component.create(injections);\n                    }\n                };\n            }\n            handle = this.registerComponent(name, specifier, componentFactory, template);\n        } else {\n            handle = this.lookup('component', name, meta);\n        }\n        return this.resolve(handle);\n    };\n\n    RuntimeResolver.prototype.lookupHelper = function lookupHelper(name, meta) {\n        if (!this.cache.helper.hasName(name)) {\n            var owner = this.owner;\n            var relSpecifier = \"helper:\" + name;\n            var referrer = meta.specifier;\n            var specifier = owner.identify(relSpecifier, referrer);\n            if (specifier === undefined) {\n                return null;\n            }\n            var helper = this.owner.lookup(specifier, meta.specifier);\n            return this.registerHelper(name, helper);\n        }\n        return this.lookup('helper', name, meta);\n    };\n\n    RuntimeResolver.prototype.lookupPartial = function lookupPartial(name, meta) {\n        throw new Error(\"Partials are not available in Glimmer applications.\");\n    };\n\n    RuntimeResolver.prototype.resolve = function resolve(handle) {\n        var registry = this.handleLookup[handle];\n        return registry.getByHandle(handle);\n    };\n\n    RuntimeResolver.prototype.identifyComponent = function identifyComponent(name, meta) {\n        var owner = this.owner;\n        var relSpecifier = \"template:\" + name;\n        var referrer = meta.specifier;\n        var specifier = owner.identify(relSpecifier, referrer);\n        if (specifier === undefined && owner.identify(\"component:\" + name, referrer)) {\n            throw new Error(\"The component '\" + name + \"' is missing a template. All components must have a template. Make sure there is a template.hbs in the component directory.\");\n        }\n        return specifier;\n    };\n\n    return RuntimeResolver;\n}();\n\nvar mainTemplate = { \"id\": \"j7SGa6Pm\", \"block\": \"{\\\"symbols\\\":[\\\"root\\\"],\\\"statements\\\":[[4,\\\"each\\\",[[22,[\\\"roots\\\"]]],[[\\\"key\\\"],[\\\"id\\\"]],{\\\"statements\\\":[[4,\\\"in-element\\\",[[21,1,[\\\"parent\\\"]]],[[\\\"guid\\\",\\\"nextSibling\\\"],[\\\"%cursor:0%\\\",[21,1,[\\\"nextSibling\\\"]]]],{\\\"statements\\\":[[1,[26,\\\"component\\\",[[21,1,[\\\"component\\\"]]],null],false]],\\\"parameters\\\":[]},null]],\\\"parameters\\\":[1]},null]],\\\"hasEval\\\":false}\", \"meta\": { \"specifier\": \"template:/-application/application/src/templates/main\" } };\n\nvar CompileTimeLookup = function () {\n    function CompileTimeLookup(resolver) {\n        classCallCheck(this, CompileTimeLookup);\n\n        this.resolver = resolver;\n    }\n\n    CompileTimeLookup.prototype.getComponentDefinition = function getComponentDefinition(handle) {\n        var spec = this.resolver.resolve(handle);\n        debugAssert(!!spec, 'Couldn\\'t find a template for ' + handle);\n        return spec;\n    };\n\n    CompileTimeLookup.prototype.getCapabilities = function getCapabilities(handle) {\n        var definition = this.getComponentDefinition(handle);\n        var manager = definition.manager,\n            state = definition.state;\n\n        return manager.getCapabilities(state);\n    };\n\n    CompileTimeLookup.prototype.getLayout = function getLayout(handle) {\n        var definition = this.getComponentDefinition(handle);\n        var manager = definition.manager;\n\n        var invocation = manager.getLayout(definition, this.resolver);\n        return {\n            compile: function compile() {\n                return invocation.handle;\n            },\n\n            symbolTable: invocation.symbolTable\n        };\n    };\n\n    CompileTimeLookup.prototype.lookupHelper = function lookupHelper(name, referrer) {\n        return this.resolver.lookupHelper(name, referrer);\n    };\n\n    CompileTimeLookup.prototype.lookupModifier = function lookupModifier(name, referrer) {\n        return this.resolver.lookupModifier(name, referrer);\n    };\n\n    CompileTimeLookup.prototype.lookupComponentSpec = function lookupComponentSpec(name, referrer) {\n        return this.resolver.lookupComponentHandle(name, referrer);\n    };\n\n    CompileTimeLookup.prototype.lookupPartial = function lookupPartial(name, referrer) {\n        return this.resolver.lookupPartial(name, referrer);\n    };\n\n    return CompileTimeLookup;\n}();\n\nvar Environment$1 = function (_GlimmerEnvironment) {\n    inherits(Environment$$1, _GlimmerEnvironment);\n\n    Environment$$1.create = function create() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        options.document = options.document || self.document;\n        options.appendOperations = options.appendOperations || new DOMTreeConstruction(options.document);\n        return new Environment$$1(options);\n    };\n\n    function Environment$$1(options) {\n        classCallCheck(this, Environment$$1);\n\n        var _this = possibleConstructorReturn(this, _GlimmerEnvironment.call(this, { appendOperations: options.appendOperations, updateOperations: new DOMChanges$1(options.document || document) }));\n\n        setOwner(_this, getOwner(options));\n        var resolver = _this.resolver = new RuntimeResolver(getOwner(_this));\n        var program = _this.program = new Program(new LazyConstants(resolver));\n        var macros = new Macros();\n        var lookup = new CompileTimeLookup(resolver);\n        _this.compileOptions = {\n            program: program,\n            macros: macros,\n            lookup: lookup,\n            Builder: LazyOpcodeBuilder\n        };\n        _this.resolver.setCompileOptions(_this.compileOptions);\n        resolver.registerTemplate('main', mainTemplate);\n        resolver.registerInternalHelper('action', buildAction);\n        resolver.registerHelper('if', function (params) {\n            return params[0] ? params[1] : params[2];\n        });\n        // TODO - required for `protocolForURL` - seek alternative approach\n        // e.g. see `installPlatformSpecificProtocolForURL` in Ember\n        _this.uselessAnchor = options.document.createElement('a');\n        return _this;\n    }\n\n    Environment$$1.prototype.protocolForURL = function protocolForURL(url) {\n        // TODO - investigate alternative approaches\n        // e.g. see `installPlatformSpecificProtocolForURL` in Ember\n        this.uselessAnchor.href = url;\n        return this.uselessAnchor.protocol;\n    };\n\n    Environment$$1.prototype.iterableFor = function iterableFor(ref, keyPath) {\n        var keyFor = void 0;\n        if (!keyPath) {\n            throw new Error('Must specify a key for #each');\n        }\n        switch (keyPath) {\n            case '@index':\n                keyFor = function keyFor(_, index) {\n                    return String(index);\n                };\n                break;\n            case '@primitive':\n                keyFor = function keyFor(item) {\n                    return String(item);\n                };\n                break;\n            default:\n                keyFor = function keyFor(item) {\n                    return item[keyPath];\n                };\n                break;\n        }\n        return new Iterable(ref, keyFor);\n    };\n\n    return Environment$$1;\n}(Environment);\n\nvar Application = function () {\n    function Application(options) {\n        classCallCheck(this, Application);\n\n        this._roots = [];\n        this._rootsIndex = 0;\n        this._initializers = [];\n        this._initialized = false;\n        this._rendering = false;\n        this._rendered = false;\n        this._scheduled = false;\n        this._notifiers = [];\n        this.rootName = options.rootName;\n        this.resolver = options.resolver;\n        this.document = options.document || typeof window !== 'undefined' && window.document;\n    }\n    /**\n     * Renders a component by name into the provided element, and optionally\n     * adjacent to the provided nextSibling element.\n     *\n     * ## Examples\n     *\n     * ```js\n     * app.renderComponent('MyComponent', document.body, document.getElementById('my-footer'));\n     * ```\n     */\n\n\n    Application.prototype.renderComponent = function renderComponent(component, parent) {\n        var nextSibling = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        this._roots.push({ id: this._rootsIndex++, component: component, parent: parent, nextSibling: nextSibling });\n        this.scheduleRerender();\n    };\n    /**\n     * Initializes the application and renders any components that have been\n     * registered via `renderComponent()`.\n     */\n\n\n    Application.prototype.boot = function boot() {\n        this.initialize();\n        this.env = this.lookup('environment:/' + this.rootName + '/main/main');\n        this._render();\n    };\n    /**\n     * Schedules all components to revalidate and potentially update the DOM to\n     * reflect any changes to underlying component state.\n     *\n     * Generally speaking, you  should avoid calling `scheduleRerender()`\n     * manually. Instead, use tracked properties on components and models, which\n     * invoke this method for you automatically when appropriate.\n     */\n\n\n    Application.prototype.scheduleRerender = function scheduleRerender() {\n        var _this = this;\n\n        if (this._scheduled || !this._rendered) return;\n        this._rendering = true;\n        this._scheduled = true;\n        requestAnimationFrame(function () {\n            _this._scheduled = false;\n            _this._rerender();\n            _this._rendering = false;\n        });\n    };\n    /** @hidden */\n\n\n    Application.prototype.initialize = function initialize() {\n        this.initRegistry();\n        this.initContainer();\n    };\n    /** @hidden */\n\n\n    Application.prototype.registerInitializer = function registerInitializer(initializer) {\n        this._initializers.push(initializer);\n    };\n    /**\n     * @hidden\n     *\n     * Initializes the registry, which maps names to objects in the system. Addons\n     * and subclasses can customize the behavior of a Glimmer application by\n     * overriding objects in the registry.\n     */\n\n\n    Application.prototype.initRegistry = function initRegistry() {\n        var registry = this._registry = new Registry();\n        // Create ApplicationRegistry as a proxy to the underlying registry\n        // that will only be available during `initialize`.\n        var appRegistry = new ApplicationRegistry(this._registry, this.resolver);\n        registry.register('environment:/' + this.rootName + '/main/main', Environment$1);\n        registry.registerOption('helper', 'instantiate', false);\n        registry.registerOption('template', 'instantiate', false);\n        registry.register('document:/' + this.rootName + '/main/main', this.document);\n        registry.registerOption('document', 'instantiate', false);\n        registry.registerInjection('environment', 'document', 'document:/' + this.rootName + '/main/main');\n        registry.registerInjection('component-manager', 'env', 'environment:/' + this.rootName + '/main/main');\n        var initializers = this._initializers;\n        for (var i = 0; i < initializers.length; i++) {\n            initializers[i].initialize(appRegistry);\n        }\n        this._initialized = true;\n    };\n    /**\n     * @hidden\n     *\n     * Initializes the container, which stores instances of objects that come from\n     * the registry.\n     */\n\n\n    Application.prototype.initContainer = function initContainer() {\n        var _this2 = this;\n\n        this._container = new Container(this._registry, this.resolver);\n        // Inject `this` (the app) as the \"owner\" of every object instantiated\n        // by its container.\n        this._container.defaultInjections = function (specifier) {\n            var hash = {};\n            setOwner(hash, _this2);\n            return hash;\n        };\n    };\n    /**\n     * @hidden\n     *\n     * The compiled `main` root layout template.\n     */\n\n\n    /** @hidden\n     *\n     * Ensures the DOM is up-to-date by performing a revalidation on the root\n     * template's render result. This method should not be called directly;\n     * instead, any mutations in the program that could cause side-effects should\n     * call `scheduleRerender()`, which ensures that DOM updates only happen once\n     * at the end of the browser's event loop.\n     */\n    Application.prototype._rerender = function _rerender() {\n        var env = this.env,\n            result = this._result;\n\n        if (!result) {\n            throw new Error('Cannot re-render before initial render has completed');\n        }\n        try {\n            env.begin();\n            result.rerender();\n            env.commit();\n            this._didRender();\n        } catch (err) {\n            this._didError(err);\n        }\n    };\n    /** @hidden */\n\n\n    Application.prototype._render = function _render() {\n        var env = this.env,\n            templateIterator = this.templateIterator;\n\n        try {\n            // Begin a new transaction. The transaction stores things like component\n            // lifecycle events so they can be flushed once rendering has completed.\n            env.begin();\n            // Iterate the template iterator, executing the compiled template program\n            // until there are no more instructions left to execute.\n            var result = void 0;\n            do {\n                result = templateIterator.next();\n            } while (!result.done);\n            // Finally, commit the transaction and flush component lifecycle hooks.\n            env.commit();\n            this._result = result.value;\n            this._didRender();\n        } catch (err) {\n            this._didError(err);\n            throw err;\n        }\n    };\n\n    Application.prototype._didRender = function _didRender() {\n        this._rendered = true;\n        var notifiers = this._notifiers;\n        this._notifiers = [];\n        notifiers.forEach(function (n) {\n            return n[0]();\n        });\n    };\n\n    Application.prototype._didError = function _didError(err) {\n        var notifiers = this._notifiers;\n        this._notifiers = [];\n        notifiers.forEach(function (n) {\n            return n[1](err);\n        });\n    };\n    /**\n     * Owner interface implementation\n     *\n     * @hidden\n     */\n\n\n    Application.prototype.identify = function identify(specifier, referrer) {\n        return this.resolver.identify(specifier, referrer);\n    };\n    /** @hidden */\n\n\n    Application.prototype.factoryFor = function factoryFor(specifier, referrer) {\n        return this._container.factoryFor(this.identify(specifier, referrer));\n    };\n    /** @hidden */\n\n\n    Application.prototype.lookup = function lookup(specifier, referrer) {\n        return this._container.lookup(this.identify(specifier, referrer));\n    };\n\n    createClass(Application, [{\n        key: 'mainLayout',\n        get: function get$$1() {\n            return templateFactory(mainTemplate).create(this.env.compileOptions);\n        }\n        /**\n         * @hidden\n         *\n         * Configures and returns a template iterator for the root template, appropriate\n         * for performing the initial render of the Glimmer application.\n         */\n\n    }, {\n        key: 'templateIterator',\n        get: function get$$1() {\n            var env = this.env,\n                mainLayout = this.mainLayout;\n            // Create the template context for the root `main` template, which just\n            // contains the array of component roots. Any property references in that\n            // template will be looked up from this object.\n\n            var self = new RootReference$1({ roots: this._roots });\n            // Create an empty root scope.\n            var dynamicScope = new DynamicScope();\n            // The cursor tells the template which element to render into.\n            var cursor = {\n                element: this.document.body,\n                nextSibling: null\n            };\n            return mainLayout.renderLayout({\n                env: env,\n                self: self,\n                dynamicScope: dynamicScope,\n                builder: clientBuilder(env, cursor)\n            });\n        }\n    }]);\n    return Application;\n}();\n\n// TODO - use symbol\n\nfunction isSpecifierStringAbsolute$1(specifier) {\n    var _specifier$split = specifier.split(':'),\n        type = _specifier$split[0],\n        path = _specifier$split[1];\n\n    return !!(type && path && path.indexOf('/') === 0 && path.split('/').length > 3);\n}\nfunction isSpecifierObjectAbsolute$1(specifier) {\n    return specifier.rootName !== undefined && specifier.collection !== undefined && specifier.name !== undefined && specifier.type !== undefined;\n}\nfunction serializeSpecifier$1(specifier) {\n    var type = specifier.type;\n    var path = serializeSpecifierPath$1(specifier);\n    if (path) {\n        return type + ':' + path;\n    } else {\n        return type;\n    }\n}\nfunction serializeSpecifierPath$1(specifier) {\n    var path = [];\n    if (specifier.rootName) {\n        path.push(specifier.rootName);\n    }\n    if (specifier.collection) {\n        path.push(specifier.collection);\n    }\n    if (specifier.namespace) {\n        path.push(specifier.namespace);\n    }\n    if (specifier.name) {\n        path.push(specifier.name);\n    }\n    if (path.length > 0) {\n        var fullPath = path.join('/');\n        if (isSpecifierObjectAbsolute$1(specifier)) {\n            fullPath = '/' + fullPath;\n        }\n        return fullPath;\n    }\n}\nfunction deserializeSpecifier$1(specifier) {\n    var obj = {};\n    if (specifier.indexOf(':') > -1) {\n        var _specifier$split2 = specifier.split(':'),\n            type = _specifier$split2[0],\n            path = _specifier$split2[1];\n\n        obj.type = type;\n        var pathSegments = void 0;\n        if (path.indexOf('/') === 0) {\n            pathSegments = path.substr(1).split('/');\n            obj.rootName = pathSegments.shift();\n            obj.collection = pathSegments.shift();\n        } else {\n            pathSegments = path.split('/');\n        }\n        if (pathSegments.length > 0) {\n            obj.name = pathSegments.pop();\n            if (pathSegments.length > 0) {\n                obj.namespace = pathSegments.join('/');\n            }\n        }\n    } else {\n        obj.type = specifier;\n    }\n    return obj;\n}\n\nfunction assert$1(description, test) {\n    if (!test) {\n        throw new Error('Assertion Failed: ' + description);\n    }\n}\n\nfunction detectLocalResolutionCollection(specifier) {\n    var namespace = specifier.namespace,\n        collection = specifier.collection;\n    // Look for the local-most private collection contained in the namespace\n    // (which will appear closest to the end of the string)\n\n    var startPos = namespace.lastIndexOf('/-');\n    if (startPos > -1) {\n        startPos += 2;\n        var endPos = namespace.indexOf('/', startPos);\n        collection = namespace.slice(startPos, endPos > -1 ? endPos : undefined);\n    }\n    return collection;\n}\n\nvar Resolver = function () {\n    function Resolver(config, registry) {\n        classCallCheck(this, Resolver);\n\n        this.config = config;\n        this.registry = registry;\n    }\n\n    Resolver.prototype.identify = function identify(specifier, referrer) {\n        if (isSpecifierStringAbsolute$1(specifier)) {\n            return specifier;\n        }\n        var s = deserializeSpecifier$1(specifier);\n        var result = void 0;\n        if (referrer) {\n            var r = deserializeSpecifier$1(referrer);\n            if (isSpecifierObjectAbsolute$1(r)) {\n                assert$1('Specifier must not include a rootName, collection, or namespace when combined with an absolute referrer', s.rootName === undefined && s.collection === undefined && s.namespace === undefined);\n                s.rootName = r.rootName;\n                s.collection = r.collection;\n                var definitiveCollection = this._definitiveCollection(s.type);\n                if (!s.name) {\n                    /*\n                     * For specifiers without a name use the referrer's name and\n                     * do not fallback to any other resolution rules.\n                     */\n                    s.namespace = r.namespace;\n                    s.name = r.name;\n                    return this._serializeAndVerify(s);\n                }\n                s.namespace = r.namespace ? r.namespace + '/' + r.name : r.name;\n                if (detectLocalResolutionCollection(s) === definitiveCollection) {\n                    /*\n                     * For specifiers with a name, try local resolution. Based on\n                     * the referrer.\n                     */\n                    if (result = this._serializeAndVerify(s)) {\n                        return result;\n                    }\n                }\n                // Look for a private collection in the referrer's namespace\n                if (definitiveCollection) {\n                    s.namespace += '/-' + definitiveCollection;\n                    if (result = this._serializeAndVerify(s)) {\n                        return result;\n                    }\n                }\n                // Because local and private resolution has failed, clear all but `name` and `type`\n                // to proceed with top-level resolution\n                s.rootName = s.collection = s.namespace = undefined;\n            } else {\n                assert$1('Referrer must either be \"absolute\" or include a `type` to determine the associated type', r.type);\n                // Look in the definitive collection for the associated type\n                s.collection = this._definitiveCollection(r.type);\n                if (!s.namespace) {\n                    s.namespace = r.rootName;\n                }\n                assert$1('\\'' + r.type + '\\' does not have a definitive collection', s.collection);\n            }\n        }\n        // If the collection is unspecified, use the definitive collection for the `type`\n        if (!s.collection) {\n            s.collection = this._definitiveCollection(s.type);\n            assert$1('\\'' + s.type + '\\' does not have a definitive collection', s.collection);\n        }\n        if (!s.rootName) {\n            // If the root name is unspecified, try the app's `rootName` first\n            s.rootName = this.config.app.rootName || 'app';\n            if (result = this._serializeAndVerify(s)) {\n                return result;\n            }\n            // Then look for an addon with a matching `rootName`\n            if (s.namespace) {\n                s.rootName = s.namespace;\n                s.namespace = undefined;\n            } else {\n                s.rootName = s.name;\n                s.name = 'main';\n            }\n        }\n        if (result = this._serializeAndVerify(s)) {\n            return result;\n        }\n    };\n\n    Resolver.prototype.retrieve = function retrieve(specifier) {\n        return this.registry.get(specifier);\n    };\n\n    Resolver.prototype.resolve = function resolve(specifier, referrer) {\n        var id = this.identify(specifier, referrer);\n        if (id) {\n            return this.retrieve(id);\n        }\n    };\n\n    Resolver.prototype._definitiveCollection = function _definitiveCollection(type) {\n        var typeDef = this.config.types[type];\n        assert$1('\\'' + type + '\\' is not a recognized type', typeDef);\n        return typeDef.definitiveCollection;\n    };\n\n    Resolver.prototype._serializeAndVerify = function _serializeAndVerify(specifier) {\n        var serialized = serializeSpecifier$1(specifier);\n        if (this.registry.has(serialized)) {\n            return serialized;\n        }\n    };\n\n    return Resolver;\n}();\n\nvar BasicRegistry = function () {\n    function BasicRegistry() {\n        var entries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        classCallCheck(this, BasicRegistry);\n\n        this._entries = entries;\n    }\n\n    BasicRegistry.prototype.has = function has(specifier) {\n        return specifier in this._entries;\n    };\n\n    BasicRegistry.prototype.get = function get$$1(specifier) {\n        return this._entries[specifier];\n    };\n\n    return BasicRegistry;\n}();\n\nvar __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {\n    var c = arguments.length,\n        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n        d;\n    if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n        if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    }return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : new P(function (resolve) {\n                resolve(result.value);\n            }).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar SearchInput = function (_Component) {\n    inherits(SearchInput, _Component);\n\n    function SearchInput() {\n        classCallCheck(this, SearchInput);\n\n        var _this = possibleConstructorReturn(this, _Component.apply(this, arguments));\n\n        _this.state = {\n            query: '',\n            index: null,\n            results: {},\n            selectedResult: null,\n            isLoading: false,\n            showResults: false\n        };\n        return _this;\n    }\n    // lifecycle hooks\n    // actions\n\n\n    SearchInput.prototype.setQuery = function setQuery(event) {\n        var query = event.target.value.toLowerCase();\n        if (query && !this.state.index) {\n            this._loadIndex();\n        }\n        this.state = Object.assign({}, this.state, { query: query });\n        this.performSearch(query);\n    };\n\n    SearchInput.prototype.openResult = function openResult(result) {\n        window.location.href = result.url;\n    };\n\n    SearchInput.prototype.openSelectedResult = function openSelectedResult(event) {\n        var result = this.state.selectedResult;\n        event.preventDefault();\n        if (result) {\n            this.openResult(result);\n        }\n    };\n\n    SearchInput.prototype.inputGainedFocus = function inputGainedFocus(event) {\n        if (this.state.query) {\n            this.showResults();\n        }\n    };\n\n    SearchInput.prototype.inputLostFocus = function inputLostFocus(event) {\n        this.hideResults();\n    };\n\n    SearchInput.prototype.inputKeydown = function inputKeydown(event) {\n        if (!this.state.showResults || !this.state.selectedResult) {\n            return;\n        }\n        if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n            var results = this.state.results && this.state.results.pages || [];\n            var result = this.state.selectedResult;\n            var currIndex = results.indexOf(result);\n            var newIndex = 0;\n            event.preventDefault();\n            if (event.key === 'ArrowDown') {\n                newIndex = currIndex + 1;\n                // loop to top\n                if (newIndex >= results.length) {\n                    newIndex = 0;\n                }\n            }\n            if (event.key === 'ArrowUp') {\n                newIndex = currIndex - 1;\n                // loop to bottom\n                if (newIndex < 0) {\n                    newIndex = results.length - 1;\n                }\n            }\n            var selectedResult = results[newIndex];\n            this.state = Object.assign({}, this.state, { selectedResult: selectedResult });\n        }\n    };\n    // functions\n\n\n    SearchInput.prototype.performSearch = function performSearch(query) {\n        var index = this.state.index || { pages: [] };\n        var results = { pages: [] };\n        var selectedResult = null;\n        if (query) {\n            results.pages = index.pages.filter(function (page) {\n                var matchedTerms = page.terms.filter(function (term) {\n                    return term.indexOf(query) > -1;\n                });\n                return matchedTerms.length > 0;\n            });\n        } else {\n            results.pages = [];\n        }\n        // highlight the first result\n        var _results$pages = results.pages;\n        selectedResult = _results$pages[0];\n\n        this.state = Object.assign({}, this.state, { results: results,\n            selectedResult: selectedResult });\n        if (query) {\n            this.showResults();\n        } else {\n            this.hideResults();\n        }\n    };\n\n    SearchInput.prototype.showResults = function showResults() {\n        if (this.state.showResults) {\n            return;\n        }\n        this.state = Object.assign({}, this.state, { showResults: true });\n    };\n\n    SearchInput.prototype.hideResults = function hideResults() {\n        if (!this.state.showResults) {\n            return;\n        }\n        this.state = Object.assign({}, this.state, { showResults: false });\n    };\n\n    SearchInput.prototype.clearResults = function clearResults() {\n        this.state = Object.assign({}, this.state, { query: '', results: [] });\n        this.hideResults();\n    };\n    // private functions\n\n\n    SearchInput.prototype._loadIndex = function _loadIndex() {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n            var indexUrl, request, json, index;\n            return regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                    switch (_context.prev = _context.next) {\n                        case 0:\n                            indexUrl = 'http://localhost:9999/search-index.json';\n\n                            if (!(this.state.index || this.state.isLoading)) {\n                                _context.next = 3;\n                                break;\n                            }\n\n                            return _context.abrupt(\"return\");\n\n                        case 3:\n                            this.state = Object.assign({}, this.state, { isLoading: true });\n                            // TODO: use proper URL depending on env\n                            _context.next = 6;\n                            return fetch(indexUrl);\n\n                        case 6:\n                            request = _context.sent;\n                            _context.next = 9;\n                            return request.json();\n\n                        case 9:\n                            json = _context.sent;\n                            index = this._generateIndex(json);\n\n                            this.state = Object.assign({}, this.state, { index: index, isLoading: false });\n                            this.performSearch(this.state.query);\n\n                        case 13:\n                        case \"end\":\n                            return _context.stop();\n                    }\n                }\n            }, _callee, this);\n        }));\n    };\n\n    SearchInput.prototype._generateIndex = function _generateIndex(json) {\n        var pages = json.pages.map(function (page) {\n            var keywords = page.keywords || [];\n            return {\n                url: page.url,\n                title: page.title,\n                terms: [page.title.toLowerCase()].concat(keywords)\n            };\n        });\n        return { pages: pages };\n    };\n\n    return SearchInput;\n}(Component);\n\n__decorate([tracked], SearchInput.prototype, \"state\", void 0);\n\nvar __ui_components_SearchInput_template__ = { \"id\": \"81erj4FV\", \"block\": \"{\\\"symbols\\\":[\\\"result\\\",\\\"@class\\\",\\\"@style\\\"],\\\"statements\\\":[[6,\\\"form\\\"],[10,\\\"action\\\",\\\"\\\"],[11,\\\"class\\\",[27,[\\\"relative gd-drop \\\",[26,\\\"if\\\",[[22,[\\\"state\\\",\\\"showResults\\\"]],\\\"active\\\"],null]]]],[11,\\\"onsubmit\\\",[26,\\\"action\\\",[[22,[\\\"openSelectedResult\\\"]]],null],null],[8],[0,\\\"\\\\n    \\\"],[6,\\\"input\\\"],[10,\\\"type\\\",\\\"text\\\"],[11,\\\"value\\\",[22,[\\\"state\\\",\\\"query\\\"]],null],[10,\\\"placeholder\\\",\\\"Search...\\\"],[11,\\\"class\\\",[21,2,[]],null],[11,\\\"style\\\",[21,3,[]],null],[10,\\\"autocomplete\\\",\\\"off\\\"],[11,\\\"oninput\\\",[26,\\\"action\\\",[[22,[\\\"setQuery\\\"]]],null],null],[11,\\\"onfocus\\\",[26,\\\"action\\\",[[22,[\\\"inputGainedFocus\\\"]]],null],null],[11,\\\"onblur\\\",[26,\\\"action\\\",[[22,[\\\"inputLostFocus\\\"]]],null],null],[11,\\\"onkeydown\\\",[26,\\\"action\\\",[[22,[\\\"inputKeydown\\\"]]],null],null],[8],[9],[0,\\\"\\\\n\\\\n\\\\n        \\\"],[6,\\\"ul\\\"],[10,\\\"id\\\",\\\"results\\\"],[10,\\\"class\\\",\\\"absolute z-999 bg-white o-0 br3 br--bottom anim-slow shadow-1-strong darkgrey dd-w2 trans-form-up pa0 f8 midgrey lh-copy list js-search-dropdown \\\"],[8],[0,\\\"\\\\n\\\"],[4,\\\"if\\\",[[22,[\\\"state\\\",\\\"isLoading\\\"]]],null,{\\\"statements\\\":[[0,\\\"                \\\"],[6,\\\"li\\\"],[10,\\\"class\\\",\\\"\\\"],[8],[0,\\\"Loading...\\\"],[9],[0,\\\"\\\\n\\\"]],\\\"parameters\\\":[]},{\\\"statements\\\":[[4,\\\"each\\\",[[22,[\\\"state\\\",\\\"results\\\",\\\"pages\\\"]]],[[\\\"key\\\"],[\\\"@index\\\"]],{\\\"statements\\\":[[0,\\\"                    \\\"],[6,\\\"li\\\"],[11,\\\"class\\\",[27,[[26,\\\"if\\\",[[26,\\\"eq\\\",[[21,1,[]],[22,[\\\"state\\\",\\\"selectedResult\\\"]]],null],\\\"bg-yellow\\\"],null]]]],[11,\\\"onmousedown\\\",[26,\\\"action\\\",[[22,[\\\"openResult\\\"]],[21,1,[]]],null],null],[8],[0,\\\"\\\\n                        \\\"],[6,\\\"a\\\"],[11,\\\"href\\\",[21,1,[\\\"url\\\"]],null],[10,\\\"class\\\",\\\"darkgrey-l2 hover-blue-d2 link db pl2 pr2 pt1 pb1\\\"],[8],[1,[21,1,[\\\"title\\\"]],false],[9],[0,\\\"\\\\n                    \\\"],[9],[0,\\\"\\\\n\\\"]],\\\"parameters\\\":[1]},{\\\"statements\\\":[[0,\\\"                    \\\"],[6,\\\"li\\\"],[10,\\\"class\\\",\\\"pa2 tc\\\"],[8],[0,\\\"No results found\\\"],[9],[0,\\\"\\\\n\\\"]],\\\"parameters\\\":[]}]],\\\"parameters\\\":[]}],[0,\\\"        \\\"],[9],[0,\\\"\\\\n\\\"],[9],[0,\\\"\\\\n\\\"]],\\\"hasEval\\\":false}\", \"meta\": { \"specifier\": \"template:/search-input/components/SearchInput\" } };\n\nvar __ui_components_SearchInputBrand_template__ = { \"id\": \"molihOa8\", \"block\": \"{\\\"symbols\\\":[],\\\"statements\\\":[[5,\\\"SearchInput\\\",[],[[\\\"@class\\\",\\\"@style\\\"],[\\\"pa2 br2 ba b--transparent bg-white middarkgrey whitney f8\\\",\\\"width: 210px\\\"]],{\\\"statements\\\":[],\\\"parameters\\\":[]}],[0,\\\"\\\\n\\\"]],\\\"hasEval\\\":false}\", \"meta\": { \"specifier\": \"template:/search-input/components/SearchInputBrand\" } };\n\nvar __ui_components_SearchInputProduct_template__ = { \"id\": \"hBKCmBta\", \"block\": \"{\\\"symbols\\\":[],\\\"statements\\\":[[5,\\\"SearchInput\\\",[],[[\\\"@class\\\"],[\\\"pa2 br2 ba b--transparent bg-white-10 white whitney f8 gh-nav-searchbox input-reset form-text\\\"]],{\\\"statements\\\":[],\\\"parameters\\\":[]}],[0,\\\"\\\\n\\\"]],\\\"hasEval\\\":false}\", \"meta\": { \"specifier\": \"template:/search-input/components/SearchInputProduct\" } };\n\nfunction eq(params) {\n    return params[0] === params[1];\n}\n\nvar moduleMap = { 'component:/search-input/components/SearchInput': SearchInput, 'template:/search-input/components/SearchInput': __ui_components_SearchInput_template__, 'template:/search-input/components/SearchInputBrand': __ui_components_SearchInputBrand_template__, 'template:/search-input/components/SearchInputProduct': __ui_components_SearchInputProduct_template__, 'helper:/search-input/components/eq': eq };\n\nvar resolverConfiguration = { \"app\": { \"name\": \"search-input\", \"rootName\": \"search-input\" }, \"types\": { \"application\": { \"definitiveCollection\": \"main\" }, \"component\": { \"definitiveCollection\": \"components\" }, \"component-test\": { \"unresolvable\": true }, \"helper\": { \"definitiveCollection\": \"components\" }, \"helper-test\": { \"unresolvable\": true }, \"renderer\": { \"definitiveCollection\": \"main\" }, \"template\": { \"definitiveCollection\": \"components\" } }, \"collections\": { \"main\": { \"types\": [\"application\", \"renderer\"] }, \"components\": { \"group\": \"ui\", \"types\": [\"component\", \"component-test\", \"template\", \"helper\", \"helper-test\"], \"defaultType\": \"component\", \"privateCollections\": [\"utils\"] }, \"styles\": { \"group\": \"ui\", \"unresolvable\": true }, \"utils\": { \"unresolvable\": true } } };\n\nvar App = function (_Application) {\n    inherits(App, _Application);\n\n    function App() {\n        classCallCheck(this, App);\n\n        var moduleRegistry = new BasicRegistry(moduleMap);\n        var resolver = new Resolver(resolverConfiguration, moduleRegistry);\n        return possibleConstructorReturn(this, _Application.call(this, {\n            resolver: resolver,\n            rootName: resolverConfiguration.app.rootName\n        }));\n    }\n\n    return App;\n}(Application);\n\n(function (self) {\n  'use strict';\n\n  if (self.fetch) {\n    return;\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && function () {\n      try {\n        new Blob();\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  if (support.arrayBuffer) {\n    var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];\n\n    var isDataView = function isDataView(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj);\n    };\n\n    var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n    };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name');\n    }\n    return name.toLowerCase();\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value;\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function next() {\n        var value = items.shift();\n        return { done: value === undefined, value: value };\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function () {\n        return iterator;\n      };\n    }\n\n    return iterator;\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function (value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function (header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function (name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function (name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ',' + value : value;\n  };\n\n  Headers.prototype['delete'] = function (name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function (name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null;\n  };\n\n  Headers.prototype.has = function (name) {\n    return this.map.hasOwnProperty(normalizeName(name));\n  };\n\n  Headers.prototype.set = function (name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function (callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function () {\n    var items = [];\n    this.forEach(function (value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items);\n  };\n\n  Headers.prototype.values = function () {\n    var items = [];\n    this.forEach(function (value) {\n      items.push(value);\n    });\n    return iteratorFor(items);\n  };\n\n  Headers.prototype.entries = function () {\n    var items = [];\n    this.forEach(function (value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items);\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'));\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function (resolve, reject) {\n      reader.onload = function () {\n        resolve(reader.result);\n      };\n      reader.onerror = function () {\n        reject(reader.error);\n      };\n    });\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise;\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise;\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('');\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0);\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer;\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function (body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        throw new Error('unsupported BodyInit type');\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function () {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected;\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob);\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob');\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]));\n        }\n      };\n\n      this.arrayBuffer = function () {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer);\n        }\n      };\n    }\n\n    this.text = function () {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected;\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob);\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text');\n      } else {\n        return Promise.resolve(this._bodyText);\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function () {\n        return this.text().then(decode);\n      };\n    }\n\n    this.json = function () {\n      return this.text().then(JSON.parse);\n    };\n\n    return this;\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method;\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read');\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests');\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function () {\n    return new Request(this, { body: this._bodyInit });\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body.trim().split('&').forEach(function (bytes) {\n      if (bytes) {\n        var split = bytes.split('=');\n        var name = split.shift().replace(/\\+/g, ' ');\n        var value = split.join('=').replace(/\\+/g, ' ');\n        form.append(decodeURIComponent(name), decodeURIComponent(value));\n      }\n    });\n    return form;\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    rawHeaders.split(/\\r?\\n/).forEach(function (line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers;\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = 'status' in options ? options.status : 200;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function () {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    });\n  };\n\n  Response.error = function () {\n    var response = new Response(null, { status: 0, statusText: '' });\n    response.type = 'error';\n    return response;\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function (url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code');\n    }\n\n    return new Response(null, { status: status, headers: { location: url } });\n  };\n\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n\n  self.fetch = function (input, init) {\n    return new Promise(function (resolve, reject) {\n      var request = new Request(input, init);\n      var xhr = new XMLHttpRequest();\n\n      xhr.onload = function () {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function () {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function () {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function (value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    });\n  };\n  self.fetch.polyfill = true;\n})(typeof self !== 'undefined' ? self : undefined);\n\n// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc = setTimeout;\n\nfunction noop() {}\n\n// Polyfill for Function.prototype.bind\nfunction bind(fn, thisArg) {\n  return function () {\n    fn.apply(thisArg, arguments);\n  };\n}\n\nfunction Promise$1(fn) {\n  if (!(this instanceof Promise$1)) throw new TypeError('Promises must be constructed via new');\n  if (typeof fn !== 'function') throw new TypeError('not a function');\n  this._state = 0;\n  this._handled = false;\n  this._value = undefined;\n  this._deferreds = [];\n\n  doResolve(fn, this);\n}\n\nfunction handle(self, deferred) {\n  while (self._state === 3) {\n    self = self._value;\n  }\n  if (self._state === 0) {\n    self._deferreds.push(deferred);\n    return;\n  }\n  self._handled = true;\n  Promise$1._immediateFn(function () {\n    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);\n      return;\n    }\n    var ret;\n    try {\n      ret = cb(self._value);\n    } catch (e) {\n      reject(deferred.promise, e);\n      return;\n    }\n    resolve(deferred.promise, ret);\n  });\n}\n\nfunction resolve(self, newValue) {\n  try {\n    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');\n    if (newValue && ((typeof newValue === 'undefined' ? 'undefined' : _typeof(newValue)) === 'object' || typeof newValue === 'function')) {\n      var then = newValue.then;\n      if (newValue instanceof Promise$1) {\n        self._state = 3;\n        self._value = newValue;\n        finale(self);\n        return;\n      } else if (typeof then === 'function') {\n        doResolve(bind(then, newValue), self);\n        return;\n      }\n    }\n    self._state = 1;\n    self._value = newValue;\n    finale(self);\n  } catch (e) {\n    reject(self, e);\n  }\n}\n\nfunction reject(self, newValue) {\n  self._state = 2;\n  self._value = newValue;\n  finale(self);\n}\n\nfunction finale(self) {\n  if (self._state === 2 && self._deferreds.length === 0) {\n    Promise$1._immediateFn(function () {\n      if (!self._handled) {\n        Promise$1._unhandledRejectionFn(self._value);\n      }\n    });\n  }\n\n  for (var i = 0, len = self._deferreds.length; i < len; i++) {\n    handle(self, self._deferreds[i]);\n  }\n  self._deferreds = null;\n}\n\nfunction Handler(onFulfilled, onRejected, promise) {\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, self) {\n  var done = false;\n  try {\n    fn(function (value) {\n      if (done) return;\n      done = true;\n      resolve(self, value);\n    }, function (reason) {\n      if (done) return;\n      done = true;\n      reject(self, reason);\n    });\n  } catch (ex) {\n    if (done) return;\n    done = true;\n    reject(self, ex);\n  }\n}\n\nPromise$1.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\nPromise$1.prototype.then = function (onFulfilled, onRejected) {\n  var prom = new this.constructor(noop);\n\n  handle(this, new Handler(onFulfilled, onRejected, prom));\n  return prom;\n};\n\nPromise$1.prototype['finally'] = function (callback) {\n  var constructor = this.constructor;\n  return this.then(function (value) {\n    return constructor.resolve(callback()).then(function () {\n      return value;\n    });\n  }, function (reason) {\n    return constructor.resolve(callback()).then(function () {\n      return constructor.reject(reason);\n    });\n  });\n};\n\nPromise$1.all = function (arr) {\n  return new Promise$1(function (resolve, reject) {\n    if (!arr || typeof arr.length === 'undefined') throw new TypeError('Promise.all accepts an array');\n    var args = Array.prototype.slice.call(arr);\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n\n    function res(i, val) {\n      try {\n        if (val && ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' || typeof val === 'function')) {\n          var then = val.then;\n          if (typeof then === 'function') {\n            then.call(val, function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n        args[i] = val;\n        if (--remaining === 0) {\n          resolve(args);\n        }\n      } catch (ex) {\n        reject(ex);\n      }\n    }\n\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise$1.resolve = function (value) {\n  if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise$1) {\n    return value;\n  }\n\n  return new Promise$1(function (resolve) {\n    resolve(value);\n  });\n};\n\nPromise$1.reject = function (value) {\n  return new Promise$1(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise$1.race = function (values) {\n  return new Promise$1(function (resolve, reject) {\n    for (var i = 0, len = values.length; i < len; i++) {\n      values[i].then(resolve, reject);\n    }\n  });\n};\n\n// Use polyfill for setImmediate for performance gains\nPromise$1._immediateFn = typeof setImmediate === 'function' && function (fn) {\n  setImmediate(fn);\n} || function (fn) {\n  setTimeoutFunc(fn, 0);\n};\n\nPromise$1._unhandledRejectionFn = function _unhandledRejectionFn(err) {\n  if (typeof console !== 'undefined' && console) {\n    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console\n  }\n};\n\nvar global$1 = function () {\n  // the only reliable means to get the global object is\n  // `Function('return this')()`\n  // However, this causes CSP violations in Chrome apps.\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global$1 !== 'undefined') {\n    return global$1;\n  }\n  throw new Error('unable to locate global object');\n}();\n\nif (!global$1.Promise) {\n  global$1.Promise = Promise$1;\n}\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!function (global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      prototype[method] = function (arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction ||\n    // For the native GeneratorFunction constructor, the best we can\n    // do is to check its .name property.\n    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  runtime.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function (arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" && hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function (unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n      // If enqueue has been called before, then we want to wait until\n      // all previous Promises have been resolved before calling invoke,\n      // so that results are always delivered in the correct order. If\n      // enqueue has not been called before, then it is important to\n      // call invoke immediately, without waiting on a callback to fire,\n      // so that the async generator function has the opportunity to do\n      // any necessary setup in a predictable way. This predictability\n      // is why the Promise constructor synchronously invokes its\n      // executor callback, and why async functions synchronously\n      // execute code before the first await. Since we implement simple\n      // async functions in terms of async generators, it is especially\n      // important to get this right, even though it requires care.\n      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg,\n      // Avoid propagating failures to Promises returned by later\n      // invocations of the iterator.\n      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function (innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));\n\n    return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n    : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function (object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function stop() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function complete(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n}(\n// In sloppy mode, unbound `this` refers to the global object, fallback to\n// Function constructor if we're in global strict mode. That is sadly a form\n// of indirect eval which violates Content Security Policy.\nfunction () {\n  return this;\n}() || Function(\"return this\")());\n\n// import polyfills for IE11\nvar app = new App();\nvar productElement = document.getElementById('product-search-input');\nvar brandElement = document.getElementById('brand-search-input');\nsetPropertyDidChange(function () {\n    app.scheduleRerender();\n});\napp.registerInitializer({\n    initialize: function initialize(registry) {\n        registry.register('component-manager:/' + app.rootName + '/component-managers/main', ComponentManager);\n    }\n});\nif (productElement) {\n    app.renderComponent('SearchInputProduct', productElement, null);\n}\nif (brandElement) {\n    app.renderComponent('SearchInputBrand', brandElement, null);\n}\napp.boot();\n\n})));\n\n//# sourceMappingURL=app.js.map\n"]}
{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BioDynaMo! A very warm welcome to BioDynaMo and thank you for your interest! This guide will help you get started. It introduces you to the project and our software development approach. It was inspired by the OpenMRS Developers Guide as well as conventions and best practices used in the software industry. Who Should Read This Guide? The target audience for this document is anyone who wants to build, contribute or learn more about BioDynaMo. Everyone has a different background, you might be new to C++ programming, simulation software or software development in general. This doesn't mean you cannot be a valuable contributor! This guide will help you fill in the blanks. Info If you are a user who wants to build simulations, please head over to our user guide Feedback This guide is an evolving resource. If you have difficulties in some steps and feel that parts could be described better or any other kind of comment please reach out to lukas . johannes . breitwieser _at_ cern . ch . Thank you for your feedback!","title":"Welcome"},{"location":"#welcome-to-biodynamo","text":"A very warm welcome to BioDynaMo and thank you for your interest! This guide will help you get started. It introduces you to the project and our software development approach. It was inspired by the OpenMRS Developers Guide as well as conventions and best practices used in the software industry.","title":"Welcome to BioDynaMo!"},{"location":"#who-should-read-this-guide","text":"The target audience for this document is anyone who wants to build, contribute or learn more about BioDynaMo. Everyone has a different background, you might be new to C++ programming, simulation software or software development in general. This doesn't mean you cannot be a valuable contributor! This guide will help you fill in the blanks. Info If you are a user who wants to build simulations, please head over to our user guide","title":"Who Should Read This Guide?"},{"location":"#feedback","text":"This guide is an evolving resource. If you have difficulties in some steps and feel that parts could be described better or any other kind of comment please reach out to lukas . johannes . breitwieser _at_ cern . ch . Thank you for your feedback!","title":"Feedback"},{"location":"build/","text":"Building BioDynaMo To build BioDynaMo from source execute the following commands: Info If you are a user please follow the installation instructions in our user guide Ubuntu 16.04, 18.04 git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo # Install the prerequisites for the project ./prerequisites.sh all # Create the build directory mkdir build cd build # Build the project cmake ../ make # (Optional) Installs the library make install The script prerequisites . sh is used to install all the dependencies needed by BioDynaMo. You will need to run it before actually calling cmake and make . It will also choose the specific dependencies given the operating systems. Run . / prerequisites . sh --help to see how to use it. Attention When trying to install the prerequisites on MacOS the script will user brew as a default install method. If you do not have brew on your system, or you are using a different package manager, you will need to manually install all the required packages. Please have a look to the Prerequisites page. CentOS 7.6.1810 In case of CentOS, you will need to run some additional commands before actually calling cmake and make . This is because CentOS do not provide by default the correct C++ compilers and the correct python interpreter. Moerover, we will need to load the OpenMPI module. You will need to run these instructions only before building BioDynaMo. You will not need them in order to run the library. git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo ./prerequisites.sh all centos-7.6.1810 export MESA_GL_VERSION_OVERRIDE = 3 .3 . scl_source enable rh-python36 . scl_source enable devtoolset-7 . /etc/profile.d/modules.sh module load mpi mkdir build && cd build && cmake ../ && make make install MacOS Before building BioDynaMo on MacOS you will need to provide to cmake a C++14 and OpenMP compatible compiler. This can be done by setting the environmental variables CXX and C for the C++ and C compilers. Here as example we show the procedure using clang compiler installed using brew . git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo ./prerequisites.sh all osx export LLVMDIR = \"/usr/local/opt/llvm\" export CC = $LLVMDIR /bin/clang export CXX = $LLVMDIR /bin/clang++ export CXXFLAGS = -I $LLVMDIR /include export LDFLAGS = -L $LLVMDIR /lib export PATH = $LLVMDIR /bin: $PATH mkdir build && cd build && cmake ../ && make make install CMake Build Options Our CMake build script uses a few options to influence the build process. They can be set as follows: cmake -Doption = value .. The value for binary options is on or off . If you change the value of these switches, you might have to delete CMakeCache . txt beforehand. Option Default Value Description test on build the test executables; precondition for e.g. valgrind and coverage dict on build ROOT dictionaries. These are compulsory to use backups. Turning them off reduces compilation time. paraview on Enable visualization using ParaView. Visualization cannot be used if this switch is turned off. cuda off enable CUDA code generation for GPU acceleration opencl off enable OpenCL code generation for GPU acceleration valgrind on enable memory leak checks coverage off creates a make target to generate a html report indicating which parts of the code are tested by automatic tests Further CMake command line parameters Option Description CMAKE_CXX_FLAGS specify additional compiler flags - e.g. \"-mavx\" CMAKE_BUILD_TYPE specify the build type. Possible values are Debug , Release , RelWithDebInfo , MinSizeRel Build Targets Target Description test executes all tests check executes all tests and shows test output on failure clean will clean all targets, also the external projects bdmclean will only clean the biodynamo and runBiodynamoTests * targets testbdmclean will only clean the runBiodynamoTests * target doc will generate the API, user and developer documentation in directory build / doc . coverage will execute the test target and generate a coverage report in build / coverage . Make sure that gcov and lcov are installed and configure cmake with cmake - Dcoverage = on .. coverage - build same as make coverage , but builds it in a separate directory ( build / coverage ). Since building the coverage report requires different compiler flags, building it in a separate directory keeps the current build directory in good order. C++ Code Style Related Build Targets The following targets are only available if clang - format , clang - tidy and git are installed. Build targets indicated with * always come in three different flavors. no - suffix : executes the target on source files that changed compared to origin/master -- e.g. make check - format - staged : executes the target on source files that have been staged -- e.g. make check - format - staged - all : executes the target on all source files in the project -- e.g. make check - format - all Target Description check - format * run clang-format on selected files. Fails if any file needs to be reformatted show - format * run clang-format on selected files and display differences format * run clang-format on selected files and update them in-place check - tidy * run clang-tidy on selected files. Fails if errors are found show - tidy * run clang-tidy on selected files and display errors. tidy * run clang-tidy on selected files and attempt to fix any warning automatically check - cpplint * run cpplint on selected files. Fails if errors are found and displays them. check - submission will build, run all tests, check formatting, code style, and generate documentation and coverage report fix - submission will attempt to fix the reported issues using clang - format and clang - tidy . Failing build, tests, compiler warnings, issues from cpplint and warnings from doxygen must be fixed manually. Also some clang - tidy issues cannot be resolved automatically Documentation Related Build Targets Target Description doc will generate the API, user and developer documentation in directory build / doc live - dev - guide and live - user - guide starts a local web server so you can immediately view the documentation in the browser. The website is automatically reloaded if you change a source file. Advanced Build Options Use a Custom Compiler If you need to user a custom compilers (instead of the one automatically detected by BioDynaMo) you will need to set the variables: CXX for the C++ compiler and CC for the C compiler. Please not that your custom compiler must support the C++14 standard and must be compatible with OpenMP. The complete procedure will become: git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo # Let's say I want to use a custom version of clang export CXX = /opt/local/bin/clang++-mp-8.0 export C = /opt/local/bin/clang++-mp-8.0 ./install.sh Use a Specific ROOT / ParaView Installation When you want to inform BioDynaMo of a specific installation of ROOT and /or ParaView on your system, you will need to perform the following instructions prior to installation. git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo # For ROOT source <root_installation_dir>/bin/thisroot.sh # For ParaView export ParaView_DIR = <paraview_installation_dir>/lib/cmake/paraview-5.6 export Qt5_DIR = <qt5_installation_dir>/lib/cmake/Qt5 ./install.sh Attention If you specify ParaView_DIR, then you will need to provide also the Qt5_DIR variable. This is because ParaView implicitly relies on the Qt5 installation. Speed Up Installation Tests with a Local BioDynaMo-LFS Copy The installation scripts fetch large precompiled dependencies like paraview or root from biodynamo's large file storage (LFS). To enable faster builds you can download the whole LFS and tell BioDynaMo to access the local version instead. This is done with the environmental flag BDM_LOCAL_LFS . Use an absolute path to the directory that contains the local copy. export BDM_LOCAL_LFS = /path/to/local/lfs If you want to download the files from remote LFS again execute: unset BDM_LOCAL_LFS Warning At the moment there is no check if the local copy is in sync with remote. You have to ensure that yourself!","title":"Build BioDynaMo"},{"location":"build/#building-biodynamo","text":"To build BioDynaMo from source execute the following commands: Info If you are a user please follow the installation instructions in our user guide","title":"Building BioDynaMo"},{"location":"build/#ubuntu-1604-1804","text":"git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo # Install the prerequisites for the project ./prerequisites.sh all # Create the build directory mkdir build cd build # Build the project cmake ../ make # (Optional) Installs the library make install The script prerequisites . sh is used to install all the dependencies needed by BioDynaMo. You will need to run it before actually calling cmake and make . It will also choose the specific dependencies given the operating systems. Run . / prerequisites . sh --help to see how to use it. Attention When trying to install the prerequisites on MacOS the script will user brew as a default install method. If you do not have brew on your system, or you are using a different package manager, you will need to manually install all the required packages. Please have a look to the Prerequisites page.","title":"Ubuntu 16.04, 18.04"},{"location":"build/#centos-761810","text":"In case of CentOS, you will need to run some additional commands before actually calling cmake and make . This is because CentOS do not provide by default the correct C++ compilers and the correct python interpreter. Moerover, we will need to load the OpenMPI module. You will need to run these instructions only before building BioDynaMo. You will not need them in order to run the library. git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo ./prerequisites.sh all centos-7.6.1810 export MESA_GL_VERSION_OVERRIDE = 3 .3 . scl_source enable rh-python36 . scl_source enable devtoolset-7 . /etc/profile.d/modules.sh module load mpi mkdir build && cd build && cmake ../ && make make install","title":"CentOS 7.6.1810"},{"location":"build/#macos","text":"Before building BioDynaMo on MacOS you will need to provide to cmake a C++14 and OpenMP compatible compiler. This can be done by setting the environmental variables CXX and C for the C++ and C compilers. Here as example we show the procedure using clang compiler installed using brew . git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo ./prerequisites.sh all osx export LLVMDIR = \"/usr/local/opt/llvm\" export CC = $LLVMDIR /bin/clang export CXX = $LLVMDIR /bin/clang++ export CXXFLAGS = -I $LLVMDIR /include export LDFLAGS = -L $LLVMDIR /lib export PATH = $LLVMDIR /bin: $PATH mkdir build && cd build && cmake ../ && make make install","title":"MacOS"},{"location":"build/#cmake-build-options","text":"Our CMake build script uses a few options to influence the build process. They can be set as follows: cmake -Doption = value .. The value for binary options is on or off . If you change the value of these switches, you might have to delete CMakeCache . txt beforehand. Option Default Value Description test on build the test executables; precondition for e.g. valgrind and coverage dict on build ROOT dictionaries. These are compulsory to use backups. Turning them off reduces compilation time. paraview on Enable visualization using ParaView. Visualization cannot be used if this switch is turned off. cuda off enable CUDA code generation for GPU acceleration opencl off enable OpenCL code generation for GPU acceleration valgrind on enable memory leak checks coverage off creates a make target to generate a html report indicating which parts of the code are tested by automatic tests","title":"CMake Build Options"},{"location":"build/#further-cmake-command-line-parameters","text":"Option Description CMAKE_CXX_FLAGS specify additional compiler flags - e.g. \"-mavx\" CMAKE_BUILD_TYPE specify the build type. Possible values are Debug , Release , RelWithDebInfo , MinSizeRel","title":"Further CMake command line parameters"},{"location":"build/#build-targets","text":"Target Description test executes all tests check executes all tests and shows test output on failure clean will clean all targets, also the external projects bdmclean will only clean the biodynamo and runBiodynamoTests * targets testbdmclean will only clean the runBiodynamoTests * target doc will generate the API, user and developer documentation in directory build / doc . coverage will execute the test target and generate a coverage report in build / coverage . Make sure that gcov and lcov are installed and configure cmake with cmake - Dcoverage = on .. coverage - build same as make coverage , but builds it in a separate directory ( build / coverage ). Since building the coverage report requires different compiler flags, building it in a separate directory keeps the current build directory in good order.","title":"Build Targets"},{"location":"build/#c-code-style-related-build-targets","text":"The following targets are only available if clang - format , clang - tidy and git are installed. Build targets indicated with * always come in three different flavors. no - suffix : executes the target on source files that changed compared to origin/master -- e.g. make check - format - staged : executes the target on source files that have been staged -- e.g. make check - format - staged - all : executes the target on all source files in the project -- e.g. make check - format - all Target Description check - format * run clang-format on selected files. Fails if any file needs to be reformatted show - format * run clang-format on selected files and display differences format * run clang-format on selected files and update them in-place check - tidy * run clang-tidy on selected files. Fails if errors are found show - tidy * run clang-tidy on selected files and display errors. tidy * run clang-tidy on selected files and attempt to fix any warning automatically check - cpplint * run cpplint on selected files. Fails if errors are found and displays them. check - submission will build, run all tests, check formatting, code style, and generate documentation and coverage report fix - submission will attempt to fix the reported issues using clang - format and clang - tidy . Failing build, tests, compiler warnings, issues from cpplint and warnings from doxygen must be fixed manually. Also some clang - tidy issues cannot be resolved automatically","title":"C++ Code Style Related Build Targets"},{"location":"build/#documentation-related-build-targets","text":"Target Description doc will generate the API, user and developer documentation in directory build / doc live - dev - guide and live - user - guide starts a local web server so you can immediately view the documentation in the browser. The website is automatically reloaded if you change a source file.","title":"Documentation Related Build Targets"},{"location":"build/#advanced-build-options","text":"","title":"Advanced Build Options"},{"location":"build/#use-a-custom-compiler","text":"If you need to user a custom compilers (instead of the one automatically detected by BioDynaMo) you will need to set the variables: CXX for the C++ compiler and CC for the C compiler. Please not that your custom compiler must support the C++14 standard and must be compatible with OpenMP. The complete procedure will become: git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo # Let's say I want to use a custom version of clang export CXX = /opt/local/bin/clang++-mp-8.0 export C = /opt/local/bin/clang++-mp-8.0 ./install.sh","title":"Use a Custom Compiler"},{"location":"build/#use-a-specific-root-paraview-installation","text":"When you want to inform BioDynaMo of a specific installation of ROOT and /or ParaView on your system, you will need to perform the following instructions prior to installation. git clone https://github.com/BioDynaMo/biodynamo.git cd biodynamo # For ROOT source <root_installation_dir>/bin/thisroot.sh # For ParaView export ParaView_DIR = <paraview_installation_dir>/lib/cmake/paraview-5.6 export Qt5_DIR = <qt5_installation_dir>/lib/cmake/Qt5 ./install.sh Attention If you specify ParaView_DIR, then you will need to provide also the Qt5_DIR variable. This is because ParaView implicitly relies on the Qt5 installation.","title":"Use a Specific ROOT / ParaView Installation"},{"location":"build/#speed-up-installation-tests-with-a-local-biodynamo-lfs-copy","text":"The installation scripts fetch large precompiled dependencies like paraview or root from biodynamo's large file storage (LFS). To enable faster builds you can download the whole LFS and tell BioDynaMo to access the local version instead. This is done with the environmental flag BDM_LOCAL_LFS . Use an absolute path to the directory that contains the local copy. export BDM_LOCAL_LFS = /path/to/local/lfs If you want to download the files from remote LFS again execute: unset BDM_LOCAL_LFS Warning At the moment there is no check if the local copy is in sync with remote. You have to ensure that yourself!","title":"Speed Up Installation Tests with a Local BioDynaMo-LFS Copy"},{"location":"code_quality/","text":"Code Quality At BioDynaMo we are aiming to develop a high quality software product. The following practices help us to achieve this goal: C++ Style Guide Documentation (User guide, Developer guide, API) Git Conventions Test driven development (TDD) Continues integration (CI) Code Styleguide A coding styleguide is a set of guidelines and best practices which improve readability and maintainability of a code base. Code is more often read than rewritten. Therefore it is important that a developer quickly understands a piece of code even if it was written by someone else. A coding standard helps to achieve that. We are using the Google C++ Style Guide Test Driven Development (TDD) and Continues Integration (CI) TDD and CI are two practices from agile development. Test Driven Development is a special way of using unit tests. A unit test is a piece of code that tests a certain functionality of our application. If we make some changes in the code and at the end all unit tests pass, we most likely did not break something. This increases confidence in the code and reduces the fear to \"touch\" others code. Continues Integration takes all this automated tests and executes them on every change to the code repository. We are using Travis-CI More information: Intro to TDD Beck, Kent. Extreme programming explained: embrace change. addison-wesley professional, 2000. Git Conventions Git Workflow We are following the Git workflow proposed by Vincent Driessen in his blog post: A successful Git branching model with the modification that his develop branch is our master branch. Git Commit Message Taken from a great blog post from Chris Beams Separate subject from body with a blank line Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Use the body to explain what and why vs. how Limit the subject line to 50 characters Wrap the body at 72 characters Summarize changes in around 50 characters or less More detailed explanatory text , if necessary . Wrap it to about 72 characters or so . In some contexts , the first line is treated as the subject of the commit and the rest of the text as the body . The blank line separating the summary from the body is critical ( unless you omit the body entirely ) ; various tools like `log`, `shortlog` and ` rebase ` can get confused if you run the two together . Explain the problem that this commit is solving . Focus on why you are making this change as opposed to how ( the code explains that ) . Are there side effects or other unintuitive consequenses of this change ? Here ' s the place to explain them. Further paragraphs come after blank lines . - Bullet points are okay , too - Typically a hyphen or asterisk is used for the bullet , preceded by a single space , with blank lines in between , but conventions vary here If you use an issue tracker , put references to them at the bottom , like this : Resolves : #123 See also : #456 , #789 Use git commit without the - m switch to write a commit body. Master Branch Each commit in the master branch should pass the CI build. Therefore all development should be carried out in a feature/hotfix branch. Once development has been finished and the build passes, it can be merged back into master .","title":"Code Quality"},{"location":"code_quality/#code-quality","text":"At BioDynaMo we are aiming to develop a high quality software product. The following practices help us to achieve this goal: C++ Style Guide Documentation (User guide, Developer guide, API) Git Conventions Test driven development (TDD) Continues integration (CI)","title":"Code Quality"},{"location":"code_quality/#code-styleguide","text":"A coding styleguide is a set of guidelines and best practices which improve readability and maintainability of a code base. Code is more often read than rewritten. Therefore it is important that a developer quickly understands a piece of code even if it was written by someone else. A coding standard helps to achieve that. We are using the Google C++ Style Guide","title":"Code Styleguide"},{"location":"code_quality/#test-driven-development-tdd-and-continues-integration-ci","text":"TDD and CI are two practices from agile development. Test Driven Development is a special way of using unit tests. A unit test is a piece of code that tests a certain functionality of our application. If we make some changes in the code and at the end all unit tests pass, we most likely did not break something. This increases confidence in the code and reduces the fear to \"touch\" others code. Continues Integration takes all this automated tests and executes them on every change to the code repository. We are using Travis-CI More information: Intro to TDD Beck, Kent. Extreme programming explained: embrace change. addison-wesley professional, 2000.","title":"Test Driven Development (TDD) and Continues Integration (CI)"},{"location":"code_quality/#git-conventions","text":"","title":"Git Conventions"},{"location":"code_quality/#git-workflow","text":"We are following the Git workflow proposed by Vincent Driessen in his blog post: A successful Git branching model with the modification that his develop branch is our master branch.","title":"Git Workflow"},{"location":"code_quality/#git-commit-message","text":"Taken from a great blog post from Chris Beams Separate subject from body with a blank line Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Use the body to explain what and why vs. how Limit the subject line to 50 characters Wrap the body at 72 characters Summarize changes in around 50 characters or less More detailed explanatory text , if necessary . Wrap it to about 72 characters or so . In some contexts , the first line is treated as the subject of the commit and the rest of the text as the body . The blank line separating the summary from the body is critical ( unless you omit the body entirely ) ; various tools like `log`, `shortlog` and ` rebase ` can get confused if you run the two together . Explain the problem that this commit is solving . Focus on why you are making this change as opposed to how ( the code explains that ) . Are there side effects or other unintuitive consequenses of this change ? Here ' s the place to explain them. Further paragraphs come after blank lines . - Bullet points are okay , too - Typically a hyphen or asterisk is used for the bullet , preceded by a single space , with blank lines in between , but conventions vary here If you use an issue tracker , put references to them at the bottom , like this : Resolves : #123 See also : #456 , #789 Use git commit without the - m switch to write a commit body.","title":"Git Commit Message"},{"location":"code_quality/#master-branch","text":"Each commit in the master branch should pass the CI build. Therefore all development should be carried out in a feature/hotfix branch. Once development has been finished and the build passes, it can be merged back into master .","title":"Master Branch"},{"location":"contribute/","text":"Contributing Code From Cloning BioDynaMo to Your First Contribution The following process describes steps to contribute code changes to the master branch. It follows best practices from industry to ensure a maintainable, high quality code base. The shown commands assume that biodynamo / build is the current directory. If you follow these steps it will make life of the code reviewer a lot easier! Consequently, it will ensure that your code is accepted sooner :) 1. Get familiar with our coding convention Carefully read the C++ style guide and our page about Code Quality 2. Clone the repository git clone https://github.com/BioDynaMo/biodynamo.git 3. Checkout the master branch git checkout master 4. Get latest version of master git pull origin master 5. Create the feature branch git checkout -b my-feature-branch 6. Make your changes and write tests You can make intermediate commits without performing all subsequent steps. However, for your final submission these steps are essential. Also for intermediate commit messages: have a look at how to write good commit messages ! 7. Compile and run tests make && make check Please make sure that there are no compiler warnings 8. Code coverage Check if code is sufficiently covered by tests. make coverage-build # open it in browser - e.g. chromium-browser coverage/coverage/index.html 9. Performance Check if code changes affected performance 10. Documentation Write documentation and check result in browser make doc chromium-browser doc/html/index.html Check if API documentation has been generated correctly it is consistent with code (copy-paste errors) it sufficiently describes the functionality Please pay attention to warnings from doxygen generation. Here an example of an inconsistent documentation: # make doc ouput : ... kd_tree_node . h : 132 : warning : argument 'axis' of command @param is not found in the argument list of bdm : : spatial_organization : : KdTreeNode < T >:: GetSAHSplitPoint () kd_tree_node . h : 132 : warning : argument 'num' of command @param is not found in the argument list of bdm : : spatial_organization : : KdTreeNode < T >:: GetSAHSplitPoint () The corresponding code snippet shows a mismatch between code and documentation which needs to be fixed. /// Gets point , which we use for surface area heuristics /// @ param axis - on what axis are we separating : x = 0 , y = 1 , z = 2 /// @ param num - what parttion are we on ( 1 ;N) /// @ return sah rating Point GetSAHSplitPoint () ; 11. Perform final checks on your machine make check-submission This command will execute all tests, check code formatting, styleguide rules, build the documentation and coverage report ( more info ). False positives from clang - tidy can be silenced by adding // NOLINT at the end of the line. Disabling clang - format for a certain part can be done by encapsulating it with the following comments: // clang - format off code here is not changed by clang - format // clang - format on If there are no false positives and you are fine with the changes suggested by clang - format and clang - tidy run: make fix - submission . However, failing build, tests, compiler warnings, issues from cpplint and warnings from doxygen must be fixed manually. Also some clang - tidy issues cannot be resolved automatically. After running make fix - submission please execute make check - submission to see if all issues have been resolved. Please verify that: code compiles without warnings all tests pass all valgrind tests pass code complies with our coding styleguide -- no errors from clang - format , clang - tidy or cpplint documentation is in good order -- see point 10 code is sufficiently covered by test cases performance did not degrade due to the code changes 12. Commit Once make check - submission does not report any issues, the final commit can be done. Have a look at how to write good commit messages ! git add -i git commit 13. Create pull request Please create a pull request 14. Verify if Travis-CI builds are OK Open the Travis-CI build for Linux and OSX and go through the checklist from point 11 for each of them. Unlike compilation and test suite execution, problems caused by formatting, code style and documentation will not fail the build. However, they need to be fixed! 15. If everything is OK contact one of the code reviewers on Slack 16. Discuss suggested changes with the code reviewer If code changes are necessary, go back to step 6 17. Congratulations, your code has been merged into the master branch Many thanks for your contribution, rigor and patience! 98% Finished Projects In the open source world sometimes it happens that people work on a feature for weeks or month and leave after it has been finished for 98%. Although this 2% don't look like a big issue, usually that means that all your work doesn't make it into the production code. Normally, other developers are busy and don't have the time to dive into your work and find the pieces that are missing or not working yet. This situation would be a waste of your precious time. We bet that it is way more satisfying if your contribution makes it into production and will be used by scientists around the world. For a contribution to be considered 100% complete, it must (be) * comply to our coding guidelines, * unit tested, * well documented * include a demo / screencast in certain cases. Therefore, we want to encourage you to reserve enough time in the end where you don't code. We do our best to support you! make check - submission explained The command make check - submission is our central automatic tool to validate if code changes are ready to be merged into master. It performs a series of checks and reports errors or warnings. Therefore, it makes the code review process easier. Since developers can execute it on their local machine, the feedback loop is much tighter, resulting in a faster submission process. Although, many issues are caught, it has its limitations. Thus, it cannot fully replace manual code reviews. Since it possibly outputs a lot of information, this page explains how to interpret the results. Here an example how the output should look like if all checks are OK Successful build without compiler warnings All tests pass clang - format does not report issues clang - tidy does not report issues cpplint does not report issues doxygen does not report issues Here an example of a passing build , but with issues in many categories -- these issues must be fixed as well: Compiler warning clang - format reports issues Since there were issues, they are displayed clang - tidy reports issues Since there were issues, they are displayed cpplint reports issues doxygen reports issues","title":"Contribute"},{"location":"contribute/#contributing-code","text":"","title":"Contributing Code"},{"location":"contribute/#from-cloning-biodynamo-to-your-first-contribution","text":"The following process describes steps to contribute code changes to the master branch. It follows best practices from industry to ensure a maintainable, high quality code base. The shown commands assume that biodynamo / build is the current directory. If you follow these steps it will make life of the code reviewer a lot easier! Consequently, it will ensure that your code is accepted sooner :)","title":"From Cloning BioDynaMo to Your First Contribution"},{"location":"contribute/#1-get-familiar-with-our-coding-convention","text":"Carefully read the C++ style guide and our page about Code Quality","title":"1. Get familiar with our coding convention"},{"location":"contribute/#2-clone-the-repository","text":"git clone https://github.com/BioDynaMo/biodynamo.git","title":"2. Clone the repository"},{"location":"contribute/#3-checkout-the-master-branch","text":"git checkout master","title":"3. Checkout the master branch"},{"location":"contribute/#4-get-latest-version-of-master","text":"git pull origin master","title":"4. Get latest version of master"},{"location":"contribute/#5-create-the-feature-branch","text":"git checkout -b my-feature-branch","title":"5. Create the feature branch"},{"location":"contribute/#6-make-your-changes-and-write-tests","text":"You can make intermediate commits without performing all subsequent steps. However, for your final submission these steps are essential. Also for intermediate commit messages: have a look at how to write good commit messages !","title":"6. Make your changes and write tests"},{"location":"contribute/#7-compile-and-run-tests","text":"make && make check Please make sure that there are no compiler warnings","title":"7. Compile and run tests"},{"location":"contribute/#8-code-coverage","text":"Check if code is sufficiently covered by tests. make coverage-build # open it in browser - e.g. chromium-browser coverage/coverage/index.html","title":"8. Code coverage"},{"location":"contribute/#9-performance","text":"Check if code changes affected performance","title":"9. Performance"},{"location":"contribute/#10-documentation","text":"Write documentation and check result in browser make doc chromium-browser doc/html/index.html Check if API documentation has been generated correctly it is consistent with code (copy-paste errors) it sufficiently describes the functionality Please pay attention to warnings from doxygen generation. Here an example of an inconsistent documentation: # make doc ouput : ... kd_tree_node . h : 132 : warning : argument 'axis' of command @param is not found in the argument list of bdm : : spatial_organization : : KdTreeNode < T >:: GetSAHSplitPoint () kd_tree_node . h : 132 : warning : argument 'num' of command @param is not found in the argument list of bdm : : spatial_organization : : KdTreeNode < T >:: GetSAHSplitPoint () The corresponding code snippet shows a mismatch between code and documentation which needs to be fixed. /// Gets point , which we use for surface area heuristics /// @ param axis - on what axis are we separating : x = 0 , y = 1 , z = 2 /// @ param num - what parttion are we on ( 1 ;N) /// @ return sah rating Point GetSAHSplitPoint () ;","title":"10. Documentation"},{"location":"contribute/#11-perform-final-checks-on-your-machine","text":"make check-submission This command will execute all tests, check code formatting, styleguide rules, build the documentation and coverage report ( more info ). False positives from clang - tidy can be silenced by adding // NOLINT at the end of the line. Disabling clang - format for a certain part can be done by encapsulating it with the following comments: // clang - format off code here is not changed by clang - format // clang - format on If there are no false positives and you are fine with the changes suggested by clang - format and clang - tidy run: make fix - submission . However, failing build, tests, compiler warnings, issues from cpplint and warnings from doxygen must be fixed manually. Also some clang - tidy issues cannot be resolved automatically. After running make fix - submission please execute make check - submission to see if all issues have been resolved. Please verify that: code compiles without warnings all tests pass all valgrind tests pass code complies with our coding styleguide -- no errors from clang - format , clang - tidy or cpplint documentation is in good order -- see point 10 code is sufficiently covered by test cases performance did not degrade due to the code changes","title":"11. Perform final checks on your machine"},{"location":"contribute/#12-commit","text":"Once make check - submission does not report any issues, the final commit can be done. Have a look at how to write good commit messages ! git add -i git commit","title":"12. Commit"},{"location":"contribute/#13-create-pull-request","text":"Please create a pull request","title":"13. Create pull request"},{"location":"contribute/#14-verify-if-travis-ci-builds-are-ok","text":"Open the Travis-CI build for Linux and OSX and go through the checklist from point 11 for each of them. Unlike compilation and test suite execution, problems caused by formatting, code style and documentation will not fail the build. However, they need to be fixed!","title":"14. Verify if Travis-CI builds are OK"},{"location":"contribute/#15-if-everything-is-ok-contact-one-of-the-code-reviewers-on-slack","text":"","title":"15. If everything is OK contact one of the code reviewers on Slack"},{"location":"contribute/#16-discuss-suggested-changes-with-the-code-reviewer","text":"If code changes are necessary, go back to step 6","title":"16. Discuss suggested changes with the code reviewer"},{"location":"contribute/#17-congratulations-your-code-has-been-merged-into-the-master-branch","text":"Many thanks for your contribution, rigor and patience!","title":"17. Congratulations, your code has been merged into the master branch"},{"location":"contribute/#98-finished-projects","text":"In the open source world sometimes it happens that people work on a feature for weeks or month and leave after it has been finished for 98%. Although this 2% don't look like a big issue, usually that means that all your work doesn't make it into the production code. Normally, other developers are busy and don't have the time to dive into your work and find the pieces that are missing or not working yet. This situation would be a waste of your precious time. We bet that it is way more satisfying if your contribution makes it into production and will be used by scientists around the world. For a contribution to be considered 100% complete, it must (be) * comply to our coding guidelines, * unit tested, * well documented * include a demo / screencast in certain cases. Therefore, we want to encourage you to reserve enough time in the end where you don't code. We do our best to support you!","title":"98% Finished Projects"},{"location":"contribute/#make-check-submission-explained","text":"The command make check - submission is our central automatic tool to validate if code changes are ready to be merged into master. It performs a series of checks and reports errors or warnings. Therefore, it makes the code review process easier. Since developers can execute it on their local machine, the feedback loop is much tighter, resulting in a faster submission process. Although, many issues are caught, it has its limitations. Thus, it cannot fully replace manual code reviews. Since it possibly outputs a lot of information, this page explains how to interpret the results. Here an example how the output should look like if all checks are OK Successful build without compiler warnings All tests pass clang - format does not report issues clang - tidy does not report issues cpplint does not report issues doxygen does not report issues Here an example of a passing build , but with issues in many categories -- these issues must be fixed as well: Compiler warning clang - format reports issues Since there were issues, they are displayed clang - tidy reports issues Since there were issues, they are displayed cpplint reports issues doxygen reports issues","title":"make check-submission explained"},{"location":"new_os/","text":"Add support for a new Operating System In order to add BioDynaMo's support for a new operating systems, please follow the steps presented below: Add a new directory called < your - os - name >-< version > inside util / installation . Generally, < your - os - name > must be all lowercase and must match the result of the command lsb_release - is . Moreover, also < version > must match the result of the command lsb_release - sr ; Create a file called prerequisites . sh and place it inside util / installation /< your - os - name >-< version > . This file will install all the prerequisites needed by the new OS. The script must take only one argument which specifies which prerequisites will be installed (all of them or just the optional ones). Please have a look to the already existing prerequisites . sh for more information; Add a Dockerfile which will be used to instantiate a container with your operating system for testing purposes. The Dockerfile needs also to be placed inside util / installation /< your - os - name >-< version > . Add to .travis.yml two new tests for the newly added operating system. More specifically, you will need to add these two lines: - os : linux before_install : - test -n $CC && unset CC - test -n $CXX && unset CXX env : SCRIPT=\"util/travis-ci/installation-test.sh <your-os-name>-<version>\" - os : linux compiler : gcc dist : trusty sudo : required group : edge env : SCRIPT=\"util/run-inside-docker.sh <your-os-name>-<version> util/travis-ci/default-build.sh\"","title":"Add a new OS"},{"location":"new_os/#add-support-for-a-new-operating-system","text":"In order to add BioDynaMo's support for a new operating systems, please follow the steps presented below: Add a new directory called < your - os - name >-< version > inside util / installation . Generally, < your - os - name > must be all lowercase and must match the result of the command lsb_release - is . Moreover, also < version > must match the result of the command lsb_release - sr ; Create a file called prerequisites . sh and place it inside util / installation /< your - os - name >-< version > . This file will install all the prerequisites needed by the new OS. The script must take only one argument which specifies which prerequisites will be installed (all of them or just the optional ones). Please have a look to the already existing prerequisites . sh for more information; Add a Dockerfile which will be used to instantiate a container with your operating system for testing purposes. The Dockerfile needs also to be placed inside util / installation /< your - os - name >-< version > . Add to .travis.yml two new tests for the newly added operating system. More specifically, you will need to add these two lines: - os : linux before_install : - test -n $CC && unset CC - test -n $CXX && unset CXX env : SCRIPT=\"util/travis-ci/installation-test.sh <your-os-name>-<version>\" - os : linux compiler : gcc dist : trusty sudo : required group : edge env : SCRIPT=\"util/run-inside-docker.sh <your-os-name>-<version> util/travis-ci/default-build.sh\"","title":"Add support for a new Operating System"}]}
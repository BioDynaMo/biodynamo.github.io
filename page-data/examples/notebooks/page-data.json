{
    "componentChunkName": "component---src-pages-examples-notebooks-js",
    "path": "/examples/notebooks/",
    "result": {"data":{"site":{"siteMetadata":{"siteUrl":"http://local:8000","title":"BioDynaMo Website","description":"Everything you need to know about agent-based simulations."}},"allJupyterNotebook":{"nodes":[{"fileRelativePath":"biodynamo/notebooks/ST01-model-initializer.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"d08f4bda","source":["# Create agents in 3D space\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we want to demonstrate different functions to initialize agents in space."]},{"cell_type":"markdown","id":"afc9e8fc","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"5df86ed1","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"markdown","id":"290f8c07","source":["We use `SphericalAgent`s with $diameter = 10$ for all consecutive examples."]},{"cell_type":"code","id":"5fcbd149","source":["auto create_agent = [](const Real3& position) {\n","  auto* agent = new SphericalAgent(position);\n","  agent->SetDiameter(10);\n","  return agent;\n","};"]},{"cell_type":"markdown","id":"3c4a8bec","source":["We define the number of agents that should be created for functions that require this parameter."]},{"cell_type":"code","id":"013e187f","source":["uint64_t num_agents = 300;"]},{"cell_type":"markdown","id":"c1253a31","source":["We define two helper functions that reset the simulation to the empty state and one to visualize the result."]},{"cell_type":"code","id":"cdd9589c","source":["void Clear() {\n","  simulation.GetResourceManager()->ClearAgents();\n","}"]},{"cell_type":"code","id":"48fb01d3","source":["void Vis() {\n","  simulation.GetScheduler()->FinalizeInitialization();\n","  VisualizeInNotebook();\n","}"]},{"cell_type":"markdown","id":"0f2c9fa2","source":["### Create agents randomly inside a 3D cube \n","Cube: $x_{min} = y_{min} = z_{min} = -200$ and $x_{max} = y_{max} = z_{max} = 200$<br>\n","By default a uniform random number distribution is used."]},{"cell_type":"code","id":"4602b092","source":["Clear();\n","ModelInitializer::CreateAgentsRandom(-200, 200, num_agents, create_agent);\n","Vis();"]},{"cell_type":"markdown","id":"5b0ff08f","source":["<div style=\"page-break-after: always;\"></div>"]},{"cell_type":"markdown","id":"be46b17d","source":["### Create agents randomly inside a 3D cube using a gaussian distribution\n","Cube: $x_{min} = y_{min} = z_{min} = -200$ and $x_{max} = y_{max} = z_{max} = 200$<br>\n","Gaussian: $\\mu = 0$, $\\sigma = 20$<br>\n","Note the extra parameter $rng$ passed to `CreateAgentsRandom`"]},{"cell_type":"code","id":"b47d15fe","source":["Clear();\n","auto rng = simulation.GetRandom()->GetGausRng(0, 20);\n","ModelInitializer::CreateAgentsRandom(-200, 200, num_agents, create_agent, &rng);\n","Vis();"]},{"cell_type":"markdown","id":"bffeec23","source":["### Create agents randomly inside a 3D cube using an exponential distribution\n","Cube: $x_{min} = y_{min} = z_{min} = -200$ and $x_{max} = y_{max} = z_{max} = 200$<br>\n","Exponential: $\\tau = 100$<br>\n","Note the extra parameter $rng$ passed to `CreateAgentsRandom`"]},{"cell_type":"code","id":"3b00519a","source":["Clear();\n","auto rng = simulation.GetRandom()->GetExpRng(100);\n","ModelInitializer::CreateAgentsRandom(-200, 200, num_agents, create_agent, &rng);\n","Vis();"]},{"cell_type":"markdown","id":"da3fcfc5","source":["### Create agents randomly inside a 3D cube using a 3D gaussian distribution\n","Cube: $x_{min} = y_{min} = z_{min} = -200$ and $x_{max} = y_{max} = z_{max} = 200$<br>\n","3D gaussian: $\\mu_x = \\mu_y = \\mu_z = 0$, $\\sigma_x = 100$, $\\sigma_y = 50$, $\\sigma_z = 20$<br>\n","The gaussian distribution we used earlier in this tutorial used the same parameters $\\mu$ and $\\sigma$ for all three dimensions. In this example we want to use different values for $\\sigma$ in each dimension. Therefore we have to use a 3D gaussian.\n","Since BioDynaMo does not have a predefined 3D gaussian, we have to define the function ourselves."]},{"cell_type":"code","id":"67e5df83","source":["Clear();\n","auto gaus3d = [](const real_t* x, const real_t* params) {\n","    auto mx = params[0];\n","    auto my = params[2];\n","    auto mz = params[4];\n","    auto sx = params[1];\n","    auto sy = params[3];\n","    auto sz = params[5];\n","    auto ret = (1.0/(sx * sy * sz *std::pow(2.0*Math::kPi, 3.0/2.0))) * \n","        std::exp(-std::pow(x[0] - mx, 2.0)/std::pow(sx, 2.0) - \n","                  std::pow(x[1] - my, 2.0)/std::pow(sy, 2.0) - \n","                  std::pow(x[2] - mz, 2.0)/std::pow(sz, 2.0));\n","    return ret;\n","};\n","auto* random = simulation.GetRandom();\n","auto rng = random->GetUserDefinedDistRng3D(gaus3d, {0, 100, 0, 50, 0, 20}, \n","                                           -200, 200, -200, 200, -200, 200);\n","ModelInitializer::CreateAgentsRandom(-200, 200, num_agents, create_agent, &rng);\n","Vis();"]},{"cell_type":"markdown","id":"2bfcf14b","source":["### Create agents randomly on a sphere\n","Center of the sphere ${0, 0, 0}$<br>\n","Radius: 100"]},{"cell_type":"code","id":"8ef1a886","source":["Clear();\n","ModelInitializer::CreateAgentsOnSphereRndm({0, 0, 0}, 100, num_agents, \n","                                           create_agent);\n","Vis();"]},{"cell_type":"markdown","id":"4498618b","source":["### Create 3D grid of agents\n","Number of agents per dimension: 10<br>\n","Space between agents: 20<br>\n","With this parameters `Grid3D` will create 1000 agents."]},{"cell_type":"code","id":"f3d6c1a0","source":["Clear();\n","uint64_t agents_per_dim = 10;\n","real_t space_between_agents = 20;\n","ModelInitializer::Grid3D(10, 20, create_agent);\n","Vis();"]},{"cell_type":"markdown","id":"55175666","source":["### Create agents on a surface\n","\n","We create agents between $x_{min} = y_{min} = -100$ and $x_{max} = y_{max} = 100$ with spacing of 10 between agents.\n","The $z$-coordinate is defined by the function $f(x, y) = 10 * sin(x/20) + 10 * sin(y/20)$<br>"]},{"cell_type":"code","id":"956872a1","source":["Clear();\n","auto f = [](const real_t* x, const real_t* params) {\n","    return 10 * std::sin(x[0] / 20.) + 10 * std::sin(x[1] / 20.0);\n","};\n","ModelInitializer::CreateAgentsOnSurface(f, {}, -100, 100, 10, -100, 100, 10, \n","                                        create_agent);\n","Vis();"]},{"cell_type":"markdown","id":"343cbc87","source":["### Create agents on a surface randomly\n","\n","We use the same parameters as in the example before, but this time we want to place agents randomly on this surface.\n","Therefore, $x$, and $y$ coordinate are sampled from a uniform distribution between $x_{min} = y_{min} = -100$ and $x_{max} = y_{max} = 100$."]},{"cell_type":"code","id":"97d760cf","source":["Clear();\n","ModelInitializer::CreateAgentsOnSurfaceRndm(f, {}, -100, 100, -100, 100, num_agents, \n","                                            create_agent);\n","Vis();"]}],"nbformat":4},"metadata":{"ipub":{"titlepage":{"author":"Lukas Breitwieser","email":"lukas.breitwieser@cern.ch","tagline":"A tagline for the report.","subtitle":"Sub-Title","title":"Main-Title"}},"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST02-user-defined-random-number-distribution.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"261afc2b","source":["# Generate random samples from a user-defined distribution\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we demonstrate how to create a random number generator that draws samples from a user-defined distribution."]},{"cell_type":"markdown","id":"16390b36","source":["Let's start by setting up BioDynaMo notebooks"]},{"cell_type":"code","id":"e115ba78","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"markdown","id":"78266042","source":["We have to create a `TCanvas` object to draw results in this notebook."]},{"cell_type":"code","id":"9789c3da","source":["TCanvas c(\"\", \"\", 400, 300);\n","c.SetGrid();"]},{"cell_type":"markdown","id":"e3e7f610","source":["Let's assume that we want to generate random numbers from a student-t distribution.<br>\n","Class [`Random`](https://biodynamo.org/api/classbdm_1_1Random.html) does not provide a direct function for that.<br>\n","Therefore, we use the user-defined distribution feature `Random::GetUserDefinedDistRng1D`.<br>\n","Fortunately, ROOT already provides a function called `tdistribution_pdf` that we can use.<br>\n","Have a look at the following two links for more math functions: [TMath](https://root.cern/doc/master/namespaceTMath.html) and [statistical functions](https://root.cern/doc/master/group__StatFunc.html)"]},{"cell_type":"code","id":"b17664b7","source":["auto* random = simulation.GetRandom();\n","auto distribution = [](const double* x, const double* param) { \n","    return ROOT::Math::tdistribution_pdf(*x, 1.0); \n","};\n","auto udd_rng = random->GetUserDefinedDistRng1D(distribution, {}, -5, 10);"]},{"cell_type":"markdown","id":"b0cbec82","source":["The returned random number generator has a function to draw the distribution."]},{"cell_type":"code","id":"1705dca2","source":["udd_rng.Draw();\n","c.Draw();"]},{"cell_type":"markdown","id":"e162d7fd","source":["In the next step we want to verify that the created random number generator follows the specified distribution.<br>\n","Therefore, we create a histogram with 100 bins in the range \\[-5, 10\\] and fill it with 10000 samples."]},{"cell_type":"code","id":"e81c5664","source":["TH1F h(\"\",\"\", 100, -5, 10);\n","for (int i = 0; i < 10000; ++i){\n","    auto rndm_sample = udd_rng.Sample();\n","    h.Fill(rndm_sample);\n","}"]},{"cell_type":"markdown","id":"bb0e6242","source":["Let's draw the result:"]},{"cell_type":"code","id":"e6b77f1f","source":["h.SetFillColor(kBlue-10);\n","h.Draw();\n","c.Draw();"]},{"cell_type":"markdown","id":"026336df","source":["As we can see from the last figure the samples from our random number generator fit our distribution."]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST03-agent-reproduction-mortality.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"71c33bc3","source":["# Agent reproduction and mortality\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we want to demonstrate how to add and remove agents from the simulation."]},{"cell_type":"markdown","id":"3a265f99","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"628dae37","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"code","id":"99248da3","source":["auto* ctxt = simulation.GetExecutionContext();\n","auto* scheduler = simulation.GetScheduler();\n","auto* rm = simulation.GetResourceManager();"]},{"cell_type":"markdown","id":"ad387f12","source":["Let's define our initial model: One cell at origin.<br>\n","We also create an agent pointer for our cell, because raw pointers might be invalidated after a call to `Scheduler::Simulate`"]},{"cell_type":"code","id":"71ea49a5","source":["auto* cell = new Cell();\n","ctxt->AddAgent(cell);\n","auto cell_aptr = cell->GetAgentPtr<Cell>();\n","scheduler->FinalizeInitialization();\n","VisualizeInNotebook();"]},{"cell_type":"markdown","id":"09d9c6a9","source":["Adding an agent to the simulation is as easy as constructing one and adding it to the execution context.<br>\n","Our default execution context will add the new agent to the simulation at the end of the iteration.<br>\n","Therefore, the visualization still shows only one agent."]},{"cell_type":"code","id":"06f1e6cf","source":["ctxt->AddAgent(new SphericalAgent({3, 0, 0}));\n","VisualizeInNotebook()"]},{"cell_type":"markdown","id":"fd025d7f","source":["Let's simulate one time step and see what happens."]},{"cell_type":"code","id":"e6839f0e","source":["scheduler->Simulate(1);\n","VisualizeInNotebook()"]},{"cell_type":"markdown","id":"3271ff63","source":["Our new agent has been added to the simulation.<br>\n","Usually, new agents will be created based on some process, e.g. cell division, neurite extension from soma, neurite branching, etc.\n","The following example shows cell division. We specify the division axis."]},{"cell_type":"code","id":"3131f214","source":["cell_aptr->Divide({1, 0, 0});\n","VisualizeInNotebook()"]},{"cell_type":"markdown","id":"4825d277","source":["Again, the new cell is not visible yet. We have to finish one iteration."]},{"cell_type":"code","id":"45f93c49","source":["scheduler->Simulate(1);\n","VisualizeInNotebook()"]},{"cell_type":"markdown","id":"3a6103ed","source":["Removing agents from the simulation works similarly.<br>\n","The default execution context will remove it at the end of the iteration."]},{"cell_type":"code","id":"77d63217","source":["cell_aptr->RemoveFromSimulation();\n","rm->GetNumAgents();\n","VisualizeInNotebook()"]},{"cell_type":"markdown","id":"23ea7e00","source":["We expect that after the `Simulate` call only 2 agents are shown in the visualization."]},{"cell_type":"code","id":"f585c671","source":["scheduler->Simulate(1);\n","VisualizeInNotebook()"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST04-agent-reproduction-with-behaviors.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"fe622041","source":["# Agent reproduction with behaviors\n","\n","**Author: Lukas Breitwieser**<br>\n","In tutorial `ST3-agent-reproduction-mortality` we have explored how to add and remove agents from the simulation.\n","In this tutorial we want to explore different behavior options to control if a new agent gets a behavior from the original agent, and if a behavior will be removed from the original one."]},{"cell_type":"markdown","id":"5f0b34a5","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"628dae37","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"markdown","id":"f1b6d8d3","source":["We define a simple behavior which prints `has print behavior`."]},{"cell_type":"code","id":"dd7a38db","source":["StatelessBehavior print_behavior([](Agent* agent) {\n","  std::cout << \"  has print behavior\" << std::endl;\n","});"]},{"cell_type":"markdown","id":"a54cef7c","source":["We define the following experiment which we will run with different options of the `print_behavior`.<br>\n","We create a cell, add a copy of the `print_behavior`, and run all behaviors. \n","We expect that the following output is created.\n","```\n","mother: \n","  has print behavior\n","```\n","Afterwards we print a separator `-------` to indicate cell division, divide the mother cell and run the behaviors of daughter 1 and daughter 2.\n","By definition the original mother cell turns into daughter 1 and the new agent becomes daughter 2."]},{"cell_type":"code","id":"71ea49a5","source":["void Experiment() {\n","    Simulation sim(\"my-simulation\");\n","    auto* mother = new Cell();\n","    mother->AddBehavior(print_behavior.NewCopy());\n","    std::cout << \"mother: \" << std::endl;\n","    mother->RunBehaviors();\n","    std::cout << \"---------------------\" << std::endl;\n","    auto* daughter2 = mother->Divide();\n","    std::cout << \"mother = daughter 1: \" << std::endl;\n","    mother->RunBehaviors(); // mother = daughter 1\n","    std::cout << \"daughter 2: \" << std::endl;\n","    daughter2->RunBehaviors();\n","}"]},{"cell_type":"markdown","id":"90413d31","source":["Let's run the experiment with default parameters and see what happens."]},{"cell_type":"code","id":"e6839f0e","source":["Experiment();"]},{"cell_type":"markdown","id":"05f00e5b","source":["The `print_behavior` was **not copied** to the daughter 2 cell and was **not removed** from the mother cell.\n","\n","---\n","\n","Let's try to copy the behavior from the mother cell to daughter 2."]},{"cell_type":"code","id":"09e6d449","source":["print_behavior.AlwaysCopyToNew();\n","Experiment();"]},{"cell_type":"markdown","id":"a429d714","source":["Now the `print_behavior` **was copied** to the daughter 2 cell and was **not removed** from the mother cell.\n","\n","---\n","\n","Let's try to remove the behavior from the mother cell."]},{"cell_type":"code","id":"3131f214","source":["print_behavior.AlwaysCopyToNew();\n","print_behavior.AlwaysRemoveFromExisting();\n","Experiment();"]},{"cell_type":"markdown","id":"49235127","source":["Now the `print_behavior` **was copied** to the daughter 2 cell and **was removed** from the mother cell.\n","\n","---\n","\n","Let's reset the values to the default."]},{"cell_type":"code","id":"45f93c49","source":["print_behavior.NeverCopyToNew();\n","print_behavior.NeverRemoveFromExisting();\n","Experiment();"]},{"cell_type":"markdown","id":"0de424e4","source":["Behaviors provide also more fine-grained distinction. Some agents support multiple [new agent events](https://biodynamo.org/docs/userguide/new_agent_event/): neurite branching, neurite bifurcation, side neurite extension, etc.\n","For each event we can specify if the behavior should be copied to the new, or removed from the existing agent."]},{"cell_type":"code","id":"77d63217","source":["print_behavior.CopyToNewIf({CellDivisionEvent::kUid});\n","print_behavior.RemoveFromExistingIf({CellDivisionEvent::kUid});\n","Experiment();"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST05-agent-reproduction-advanced.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"cfece0db","source":["# Agent reproduction advanced\n","\n","**Author: Lukas Breitwieser**<br>\n","In the tutorials so far we used `Cell::Divide` to create new agents.\n","In this demo we want to show how to define your own \"process\" that creates a new agent.\n","Furthermore, we will explain the purpose of the functions `Agent::Initialize` and `Agent::Update`.\n","\n","Assume that we want to create a new agent type `Human` which should be able to `GiveBirth`."]},{"cell_type":"markdown","id":"7050c0c6","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"6a3a1fa6","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"code","id":"27ce5b1f","source":["auto* ctxt = simulation.GetExecutionContext();\n","auto* scheduler = simulation.GetScheduler();"]},{"cell_type":"markdown","id":"c11074ec","source":["Let's start by creating the `ChildBirthEvent`.\n","In this example we do not need any attributes."]},{"cell_type":"code","id":"459c519c","source":["struct ChildBirthEvent : public NewAgentEvent {\n","  ChildBirthEvent() {}\n","  virtual ~ChildBirthEvent() {}\n","  NewAgentEventUid GetUid() const override { \n","      static NewAgentEventUid kUid = \n","          NewAgentEventUidGenerator::GetInstance()->GenerateUid();\n","      return kUid; \n","  }\n","};"]},{"cell_type":"markdown","id":"a53261d2","source":["We continue by defining the class `Human` which derives from `SphericalAgent`."]},{"cell_type":"code","id":"71c326cd","source":["class Human : public SphericalAgent {\n","  BDM_AGENT_HEADER(Human, SphericalAgent, 1);\n","\n"," public:\n","  Human() {}\n","  explicit Human(const Real3& position) : Base(position) {}\n","  virtual ~Human() {}\n","\n","  void GiveBirth();\n","  void Initialize(const NewAgentEvent& event) override;\n","};"]},{"cell_type":"markdown","id":"0fcf5d2b","source":["The implementation of `GiveBirth` only requires two lines of code. <br>"]},{"cell_type":"code","id":"99ad043e","source":["void Human::GiveBirth() {\n","    ChildBirthEvent event;\n","    CreateNewAgents(event, {this});\n","}"]},{"cell_type":"markdown","id":"07dec17c","source":["First, creating an instance of the event. <br>\n","Second, invoking `CreateNewAgents` function which is defined in class `Agent`.\n","\n","The first parameter of `CreateNewAgents` takes an event object, and the second a vector of agent prototypes.\n","The size of this vector determines how many new agents will be created. \n","In our case: one. If twins should be born we could change it to `CreateNewAgents(event, {this, this});`.\n","\n","But why do we have to pass a list of agent pointers to the function?\n","\n","The answer is simple: we have to tell `CreateNewAgents` which agent type it should create. \n","In our use case we want to create another instance of class `Human`. Therefore, we pass the `this` pointer.\n","\n","The only part missing is to tell BioDynaMo how to initialize the attributes of the new child.\n","This decision is encapsulated in the `Initialize` function which we override from the base class.\n","Don't forget to also call the implementation of the base class using `Base::Initialize(event)`.\n","Otherwise the initialization of the base class is skipped.\n","\n","In our example we define that the child should be created next to the mother in 3D space. "]},{"cell_type":"code","id":"e0cb0aa4","source":["void Human::Initialize(const NewAgentEvent& event) {\n","    Base::Initialize(event);\n","    auto* mother = bdm_static_cast<Human*>(event.existing_agent);\n","    SetPosition(mother->GetPosition() + Real3{2, 0, 0});\n","}"]},{"cell_type":"markdown","id":"51d74f7d","source":["This concludes all required building blocks. Let's try it out!"]},{"cell_type":"code","id":"8eb0fea1","source":["auto* human = new Human();\n","ctxt->AddAgent(human);"]},{"cell_type":"code","id":"8dea1e59","source":["human->GiveBirth();"]},{"cell_type":"code","id":"044c370a","source":["scheduler->Simulate(1);\n","VisualizeInNotebook();"]},{"cell_type":"markdown","id":"66a018d2","source":["As expected the simulation consists of two \"humans\".\n","\n","----\n","\n","Let's take this one step further.\n","Let's assume that class `Human` was provided in a library that we don't want to modify.\n","However, we want to add two more attributes: \n","* the number of offsprings\n","* the mitochondiral dna (Note: the mitochondrial dna is inherited solely from the mother)\n","\n","Let's create a new class called `MyHuman` which derives from `Human` and which adds these two attributes."]},{"cell_type":"code","id":"1bdfdd23","source":["using MitochondrialDNA = int;"]},{"cell_type":"code","id":"b4d66427","source":["class MyHuman : public Human {\n","  BDM_AGENT_HEADER(MyHuman, Human, 1);\n","\n"," public:\n","  MyHuman() {}\n","  explicit MyHuman(const Real3& position) : Base(position) {}\n","  virtual ~MyHuman() {}\n","\n","  void Initialize(const NewAgentEvent& event) override;\n","  void Update(const NewAgentEvent& event) override;\n","\n","  int num_offsprings_ = 0;\n","  MitochondrialDNA mdna_;\n","};"]},{"cell_type":"markdown","id":"496ee37f","source":["As in the example above, the `Initialize` method is used to set the attributes during new agent events.\n","In this example, we have to set the mitochondrial dna of the child to the value from the mother.\n","The following function definition does exactly that and prints out the value."]},{"cell_type":"code","id":"b6b5c460","source":["void MyHuman::Initialize(const NewAgentEvent& event) {\n","    Base::Initialize(event);\n","    auto* mother = bdm_static_cast<MyHuman*>(event.existing_agent);\n","    mdna_ = mother->mdna_;\n","    std::cout << \"Initialize child attributes: mitochondrial dna set to \"\n","              << mdna_ << std::endl;\n","}"]},{"cell_type":"markdown","id":"3672e873","source":["The only task left is to update the attributes of the mother. This is done by overriding the `Update` method.\n","Again, do not forget to call the implementation of the base class for correctness.\n","We increment the `num_offsprings_` attribute by the number of newly created agents.\n","Although we could just have incremented the attribute by one, the solution below is generic enough to handle e.g. twin births."]},{"cell_type":"code","id":"6f9c863b","source":["void MyHuman::Update(const NewAgentEvent& event) {\n","    Base::Update(event);\n","    num_offsprings_ += event.new_agents.size();\n","    std::cout << \"Update mother attributes: num_offsprings incremented to \"\n","              << num_offsprings_ << std::endl;\n","}"]},{"cell_type":"markdown","id":"1c1529d1","source":["Let's create a new `MyHuman`, set its mitochondrial dna to `123` and output the current value of `num_offsprings_`, which we expect to be `0`."]},{"cell_type":"code","id":"522e3ee8","source":["auto* my_human = new MyHuman();\n","my_human->mdna_ = 123;\n","my_human->num_offsprings_"]},{"cell_type":"markdown","id":"a3b9d99a","source":["Now we can call `GiveBirth` again. We expect the output of two lines.\n","* The first coming from the child informing us about the initialization of its `mdna_` attribute\n","* and the second from the mother telling us about the update of `num_offsprings_`"]},{"cell_type":"code","id":"e430fb7b","source":["my_human->GiveBirth();"]},{"cell_type":"markdown","id":"a8dbeaae","source":["To real_t check, let's output the value of `num_offsprings`, which we expect to be 1"]},{"cell_type":"code","id":"64620dde","source":["my_human->num_offsprings_"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST06-environment-search.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"35b1e478","source":["# Environment search\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we will show how to execute a function for each neighbor of an agent."]},{"cell_type":"markdown","id":"2082b703","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"11ca5e41","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"markdown","id":"4c86850d","source":["We create three agents in a row along the x-axis with identical y and z values."]},{"cell_type":"code","id":"2401012a","source":["auto* ctxt = simulation.GetExecutionContext();\n","\n","auto* a0 = new SphericalAgent({10, 0, 0});\n","auto* a1 = new SphericalAgent({20, 0, 0});\n","auto* a2 = new SphericalAgent({30, 0, 0});\n","\n","a0->SetDiameter(11);\n","a1->SetDiameter(11);\n","a2->SetDiameter(11);\n","\n","ctxt->AddAgent(a0);\n","ctxt->AddAgent(a1);\n","ctxt->AddAgent(a2);"]},{"cell_type":"markdown","id":"3ab3a953","source":["We finalize the initialization and update the environment so it can be used later.\n","Please not that this is usually done automatically inside `Scheduler::Simulate`."]},{"cell_type":"code","id":"8f0d4544","source":["simulation.GetScheduler()->FinalizeInitialization();\n","simulation.GetEnvironment()->Update();\n","VisualizeInNotebook();"]},{"cell_type":"markdown","id":"282ea396","source":["Let's define the function that we want to execute for each neighbor. It prints the unique id of the neighbor and its distance from the querying agent."]},{"cell_type":"code","id":"a4da75e5","source":["auto print_id_distance = L2F([](Agent* a, real_t squared_distance) {\n","  std::cout << \"Neighbor \" << a->GetUid() << \"  with distance: \" \n","            << std::sqrt(squared_distance) << std::endl;\n","});"]},{"cell_type":"markdown","id":"62da5578","source":["The agents have the following ids (in order of increasing x-value)\n","0-0, 1-0, 2-0\n","\n","We start by executing print_id_distance for the first agent. We ask for all neighbors within distance 101.\n","Therefore the function should be executed for the agent in the middle with id 1-0"]},{"cell_type":"code","id":"eb14d94e","source":["ctxt->ForEachNeighbor(print_id_distance, *a0, 101);"]},{"cell_type":"markdown","id":"6e8096bb","source":["Let's repeat the experiment for the middle agent. We expect to see two lines for the left and right neighbor."]},{"cell_type":"code","id":"22ba95a1","source":["ctxt->ForEachNeighbor(print_id_distance, *a1, 101);"]},{"cell_type":"markdown","id":"10639340","source":["Lastly, we want to execute the function `print_id_distance` for all neighbors of the righ-most agent. We expect to see one line printing the middle agent as neighbor (1-0)"]},{"cell_type":"code","id":"f8e1ec99","source":["ctxt->ForEachNeighbor(print_id_distance, *a2, 101);"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST07-multi-scale-simulation.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"bb375e54","source":["# Multi-scale simulations\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we will show how BioDynaMo support multi-scale simulations. \n","Multi-scale simulation means that simulated processes happen in different time-scales---e.g. substance diffusion and neurite growth."]},{"cell_type":"markdown","id":"d2e32028","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"3654007a","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"markdown","id":"7b63e9cb","source":["We define a new [standalone operation](https://biodynamo.org/docs/userguide/operation/) which only task is to print the current simulation time step if it is executed."]},{"cell_type":"code","id":"f336788b","source":["struct TestOp : public StandaloneOperationImpl {\n","  BDM_OP_HEADER(TestOp);\n","  void operator()() override {\n","    auto* scheduler = Simulation::GetActive()->GetScheduler();\n","    auto* param = Simulation::GetActive()->GetParam();\n","    std::cout << \"Processing iteration \" \n","              << scheduler->GetSimulatedSteps() \n","              << \" simulation time \"\n","              << scheduler->GetSimulatedSteps() * param->simulation_time_step\n","              << std::endl; \n","  }\n","};\n","OperationRegistry::GetInstance()->AddOperationImpl(\n","    \"test_op\", OpComputeTarget::kCpu, new TestOp());"]},{"cell_type":"code","id":"b6187081","source":["auto set_param = [](Param * param) {\n","    param->simulation_time_step = 2;\n","};\n","Simulation simulation(\"my-simulation\", set_param);"]},{"cell_type":"markdown","id":"ab605e19","source":["Our initial model consists of one agent at origin."]},{"cell_type":"code","id":"8bc5851d","source":["auto* ctxt = simulation.GetExecutionContext();\n","ctxt->AddAgent(new SphericalAgent());"]},{"cell_type":"markdown","id":"5b395ab8","source":["Let's create a new instance of our class `TestOp` and add it to the scheduler."]},{"cell_type":"code","id":"d74d3d77","source":["auto* op1 = NewOperation(\"test_op\");\n","auto* scheduler = simulation.GetScheduler();\n","scheduler->ScheduleOp(op1);"]},{"cell_type":"markdown","id":"72100a54","source":["Let's simulate 9 steps. We expect that `op1` will be called each time step."]},{"cell_type":"code","id":"fb044c02","source":["scheduler->Simulate(9);"]},{"cell_type":"markdown","id":"1e9571e0","source":["Operations have a frequency attribute which specifies how often it will be executed.\n","An operation with frequency one will be executed at every time step; an operation with frequency two every second, and so on."]},{"cell_type":"code","id":"71568cbb","source":["op1->frequency_= 3;\n","scheduler->Simulate(9);"]},{"cell_type":"markdown","id":"b55860a3","source":["This functionality can be used to set the frequency of different processes in an agent-based model."]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST08-histograms.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"59a444f2","source":["# Create a histogram of agent attributes\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we will show how to create a histogram of all agent diameters in the simulation and fit a function to the data."]},{"cell_type":"markdown","id":"b2c4e70d","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"96f8df86","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"markdown","id":"4826bcd8","source":["We want to define a function that creates a cell at a certain position with diameters drawn from a gaussian distribution with $\\mu=20$ and $\\sigma=5$.\n","The smallest diameter should be larger then $2.0$."]},{"cell_type":"code","id":"55d54a85","source":["simulation.GetResourceManager()->ClearAgents();\n","auto rng = simulation.GetRandom()->GetGausRng(20, 5);\n","auto create_cell = [&](const Real3& position) {\n","  Cell* cell = new Cell(position);\n","  real_t diameter = std::max(2.0, rng.Sample());\n","  cell->SetDiameter(diameter);\n","  return cell;\n","};"]},{"cell_type":"markdown","id":"b75a38d5","source":["Now that we defined `create_cell` we can use it to create 400 cells on a plane with $z = 0$, $xmin = ymin = -200$, $xmax = ymax = 200$, and spacing = 20 in both dimensions."]},{"cell_type":"code","id":"16dfac9d","source":["auto f = [](const real_t* x, const real_t* params) { return 0.0; };\n","ModelInitializer::CreateAgentsOnSurface(f, {}, -200, 200, 20, -200, 200, 20, \n","                                        create_cell);\n","simulation.GetScheduler()->FinalizeInitialization();\n","VisualizeInNotebook(300, 300);"]},{"cell_type":"markdown","id":"e39ad15d","source":["The next step is to create a histogram object with 100 bins in the interval [2, 40].<br>\n","The second line creates a function which fills the histogram with the diameter of the given agent.<br>\n","The third line calls the function `fill` for each agent, thus adding all diameters to the histogram."]},{"cell_type":"code","id":"1b668a6f","source":["TH1F h(\"myHisto\",\"Agent Diameter Histogram;Diameter;Count\", 100, 2, 40);\n","auto fill = L2F([&](Agent* a, AgentHandle){ h.Fill(a->GetDiameter()); });\n","simulation.GetResourceManager()->ForEachAgent(fill);"]},{"cell_type":"markdown","id":"f72003ca","source":["Let's draw the final histogram.<br>\n","Before we have to create a `TCanvas` object in order to display the result in this notebook.<br>\n","We also modify the default color and create a grid."]},{"cell_type":"code","id":"922bdaff","source":["TCanvas c(\"\", \"\", 400, 300);\n","h.SetFillColor(kBlue - 10);\n","c.SetGrid();\n","h.Draw();\n","c.Draw();"]},{"cell_type":"markdown","id":"66975011","source":["Finally, we can try to fit a function to the data in the histogram.<br>\n","Since we drew samples from a gaussian random number generator when we created our cells, we expect that a gaussian will fit our data."]},{"cell_type":"code","id":"a5692df4","source":["h.Fit(\"gaus\", \"S\");\n","h.Draw();\n","c.Draw();"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST09-timeseries-plotting-basic.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"27e05215","source":["# Simulation time series plotting (basics)\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we show how to collect data during the simulation and plot it at the end.<br>\n","To this extent, we create a simulation where cells divide rapidly leading to exponential growth."]},{"cell_type":"markdown","id":"61e7a91d","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"ef7edf86","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"code","id":"46333689","source":["using namespace bdm::experimental;"]},{"cell_type":"code","id":"6921b944","source":["auto set_param = [](Param* param) {\n","    param->simulation_time_step = 1.0;\n","};\n","Simulation simulation(\"MySimulation\", set_param);"]},{"cell_type":"markdown","id":"81271f84","source":["Let's create a behavior which divides cells with $10\\%$ probability in each time step.<br>\n","New cells should also get this behavior.<br>\n","Therefore, we have to call `AlwaysCopyToNew()`. <br>\n","Otherwise, we would only see linear growth."]},{"cell_type":"code","id":"55a9d0bd","source":["StatelessBehavior rapid_division([](Agent* agent) {\n","  if (Simulation::GetActive()->GetRandom()->Uniform() < 0.1) {\n","    bdm_static_cast<Cell*>(agent)->Divide();\n","  }\n","});\n","rapid_division.AlwaysCopyToNew();"]},{"cell_type":"markdown","id":"efac4965","source":["Let's create a function that creates a cell at a specific position, with diameter = 10, and the `rapid_division` behavior."]},{"cell_type":"code","id":"a50d084a","source":["auto create_cell = [](const Real3& position) {\n","  Cell* cell = new Cell(position);\n","  cell->SetDiameter(10);\n","  cell->AddBehavior(rapid_division.NewCopy());\n","  return cell;\n","};"]},{"cell_type":"markdown","id":"f7738e8f","source":["As starting condition we want to create 100 cells randomly distributed in a cube with $min = 0, max = 200$"]},{"cell_type":"code","id":"bac61f01","source":["simulation.GetResourceManager()->ClearAgents();\n","ModelInitializer::CreateAgentsRandom(0, 200, 100, create_cell);\n","simulation.GetScheduler()->FinalizeInitialization();\n","VisualizeInNotebook();"]},{"cell_type":"markdown","id":"273d7037","source":["Before we start the simulation, we have to tell BioDynaMo which data to collect.<br>\n","We can do this with the `TimeSeries::AddCollector` function.\n","In this example we are interested in the number of agents.<br>"]},{"cell_type":"code","id":"8b3d62c1","source":["auto* ts = simulation.GetTimeSeries();\n","auto get_num_agents = [](Simulation* sim) {\n","  return static_cast<real_t>(sim->GetResourceManager()->GetNumAgents());\n","};\n","ts->AddCollector(\"num-agents\", get_num_agents);"]},{"cell_type":"markdown","id":"f3f4783d","source":["Now let's simulate until there are 4000 agents in the simulation"]},{"cell_type":"code","id":"1ce235bb","source":["auto exit_condition = [](){\n","    auto* rm = Simulation::GetActive()->GetResourceManager();\n","    return rm->GetNumAgents() > 4000;\n","};\n","simulation.GetScheduler()->SimulateUntil(exit_condition);"]},{"cell_type":"markdown","id":"b9a24d69","source":["Now we can plot how the number of agents (in this case cells) evolved over time."]},{"cell_type":"code","id":"a7e92b2b","source":["LineGraph g(ts, \"My result\", \"Time\", \"Number of agents\", true, nullptr, 500, 300);\n","g.Add(\"num-agents\", \"Number of Agents\");\n","g.Draw();"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST10-timeseries-plotting-and-analysis.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"32a23b2c","source":["# Simulation time series plotting and analysis\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we show how to collect data during the simulation, and plot and analyse it at the end.<br>\n","To this extent, we create a simulation where cells divide rapidly leading to exponential growth."]},{"cell_type":"markdown","id":"f05fc59b","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"ef7edf86","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"code","id":"38f30ea8","source":["using namespace bdm::experimental;"]},{"cell_type":"code","id":"3b033786","source":["auto set_param = [](Param* param) {\n","    param->simulation_time_step = 1.0;\n","};\n","Simulation simulation(\"MySimulation\", set_param);"]},{"cell_type":"markdown","id":"f9dac184","source":["Let's create a behavior which divides cells with $5\\%$ probability in each time step.<br>\n","New cells should also get this behavior.<br>\n","Therefore, we have to call `AlwaysCopyToNew()`. <br>\n","Otherwise, we would only see linear growth."]},{"cell_type":"code","id":"55a9d0bd","source":["StatelessBehavior rapid_division([](Agent* agent) {\n","  if (Simulation::GetActive()->GetRandom()->Uniform() < 0.05) {\n","    bdm_static_cast<Cell*>(agent)->Divide();\n","  }\n","});\n","rapid_division.AlwaysCopyToNew();"]},{"cell_type":"markdown","id":"d55bc904","source":["Let's create a function that creates a cell at a specific position, with diameter = 10, and the `rapid_division` behavior."]},{"cell_type":"code","id":"a50d084a","source":["auto create_cell = [](const Real3& position) {\n","  Cell* cell = new Cell(position);\n","  cell->SetDiameter(10);\n","  cell->AddBehavior(rapid_division.NewCopy());\n","  return cell;\n","};"]},{"cell_type":"markdown","id":"306f90b8","source":["As starting condition we want to create 100 cells randomly distributed in a cube with $min = 0, max = 200$"]},{"cell_type":"code","id":"bac61f01","source":["simulation.GetResourceManager()->ClearAgents();\n","ModelInitializer::CreateAgentsRandom(0, 200, 100, create_cell);\n","simulation.GetScheduler()->FinalizeInitialization();\n","VisualizeInNotebook();"]},{"cell_type":"markdown","id":"c35e0f44","source":["Before we start the simulation, we have to tell BioDynaMo which data to collect.<br>\n","We can do this with the TimeSeries::AddCollector function. <br>\n","In this example we are interested in the number of agents ..."]},{"cell_type":"code","id":"8b3d62c1","source":["auto* ts = simulation.GetTimeSeries();\n","auto get_num_agents = [](Simulation* sim) {\n","  return static_cast<real_t>(sim->GetResourceManager()->GetNumAgents());\n","};\n","ts->AddCollector(\"num-agents\", get_num_agents);"]},{"cell_type":"markdown","id":"7b6353cd","source":["...  and the number agents with $diameter < 5$.<br>\n","We create a condition `cond` and pass it to an instance of `Counter` which calculates the number of agents for which `cond(agent)` evaluates to true."]},{"cell_type":"code","id":"fe964505","source":["auto cond = [](Agent* a) { return a->GetDiameter() < 5; };\n","ts->AddCollector(\"agents_lt_5\", new bdm::experimental::Counter<real_t>(cond));"]},{"cell_type":"markdown","id":"e014efbf","source":["Now let's simulate 40 iterations"]},{"cell_type":"code","id":"1ce235bb","source":["simulation.GetScheduler()->Simulate(40);"]},{"cell_type":"markdown","id":"1718298b","source":["Now we can plot how the number of agents (in this case cells) and the number of agents with $diameter < 5$ evolved over time."]},{"cell_type":"code","id":"a7e92b2b","source":["LineGraph g(ts, \"my result\", \"Time\", \"Number of agents\", \n","                               true, nullptr, 500, 300);\n","g.Add(\"num-agents\", \"Number of Agents\", \"L\", kBlue);\n","g.Add(\"agents_lt_5\", \"Number of Agents diam < 5\", \"L\", kGreen);\n","g.Draw();"]},{"cell_type":"markdown","id":"74fcca1f","source":["Let's try to fit an exponential function to verify our assumption that the cells grew exponentially.<br>\n","Please visit the [ROOT user-guide](https://root.cern.ch/root/htmldoc/guides/users-guide/FittingHistograms.html) for more information regarding fitting "]},{"cell_type":"code","id":"7aa6ad92","source":["auto fitresult = g.GetTGraphs(\"num-agents\")[0]->Fit(\"expo\", \"S\");\n","g.Draw();"]},{"cell_type":"markdown","id":"6b395b71","source":["Indeed, the number of agents follow an exponential function $$y = \\exp(slope * x + constant)$$ with constant = 4.6 and slope = 0.049\n","This corresponds to the division probability of $0.05$ "]},{"cell_type":"markdown","id":"3f2b70b1","source":["This is how to change the color after the creation of `g`.<br>\n","Also the position of the legend can be optimized."]},{"cell_type":"code","id":"1c53fe3e","source":["g.GetTGraphs(\"num-agents\")[0]->SetLineColor(kBlack);\n","g.SetLegendPos(1, 500, 20, 700);\n","g.Draw();"]},{"cell_type":"markdown","id":"64245848","source":["Let's save these results in multiple formats"]},{"cell_type":"code","id":"92d716a1","source":["g.SaveAs(Concat(simulation.GetOutputDir(), \"/line-graph\"), \n","         {\".root\", \".svg\", \".png\", \".C\"});"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST11-multiple-experiments-statistical-analysis.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"27e05215","source":["# Multiple experiments and statistical analysis\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we show how to collect and analyse data from multiple experiments.<br>\n","To this extent, we create a simulation where cells divide rapidly leading to exponential growth."]},{"cell_type":"markdown","id":"302c3309","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"ef7edf86","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"code","id":"c5d8d40b","source":["using namespace bdm::experimental;"]},{"cell_type":"code","id":"adc6bce5","source":["real_t gDivProb = 0.05;"]},{"cell_type":"markdown","id":"102c177f","source":["We use the same simulation as in `ST09-timeseries-plotting-basic`. \n","It is a simulation were agents divide with a specific division probability in each time step leading to exponential growth. We collect the number of agents in each time step.\n","Have a look at `ST09-timeseries-plotting-basic` for more information. \n","\n","We wrap the required simulation code in a function called `Experiment` which takes two parameters:\n","* the collected result data from a single invocation (output param)\n","* the division probability parameter "]},{"cell_type":"code","id":"4b5c3f40","source":["void Experiment(TimeSeries* result, real_t division_probability) {\n","    gDivProb = division_probability;\n","    \n","    auto set_param = [](Param* param) {\n","        param->simulation_time_step = 1.0;\n","    };\n","    Simulation simulation(\"MySimulation\", set_param);\n","    \n","    StatelessBehavior rapid_division([](Agent* agent) {\n","      if (Simulation::GetActive()->GetRandom()->Uniform() < gDivProb) {\n","        bdm_static_cast<Cell*>(agent)->Divide();\n","      }\n","    });\n","    rapid_division.AlwaysCopyToNew();\n","    \n","    auto create_cell = [&](const Real3& position) {\n","      Cell* cell = new Cell(position);\n","      cell->SetDiameter(10);\n","      cell->AddBehavior(rapid_division.NewCopy());\n","      return cell;\n","    };\n","    \n","    simulation.GetResourceManager()->ClearAgents();\n","    ModelInitializer::CreateAgentsRandom(0, 200, 100, create_cell);\n","    simulation.GetScheduler()->FinalizeInitialization();\n","    \n","    auto* ts = simulation.GetTimeSeries();\n","    auto get_num_agents = [](Simulation* sim) {\n","      return static_cast<real_t>(sim->GetResourceManager()->GetNumAgents());\n","    };\n","    ts->AddCollector(\"num-agents\", get_num_agents);\n","    \n","    simulation.GetScheduler()->Simulate(40);\n","    \n","    // move collected time series data from simulation to object result\n","    *result = std::move(*simulation.GetTimeSeries());\n","}"]},{"cell_type":"markdown","id":"f4f7b3b8","source":["We want to run our experiment for 10 times with a different division probability parameter.\n","We choose the division probability randomly between 0.04 and 0.06"]},{"cell_type":"code","id":"c115283f","source":["std::vector<TimeSeries> individual_results(10);\n","Random rnd;\n","for(auto& ir : individual_results) {\n","    Experiment(&ir, rnd.Uniform(0.04, 0.06));\n","}"]},{"cell_type":"markdown","id":"d78ace15","source":["In the next step we want to combine the individual results. Therefore we calculate the mean, and min (error low), and max (error high) and store it in a merged `TimeSeries` object."]},{"cell_type":"code","id":"52af58c2","source":["TimeSeries merged;\n","auto merger = [](const std::vector<real_t>& all_ys, \n","                  real_t* y, real_t* eh, real_t* el) {\n","    *y = TMath::Mean(all_ys.begin(), all_ys.end());\n","    *el = *y - *TMath::LocMin(all_ys.begin(), all_ys.end());\n","    *eh = *TMath::LocMax(all_ys.begin(), all_ys.end()) - *y;\n","};\n","TimeSeries::Merge(&merged, individual_results, merger);"]},{"cell_type":"markdown","id":"7fbecc45","source":["Now we can print the merged results and see how the simulations evolved over time, and how they differed from each other."]},{"cell_type":"code","id":"ebd013ea","source":["LineGraph g(&merged, \"My result\", \"Time\", \"Number of agents\", false, nullptr, 500, 300);\n","g.Add(\"num-agents\", \"Number of Agents\", \"LP\", kBlue);\n","g.Draw();"]},{"cell_type":"markdown","id":"cb193f1d","source":["Finally, let's fit an exponential function to the data."]},{"cell_type":"code","id":"130bb51e","source":["g.GetTMultiGraph()->Fit(\"expo\", \"S\");\n","g.Draw()"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST12-hierarchical-model.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"cf421e00","source":["# Hierarchical model support\n","\n","**Author: Lukas Breitwieser**<br>\n","Some models require to update certain agents before others.\n","In this tutorial we show how to execute operations first for large agents and afterwards for small ones.\n","Lastly, we demonstrate how to run a different set of operations for large and for small agents."]},{"cell_type":"markdown","id":"700c09a6","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"3654007a","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"markdown","id":"4ae01b7f","source":["To make this demo easier to understand, we turn off multi-threading and load balancing. "]},{"cell_type":"code","id":"78277bc9","source":["omp_set_num_threads(1);\n","ThreadInfo::GetInstance()->Renew();\n","auto* scheduler = simulation.GetScheduler();\n","scheduler->UnscheduleOp(scheduler->GetOps(\"load balancing\")[0]);"]},{"cell_type":"markdown","id":"2c6850fe","source":["We create a new agent operation which prints out its name and the diameter of the agent it is processing"]},{"cell_type":"code","id":"f336788b","source":["struct TestOp : public AgentOperationImpl {\n","  BDM_OP_HEADER(TestOp);\n","  void operator()(Agent* agent) override {\n","    std::cout << name << \" processing agent with diameter \" \n","              << agent->GetDiameter() << endl; \n","  }\n","  std::string name = \"\";\n","};\n","OperationRegistry::GetInstance()->AddOperationImpl(\n","    \"test_op\", OpComputeTarget::kCpu, new TestOp());"]},{"cell_type":"markdown","id":"79e02ac2","source":["We create four agents with diameter `{20, 10, 20, 10}`"]},{"cell_type":"code","id":"8bc5851d","source":["auto* ctxt = simulation.GetExecutionContext();\n","for (int i = 0; i < 4; ++i) {\n","    real_t diameter = i % 2 == 0 ? 20 : 10;\n","    ctxt->AddAgent(new SphericalAgent(diameter));\n","}"]},{"cell_type":"markdown","id":"01f04ed6","source":["We add the new operation to the simulation"]},{"cell_type":"code","id":"d74d3d77","source":["auto* op1 = NewOperation(\"test_op\");\n","scheduler->ScheduleOp(op1);"]},{"cell_type":"markdown","id":"4aca92f2","source":["Let's simulate one time step and observe the default behavior of BioDynaMo.\n","We expect that the agents are processed in the order they were added (`{20, 10, 20, 10}`)"]},{"cell_type":"code","id":"fb044c02","source":["scheduler->Simulate(1);"]},{"cell_type":"markdown","id":"45ad99d6","source":["Now we want to define the group of large and small agents and tell BioDynaMo that large agents should be processed before small ones. \n","\n","This can be done with the following three lines of code."]},{"cell_type":"code","id":"ad4b226b","source":["auto small_filter = L2F([](Agent* a) { return a->GetDiameter() < 15; });\n","auto large_filter = L2F([](Agent* a) { return a->GetDiameter() >= 15; });\n","scheduler->SetAgentFilters({&large_filter, &small_filter});"]},{"cell_type":"markdown","id":"25366858","source":["Let's observe if the output has changed. We expect to see first the large agents `{20, 20}`,  followed by the small ones `{10, 10}`."]},{"cell_type":"code","id":"d0858e54","source":["scheduler->Simulate(1);"]},{"cell_type":"markdown","id":"72e2980e","source":["Let's create two more instances of our `TestOp`.\n","We define that:\n","* `op1` should be run for all agents (large and small).\n","* `op2` only for small agents\n","* `op3` only for large agents"]},{"cell_type":"code","id":"f6761123","source":["auto* op2 = NewOperation(\"test_op\");\n","auto* op3 = NewOperation(\"test_op\");\n","\n","op1->GetImplementation<TestOp>()->name = \"OpAll      \";\n","op2->GetImplementation<TestOp>()->name = \"OpOnlySmall\";\n","op3->GetImplementation<TestOp>()->name = \"OpOnlyLarge\";\n","\n","op2->SetExcludeFilters({&large_filter});\n","op3->SetExcludeFilters({&small_filter});\n","\n","scheduler->ScheduleOp(op2);\n","scheduler->ScheduleOp(op3);"]},{"cell_type":"markdown","id":"73aeefb9","source":["Now we want to execute another time step with the updated model. We expect that for each agent two operations will be executed. \n","\n","For large agents `OpAll` and `OpOnlyLarge` and for small agents `OpAll` and `OpOnlySmall`.\n","As before, we expect that first all large agents are executed, followed by all small agents."]},{"cell_type":"code","id":"b13e0354","source":["scheduler->Simulate(1);"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST13-dynamic-scheduling.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"a81151f9","source":["# Dynamic scheduling\n","\n","**Author: Lukas Breitwieser**<br>\n","This tutorial demonstrates that behaviors and operations can be added and removed during the simulation.\n","This feature provides maximum flexibility to control which functions will be executed during the lifetime of a simulation."]},{"cell_type":"markdown","id":"ef10be44","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"201082b4","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"code","id":"d1d5fdc4","source":["auto* ctxt = simulation.GetExecutionContext();\n","auto* scheduler = simulation.GetScheduler();"]},{"cell_type":"markdown","id":"09c18d30","source":["Define a helper variable"]},{"cell_type":"code","id":"c39d7149","source":["int test_op_id = 0;"]},{"cell_type":"markdown","id":"f0506762","source":["We define a standalone operation `TestOp` which prints out that it got executed and which removes itself from the list of scheduled operations afterwards. The same principles apply also for agent operations."]},{"cell_type":"code","id":"d650b370","source":["struct TestOp : public StandaloneOperationImpl {\n","  BDM_OP_HEADER(TestOp);\n","  void operator()() override {\n","    auto* scheduler = Simulation::GetActive()->GetScheduler();\n","    std::cout << name << \" processing iteration \" \n","              << scheduler->GetSimulatedSteps() \n","              << std::endl; \n","\n","    auto* op = scheduler->GetOps(\"test_op\")[test_op_id++];\n","    scheduler->UnscheduleOp(op);\n","      \n","    std::cout << \"  \" << name \n","          << \" removed itself from the simulation \" << std::endl;\n","  }\n","  std::string name = \"\";\n","};\n","OperationRegistry::GetInstance()->AddOperationImpl(\n","    \"test_op\", OpComputeTarget::kCpu, new TestOp());"]},{"cell_type":"markdown","id":"08de84e8","source":["Let's define a little helper function which creates a new instance of `TestOp` and adds it to the list of scheduled operations."]},{"cell_type":"code","id":"59162209","source":["void AddNewTestOpToSim(const std::string& name) {\n","    auto* op = NewOperation(\"test_op\");\n","    op->GetImplementation<TestOp>()->name = name;\n","    scheduler->ScheduleOp(op);\n","}"]},{"cell_type":"markdown","id":"5301eb93","source":["Let's define a new behavior `b2` which prints out when it gets executed and which adds a new operation with name `OP2` to the simulation if a condition is met.\n","\n","In this scenario the condition is defined as `simulation time step == 1`."]},{"cell_type":"code","id":"62f14b53","source":["StatelessBehavior b2([](Agent* agent) {\n","    std::cout << \"B2 \" << agent->GetUid() << std::endl;\n","    if (simulation.GetScheduler()->GetSimulatedSteps() == 1) {\n","        AddNewTestOpToSim(\"OP2\");\n","        std::cout << \"  B2 added OP2 to the simulation\" << std::endl;\n","    }\n","});"]},{"cell_type":"markdown","id":"1f724a55","source":["We define another behavior `b1` which prints out when it gets executed, removes itself from the agent, and which adds behavior `b2` to the agent."]},{"cell_type":"code","id":"af44d774","source":["StatelessBehavior b1([](Agent* agent) {\n","    std::cout << \"B1 \" << agent->GetUid() << std::endl;\n","    agent->RemoveBehavior(agent->GetAllBehaviors()[0]);\n","    std::cout << \"  B1 removed itself from agent \" << agent->GetUid() << std::endl;\n","    agent->AddBehavior(b2.NewCopy());\n","    std::cout << \"  B1 added B2 to agent \" << agent->GetUid() << std::endl;\n","});"]},{"cell_type":"markdown","id":"de61161c","source":["Now all required building blocks are ready. Let's define the initial model: a single agent with behavior `b1`."]},{"cell_type":"code","id":"8d36312f","source":["auto* agent = new SphericalAgent();\n","agent->AddBehavior(b1.NewCopy());\n","ctxt->AddAgent(agent);"]},{"cell_type":"markdown","id":"af9d3f69","source":["We also add a new operation to the simulation."]},{"cell_type":"code","id":"c7a1189f","source":["AddNewTestOpToSim(\"OP1\");"]},{"cell_type":"markdown","id":"3e7b7086","source":["Let's simulate one iteration and think about the expected output.\n","* Since we initialized our only agent with behavior `b1`, we expect to see a line `B1 0-0`\n","* Furthermore, `b1` will print a line to inform us that it removed itself from the agent, and that it added behavior `b2` to the agent.\n","* Because changes are applied immediately (using the default `InPlaceExecCtxt`) also `B2` will be executed. However the condition inside `b2` is not met.\n","* Next we expect an output from `OP1` telling us that it got executed.\n","* Lastly, we expect an output from `OP1` to tell is that it removed itself from the simulation."]},{"cell_type":"code","id":"e78cf8b9","source":["scheduler->Simulate(1);"]},{"cell_type":"markdown","id":"f5f7837a","source":["Let's simulate another iteration.<br>\n","This time we only expect output from `B2`.\n","Remember that `B1` and `OP1` have been removed in the last iteration.\n","\n","This time the condition in `B2` is met and we expect to see an output line to tell us that a new instance of `TestOp` with name `OP2` has been added to the simulation."]},{"cell_type":"code","id":"be462af4","source":["scheduler->Simulate(1);"]},{"cell_type":"markdown","id":"8803ce5e","source":["Let's simulate another iteration.\n","This time we expect an output from `B2` whose condition is not met in this iterations, and from `OP2` that it got executed and removed from the simulation."]},{"cell_type":"code","id":"0943f9aa","source":["scheduler->Simulate(1);"]},{"cell_type":"markdown","id":"b21667f1","source":["Let's simulate one last iteration.\n","`OP2` removed itself in the last iteration. Therefore, only `B2` should be left. The condition of `B2` is not met. "]},{"cell_type":"code","id":"325eb8a5","source":["scheduler->Simulate(1);"]},{"cell_type":"markdown","id":"4fd1e20c","source":["In summary: \n","We initialized the simulation with `B1` and `OP1`.\n","\n","In iteration:\n","\n","0. B1 removed, B2 added, OP1 removed\n","1. OP2 added\n","2. OP2 removed"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST14-randomize-iteration-order.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"d82aa08c","source":["# Randomize iteration order\n","\n","**Author: Lukas Breitwieser**<br>\n","In this tutorial we show how to randomize the order that BioDynaMo uses in each iteration to process the agents."]},{"cell_type":"markdown","id":"0f2eccf9","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"e78c1565","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"markdown","id":"73bfe0f7","source":["Let's create two helper functions:\n","* `AddAgents` to add four agents to the simulation\n","* `print_uid` which prints the uid of the given agent"]},{"cell_type":"code","id":"d6280097","source":["void AddAgents(ResourceManager* rm) {\n","    for (int i = 0; i < 4; ++i) {\n","        rm->AddAgent(new SphericalAgent());\n","    }\n","}\n","auto print_uid = [](Agent* a) { \n","  std::cout << a->GetUid() << std::endl;\n","};"]},{"cell_type":"markdown","id":"7124c420","source":["We define an experiment which \n","1. takes a simulation object as input\n","2. adds four agents\n","3. calls `print_uid` for each agent\n","4. print a separator so we can distinguish the output of the two different time steps\n","4. advances to the next time step\n","5. calls `print_uid` for each agent again"]},{"cell_type":"code","id":"e15b1ee4","source":["void Experiment(Simulation* sim) {\n","    auto* rm = sim->GetResourceManager();\n","    AddAgents(rm);\n","    \n","    rm->ForEachAgent(print_uid);\n","    rm->EndOfIteration();\n","    std::cout << \"-----------------\" << std::endl;\n","    rm->ForEachAgent(print_uid);\n","}"]},{"cell_type":"markdown","id":"1ac0256b","source":["The default behavior of BioDynaMo is to iterate over the agents in the order they were added (not taking multi-threading and load balancing into account). Therefore, we expect to see the same order twice."]},{"cell_type":"code","id":"a50ec22e","source":["Experiment(&simulation)"]},{"cell_type":"markdown","id":"77e55b34","source":["BioDynaMo also provides a wrapper called `RandomizedRm`, which, as the name suggests, randomizes the iteration order after each iteration. It just takes two lines to add this functionality to the simulation."]},{"cell_type":"code","id":"08de3470","source":["Simulation simulation(\"my-sim\");\n","auto* rand_rm = new RandomizedRm<ResourceManager>();\n","simulation.SetResourceManager(rand_rm);"]},{"cell_type":"markdown","id":"619abd2d","source":["Let's run our experiment again. This time with the simulation which has a randomized resource manager. We expect two different orders."]},{"cell_type":"code","id":"710d474f","source":["Experiment(&simulation)"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}},{"fileRelativePath":"biodynamo/notebooks/ST15-replace-interaction-force.ipynb","json":{"nbformat_minor":5,"cells":[{"cell_type":"markdown","id":"744e5067","source":["# Replace mechanical interaction force\n","\n","**Author: Lukas Breitwieser**<br>\n","This tutorial demonstrates how to replace BioDynaMo's default interaction force with a user-defined one.\n","The interaction force is used to calculate forces between agent pairs that are in physical contact with each other."]},{"cell_type":"markdown","id":"220dbe96","source":["Let's start by setting up BioDynaMo notebooks."]},{"cell_type":"code","id":"cc6fcee9","source":["%jsroot on\n","gROOT->LoadMacro(\"${BDMSYS}/etc/rootlogon.C\");"]},{"cell_type":"code","id":"0e1fdc1a","source":["#include \"core/operation/mechanical_forces_op.h\""]},{"cell_type":"markdown","id":"821c1990","source":["We modify the `simulation_max_displacement` parameter to better visualize the difference of the user-defined force that we will add."]},{"cell_type":"code","id":"0dd52b08","source":["auto set_param = [](Param* p) {\n","    p->simulation_max_displacement = 50;\n","};\n","Simulation simulation(\"my-simulation\", set_param);"]},{"cell_type":"markdown","id":"4a798834","source":["In our experiment we create two overlapping cells and visualize the starting condition."]},{"cell_type":"code","id":"38207a67","source":["void Experiment() {\n","    simulation.GetResourceManager()->ClearAgents();\n","    auto* ctxt = simulation.GetExecutionContext();\n","    auto* scheduler = simulation.GetScheduler();\n","    \n","    auto* cell1 = new Cell({0, 0, 0});\n","    auto* cell2 = new Cell({10, 0, 0});\n","    cell1->SetDiameter(20);\n","    cell2->SetDiameter(20);\n","    cell1->SetMass(0.1);\n","    cell2->SetMass(0.1);\n","\n","    ctxt->AddAgent(cell1);\n","    ctxt->AddAgent(cell2);\n","    \n","    scheduler->FinalizeInitialization();\n","    VisualizeInNotebook();\n","}"]},{"cell_type":"markdown","id":"4c558d1e","source":["Let's run our experiment and have a look at the visualization."]},{"cell_type":"code","id":"b8b6889c","source":["Experiment();"]},{"cell_type":"markdown","id":"e4b46995","source":["We continue by simulating 10 iterations and observe how the mechanical force pushed the two cells away from each other, until they don't overlap anymore."]},{"cell_type":"code","id":"e3e20ef1","source":["auto* scheduler = simulation.GetScheduler();\n","scheduler->Simulate(10);\n","VisualizeInNotebook();"]},{"cell_type":"markdown","id":"f28bf2eb","source":["Now we want to add our user-defined force implementation. \n","First, we have to subclass `InteractionForce` and implement our force. \n","In this case, it is an extremely simple (and unrealistic) implementation."]},{"cell_type":"code","id":"a123cee0","source":["class MyInteractionForce : public InteractionForce {\n","  public:\n","    MyInteractionForce() {}\n","    virtual ~MyInteractionForce() {}\n","    \n","    Real4 Calculate(const Agent* lhs, const Agent* rhs) const override {\n","        if (lhs < rhs) {\n","            return {100, 0, 0, 0};\n","        } else {\n","            return {-100, 0, 0, 0};\n","        }\n","    }\n","    \n","    InteractionForce* NewCopy() const override { return new MyInteractionForce(); }\n","};"]},{"cell_type":"markdown","id":"b141ec01","source":["With the following three lines we instruct BioDynaMo to use our new `MyInteractionForce` instead of the default implementation."]},{"cell_type":"code","id":"d2b6d8e8","source":["auto* myforce = new MyInteractionForce();\n","auto* op = scheduler->GetOps(\"mechanical forces\")[0];\n","op->GetImplementation<MechanicalForcesOp>()->SetInteractionForce(myforce);"]},{"cell_type":"markdown","id":"938d808b","source":["We create the same starting condition as before."]},{"cell_type":"code","id":"6f1d4b1e","source":["Experiment();"]},{"cell_type":"markdown","id":"d5e4f1af","source":["Because `myforce` is so strong, it is sufficient to simulate only one iteration to clearly see its impact."]},{"cell_type":"code","id":"597840f2","source":["auto* scheduler = simulation.GetScheduler();\n","scheduler->Simulate(1);\n","VisualizeInNotebook();"]}],"nbformat":4},"metadata":{"ipub":null,"kernelspec":{"display_name":"ROOT C++","language":"c++","name":"root"},"language_info":{"file_extension":".C","mimetype":" text/x-c++src","name":"c++"}}}]}},"pageContext":{}},
    "staticQueryHashes": []}